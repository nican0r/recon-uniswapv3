/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/NoDelegateCall.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity =0.7.6;
  3 |     | 
  4 |     | /// @title Prevents delegatecall to a contract
  5 |     | /// @notice Base contract that provides a modifier for preventing delegatecall to methods in a child contract
  6 |     | abstract contract NoDelegateCall {
  7 |     |     /// @dev The original address of this contract
  8 |     |     address private immutable original;
  9 |     | 
 10 |     |     constructor() {
 11 |     |         // Immutables are computed in the init code of the contract, and then inlined into the deployed bytecode.
 12 |     |         // In other words, this variable won't change when it's checked at runtime.
 13 | *   |         original = address(this);
 14 |     |     }
 15 |     | 
 16 |     |     /// @dev Private method is used instead of inlining into modifier because modifiers are copied into each method,
 17 |     |     ///     and the use of immutable means the address bytes are copied in every place the modifier is used.
 18 | *   |     function checkNotDelegateCall() private view {
 19 | *   |         require(address(this) == original);
 20 |     |     }
 21 |     | 
 22 |     |     /// @notice Prevents delegatecall into the modified method
 23 |     |     modifier noDelegateCall() {
 24 | *   |         checkNotDelegateCall();
 25 | *   |         _;
 26 |     |     }
 27 |     | }
 28 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/UniswapV3Factory.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity =0.7.6;
  3 |     | 
  4 |     | import './interfaces/IUniswapV3Factory.sol';
  5 |     | 
  6 |     | import './UniswapV3PoolDeployer.sol';
  7 |     | import './NoDelegateCall.sol';
  8 |     | 
  9 |     | import './UniswapV3Pool.sol';
 10 |     | 
 11 |     | /// @title Canonical Uniswap V3 factory
 12 |     | /// @notice Deploys Uniswap V3 pools and manages ownership and control over pool protocol fees
 13 | *   | contract UniswapV3Factory is IUniswapV3Factory, UniswapV3PoolDeployer, NoDelegateCall {
 14 |     |     /// @inheritdoc IUniswapV3Factory
 15 |     |     address public override owner;
 16 |     | 
 17 |     |     /// @inheritdoc IUniswapV3Factory
 18 |     |     mapping(uint24 => int24) public override feeAmountTickSpacing;
 19 |     |     /// @inheritdoc IUniswapV3Factory
 20 | *   |     mapping(address => mapping(address => mapping(uint24 => address))) public override getPool;
 21 |     | 
 22 | *   |     constructor() {
 23 |     |         owner = msg.sender;
 24 |     |         emit OwnerChanged(address(0), msg.sender);
 25 |     | 
 26 |     |         feeAmountTickSpacing[500] = 10;
 27 |     |         emit FeeAmountEnabled(500, 10);
 28 |     |         feeAmountTickSpacing[3000] = 60;
 29 |     |         emit FeeAmountEnabled(3000, 60);
 30 |     |         feeAmountTickSpacing[10000] = 200;
 31 |     |         emit FeeAmountEnabled(10000, 200);
 32 |     |     }
 33 |     | 
 34 |     |     /// @inheritdoc IUniswapV3Factory
 35 | *   |     function createPool(
 36 |     |         address tokenA,
 37 |     |         address tokenB,
 38 |     |         uint24 fee
 39 | *   |     ) external override noDelegateCall returns (address pool) {
 40 | *   |         require(tokenA != tokenB);
 41 | *   |         (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
 42 | *   |         require(token0 != address(0));
 43 | *   |         int24 tickSpacing = feeAmountTickSpacing[fee];
 44 | *   |         require(tickSpacing != 0);
 45 | *   |         require(getPool[token0][token1][fee] == address(0));
 46 | *   |         pool = deploy(address(this), token0, token1, fee, tickSpacing);
 47 | *   |         getPool[token0][token1][fee] = pool;
 48 |     |         // populate mapping in the reverse direction, deliberate choice to avoid the cost of comparing addresses
 49 | *   |         getPool[token1][token0][fee] = pool;
 50 | *   |         emit PoolCreated(token0, token1, fee, tickSpacing, pool);
 51 |     |     }
 52 |     | 
 53 |     |     /// @inheritdoc IUniswapV3Factory
 54 |     |     function setOwner(address _owner) external override {
 55 |     |         require(msg.sender == owner);
 56 |     |         emit OwnerChanged(owner, _owner);
 57 |     |         owner = _owner;
 58 |     |     }
 59 |     | 
 60 |     |     /// @inheritdoc IUniswapV3Factory
 61 |     |     function enableFeeAmount(uint24 fee, int24 tickSpacing) public override {
 62 |     |         require(msg.sender == owner);
 63 |     |         require(fee < 1000000);
 64 |     |         // tick spacing is capped at 16384 to prevent the situation where tickSpacing is so large that
 65 |     |         // TickBitmap#nextInitializedTickWithinOneWord overflows int24 container from a valid tick
 66 |     |         // 16384 ticks represents a >5x price change with ticks of 1 bips
 67 |     |         require(tickSpacing > 0 && tickSpacing < 16384);
 68 |     |         require(feeAmountTickSpacing[fee] == 0);
 69 |     | 
 70 |     |         feeAmountTickSpacing[fee] = tickSpacing;
 71 |     |         emit FeeAmountEnabled(fee, tickSpacing);
 72 |     |     }
 73 |     | }
 74 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/UniswapV3Pool.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity =0.7.6;
   3 |     | 
   4 |     | import './interfaces/IUniswapV3Pool.sol';
   5 |     | 
   6 |     | import './NoDelegateCall.sol';
   7 |     | 
   8 |     | import './libraries/LowGasSafeMath.sol';
   9 |     | import './libraries/SafeCast.sol';
  10 |     | import './libraries/Tick.sol';
  11 |     | import './libraries/TickBitmap.sol';
  12 |     | import './libraries/Position.sol';
  13 |     | import './libraries/Oracle.sol';
  14 |     | 
  15 |     | import './libraries/FullMath.sol';
  16 |     | import './libraries/FixedPoint128.sol';
  17 |     | import './libraries/TransferHelper.sol';
  18 |     | import './libraries/TickMath.sol';
  19 |     | import './libraries/LiquidityMath.sol';
  20 |     | import './libraries/SqrtPriceMath.sol';
  21 |     | import './libraries/SwapMath.sol';
  22 |     | 
  23 |     | import './interfaces/IUniswapV3PoolDeployer.sol';
  24 |     | import './interfaces/IUniswapV3Factory.sol';
  25 |     | import './interfaces/IERC20Minimal.sol';
  26 |     | import './interfaces/callback/IUniswapV3MintCallback.sol';
  27 |     | import './interfaces/callback/IUniswapV3SwapCallback.sol';
  28 |     | import './interfaces/callback/IUniswapV3FlashCallback.sol';
  29 |     | 
  30 | *   | contract UniswapV3Pool is IUniswapV3Pool, NoDelegateCall {
  31 |     |     using LowGasSafeMath for uint256;
  32 |     |     using LowGasSafeMath for int256;
  33 |     |     using SafeCast for uint256;
  34 |     |     using SafeCast for int256;
  35 |     |     using Tick for mapping(int24 => Tick.Info);
  36 |     |     using TickBitmap for mapping(int16 => uint256);
  37 |     |     using Position for mapping(bytes32 => Position.Info);
  38 |     |     using Position for Position.Info;
  39 |     |     using Oracle for Oracle.Observation[65535];
  40 |     | 
  41 |     |     /// @inheritdoc IUniswapV3PoolImmutables
  42 |     |     address public immutable override factory;
  43 |     |     /// @inheritdoc IUniswapV3PoolImmutables
  44 | *   |     address public immutable override token0;
  45 |     |     /// @inheritdoc IUniswapV3PoolImmutables
  46 |     |     address public immutable override token1;
  47 |     |     /// @inheritdoc IUniswapV3PoolImmutables
  48 |     |     uint24 public immutable override fee;
  49 |     | 
  50 |     |     /// @inheritdoc IUniswapV3PoolImmutables
  51 |     |     int24 public immutable override tickSpacing;
  52 |     | 
  53 |     |     /// @inheritdoc IUniswapV3PoolImmutables
  54 |     |     uint128 public immutable override maxLiquidityPerTick;
  55 |     | 
  56 |     |     struct Slot0 {
  57 |     |         // the current price
  58 |     |         uint160 sqrtPriceX96;
  59 |     |         // the current tick
  60 |     |         int24 tick;
  61 |     |         // the most-recently updated index of the observations array
  62 |     |         uint16 observationIndex;
  63 |     |         // the current maximum number of observations that are being stored
  64 |     |         uint16 observationCardinality;
  65 |     |         // the next maximum number of observations to store, triggered in observations.write
  66 |     |         uint16 observationCardinalityNext;
  67 |     |         // the current protocol fee as a percentage of the swap fee taken on withdrawal
  68 |     |         // represented as an integer denominator (1/x)%
  69 |     |         uint8 feeProtocol;
  70 |     |         // whether the pool is locked
  71 |     |         bool unlocked;
  72 |     |     }
  73 |     |     /// @inheritdoc IUniswapV3PoolState
  74 | *   |     Slot0 public override slot0;
  75 |     | 
  76 |     |     /// @inheritdoc IUniswapV3PoolState
  77 |     |     uint256 public override feeGrowthGlobal0X128;
  78 |     |     /// @inheritdoc IUniswapV3PoolState
  79 | *   |     uint256 public override feeGrowthGlobal1X128;
  80 |     | 
  81 |     |     // accumulated protocol fees in token0/token1 units
  82 |     |     struct ProtocolFees {
  83 |     |         uint128 token0;
  84 |     |         uint128 token1;
  85 |     |     }
  86 |     |     /// @inheritdoc IUniswapV3PoolState
  87 | *   |     ProtocolFees public override protocolFees;
  88 |     | 
  89 |     |     /// @inheritdoc IUniswapV3PoolState
  90 | *   |     uint128 public override liquidity;
  91 |     | 
  92 |     |     /// @inheritdoc IUniswapV3PoolState
  93 | *   |     mapping(int24 => Tick.Info) public override ticks;
  94 |     |     /// @inheritdoc IUniswapV3PoolState
  95 |     |     mapping(int16 => uint256) public override tickBitmap;
  96 |     |     /// @inheritdoc IUniswapV3PoolState
  97 |     |     mapping(bytes32 => Position.Info) public override positions;
  98 |     |     /// @inheritdoc IUniswapV3PoolState
  99 | *   |     Oracle.Observation[65535] public override observations;
 100 |     | 
 101 |     |     /// @dev Mutually exclusive reentrancy protection into the pool to/from a method. This method also prevents entrance
 102 |     |     /// to a function before the pool is initialized. The reentrancy guard is required throughout the contract because
 103 |     |     /// we use balance checks to determine the payment status of interactions such as mint, swap and flash.
 104 |     |     modifier lock() {
 105 | *   |         require(slot0.unlocked, 'LOK');
 106 |     |         slot0.unlocked = false;
 107 |     |         _;
 108 | *   |         slot0.unlocked = true;
 109 |     |     }
 110 |     | 
 111 |     |     /// @dev Prevents calling a function from anyone except the address returned by IUniswapV3Factory#owner()
 112 |     |     modifier onlyFactoryOwner() {
 113 |     |         require(msg.sender == IUniswapV3Factory(factory).owner());
 114 |     |         _;
 115 |     |     }
 116 |     | 
 117 | *   |     constructor() {
 118 | *   |         int24 _tickSpacing;
 119 | *   |         (factory, token0, token1, fee, _tickSpacing) = IUniswapV3PoolDeployer(msg.sender).parameters();
 120 |     |         tickSpacing = _tickSpacing;
 121 |     | 
 122 |     |         maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(_tickSpacing);
 123 |     |     }
 124 |     | 
 125 |     |     /// @dev Common checks for valid tick inputs.
 126 | *   |     function checkTicks(int24 tickLower, int24 tickUpper) private pure {
 127 | *   |         require(tickLower < tickUpper, 'TLU');
 128 | *   |         require(tickLower >= TickMath.MIN_TICK, 'TLM');
 129 | *   |         require(tickUpper <= TickMath.MAX_TICK, 'TUM');
 130 |     |     }
 131 |     | 
 132 |     |     /// @dev Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.
 133 | *   |     function _blockTimestamp() internal view virtual returns (uint32) {
 134 | *   |         return uint32(block.timestamp); // truncation is desired
 135 |     |     }
 136 |     | 
 137 |     |     /// @dev Get the pool's balance of token0
 138 |     |     /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
 139 |     |     /// check
 140 | *   |     function balance0() private view returns (uint256) {
 141 | *   |         (bool success, bytes memory data) = token0.staticcall(
 142 | *   |             abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this))
 143 |     |         );
 144 | *   |         require(success && data.length >= 32);
 145 | *   |         return abi.decode(data, (uint256));
 146 |     |     }
 147 |     | 
 148 |     |     /// @dev Get the pool's balance of token1
 149 |     |     /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
 150 |     |     /// check
 151 | *   |     function balance1() private view returns (uint256) {
 152 | *   |         (bool success, bytes memory data) = token1.staticcall(
 153 | *   |             abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this))
 154 |     |         );
 155 |     |         require(success && data.length >= 32);
 156 |     |         return abi.decode(data, (uint256));
 157 |     |     }
 158 |     | 
 159 |     |     /// @inheritdoc IUniswapV3PoolDerivedState
 160 |     |     function snapshotCumulativesInside(
 161 |     |         int24 tickLower,
 162 |     |         int24 tickUpper
 163 |     |     )
 164 |     |         external
 165 |     |         view
 166 |     |         override
 167 |     |         noDelegateCall
 168 |     |         returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside)
 169 |     |     {
 170 |     |         checkTicks(tickLower, tickUpper);
 171 |     | 
 172 |     |         int56 tickCumulativeLower;
 173 |     |         int56 tickCumulativeUpper;
 174 |     |         uint160 secondsPerLiquidityOutsideLowerX128;
 175 |     |         uint160 secondsPerLiquidityOutsideUpperX128;
 176 |     |         uint32 secondsOutsideLower;
 177 |     |         uint32 secondsOutsideUpper;
 178 |     | 
 179 |     |         {
 180 |     |             Tick.Info storage lower = ticks[tickLower];
 181 |     |             Tick.Info storage upper = ticks[tickUpper];
 182 |     |             bool initializedLower;
 183 |     |             (tickCumulativeLower, secondsPerLiquidityOutsideLowerX128, secondsOutsideLower, initializedLower) = (
 184 |     |                 lower.tickCumulativeOutside,
 185 |     |                 lower.secondsPerLiquidityOutsideX128,
 186 |     |                 lower.secondsOutside,
 187 |     |                 lower.initialized
 188 |     |             );
 189 |     |             require(initializedLower);
 190 |     | 
 191 |     |             bool initializedUpper;
 192 |     |             (tickCumulativeUpper, secondsPerLiquidityOutsideUpperX128, secondsOutsideUpper, initializedUpper) = (
 193 |     |                 upper.tickCumulativeOutside,
 194 |     |                 upper.secondsPerLiquidityOutsideX128,
 195 |     |                 upper.secondsOutside,
 196 |     |                 upper.initialized
 197 |     |             );
 198 |     |             require(initializedUpper);
 199 |     |         }
 200 |     | 
 201 |     |         Slot0 memory _slot0 = slot0;
 202 |     | 
 203 |     |         if (_slot0.tick < tickLower) {
 204 |     |             return (
 205 |     |                 tickCumulativeLower - tickCumulativeUpper,
 206 |     |                 secondsPerLiquidityOutsideLowerX128 - secondsPerLiquidityOutsideUpperX128,
 207 |     |                 secondsOutsideLower - secondsOutsideUpper
 208 |     |             );
 209 |     |         } else if (_slot0.tick < tickUpper) {
 210 |     |             uint32 time = _blockTimestamp();
 211 |     |             (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) = observations.observeSingle(
 212 |     |                 time,
 213 |     |                 0,
 214 |     |                 _slot0.tick,
 215 |     |                 _slot0.observationIndex,
 216 |     |                 liquidity,
 217 |     |                 _slot0.observationCardinality
 218 |     |             );
 219 |     |             return (
 220 |     |                 tickCumulative - tickCumulativeLower - tickCumulativeUpper,
 221 |     |                 secondsPerLiquidityCumulativeX128 -
 222 |     |                     secondsPerLiquidityOutsideLowerX128 -
 223 |     |                     secondsPerLiquidityOutsideUpperX128,
 224 |     |                 time - secondsOutsideLower - secondsOutsideUpper
 225 |     |             );
 226 |     |         } else {
 227 |     |             return (
 228 |     |                 tickCumulativeUpper - tickCumulativeLower,
 229 |     |                 secondsPerLiquidityOutsideUpperX128 - secondsPerLiquidityOutsideLowerX128,
 230 |     |                 secondsOutsideUpper - secondsOutsideLower
 231 |     |             );
 232 |     |         }
 233 |     |     }
 234 |     | 
 235 |     |     /// @inheritdoc IUniswapV3PoolDerivedState
 236 |     |     function observe(
 237 |     |         uint32[] calldata secondsAgos
 238 |     |     )
 239 |     |         external
 240 |     |         view
 241 |     |         override
 242 |     |         noDelegateCall
 243 |     |         returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s)
 244 |     |     {
 245 |     |         return
 246 |     |             observations.observe(
 247 |     |                 _blockTimestamp(),
 248 |     |                 secondsAgos,
 249 |     |                 slot0.tick,
 250 |     |                 slot0.observationIndex,
 251 |     |                 liquidity,
 252 |     |                 slot0.observationCardinality
 253 |     |             );
 254 |     |     }
 255 |     | 
 256 |     |     /// @inheritdoc IUniswapV3PoolActions
 257 |     |     function increaseObservationCardinalityNext(
 258 |     |         uint16 observationCardinalityNext
 259 |     |     ) external override lock noDelegateCall {
 260 |     |         uint16 observationCardinalityNextOld = slot0.observationCardinalityNext; // for the event
 261 |     |         uint16 observationCardinalityNextNew = observations.grow(
 262 |     |             observationCardinalityNextOld,
 263 |     |             observationCardinalityNext
 264 |     |         );
 265 |     |         slot0.observationCardinalityNext = observationCardinalityNextNew;
 266 |     |         if (observationCardinalityNextOld != observationCardinalityNextNew)
 267 |     |             emit IncreaseObservationCardinalityNext(observationCardinalityNextOld, observationCardinalityNextNew);
 268 |     |     }
 269 |     | 
 270 |     |     /// @inheritdoc IUniswapV3PoolActions
 271 |     |     /// @dev not locked because it initializes unlocked
 272 | *   |     function initialize(uint160 sqrtPriceX96) external override {
 273 | *   |         require(slot0.sqrtPriceX96 == 0, 'AI');
 274 |     | 
 275 |     |         int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);
 276 |     | 
 277 | *   |         (uint16 cardinality, uint16 cardinalityNext) = observations.initialize(_blockTimestamp());
 278 |     | 
 279 | *   |         slot0 = Slot0({
 280 |     |             sqrtPriceX96: sqrtPriceX96,
 281 |     |             tick: tick,
 282 |     |             observationIndex: 0,
 283 |     |             observationCardinality: cardinality,
 284 |     |             observationCardinalityNext: cardinalityNext,
 285 |     |             feeProtocol: 0,
 286 |     |             unlocked: true
 287 |     |         });
 288 |     | 
 289 | *   |         emit Initialize(sqrtPriceX96, tick);
 290 |     |     }
 291 |     | 
 292 |     |     struct ModifyPositionParams {
 293 |     |         // the address that owns the position
 294 |     |         address owner;
 295 |     |         // the lower and upper tick of the position
 296 |     |         int24 tickLower;
 297 |     |         int24 tickUpper;
 298 |     |         // any change in liquidity
 299 |     |         int128 liquidityDelta;
 300 |     |     }
 301 |     | 
 302 |     |     /// @dev Effect some changes to a position
 303 |     |     /// @param params the position details and the change to the position's liquidity to effect
 304 |     |     /// @return position a storage pointer referencing the position with the given owner and tick range
 305 |     |     /// @return amount0 the amount of token0 owed to the pool, negative if the pool should pay the recipient
 306 |     |     /// @return amount1 the amount of token1 owed to the pool, negative if the pool should pay the recipient
 307 | *   |     function _modifyPosition(
 308 |     |         ModifyPositionParams memory params
 309 |     |     ) private noDelegateCall returns (Position.Info storage position, int256 amount0, int256 amount1) {
 310 | *   |         checkTicks(params.tickLower, params.tickUpper);
 311 |     | 
 312 | *   |         Slot0 memory _slot0 = slot0; // SLOAD for gas optimization
 313 |     | 
 314 | *   |         position = _updatePosition(
 315 | *   |             params.owner,
 316 | *   |             params.tickLower,
 317 | *   |             params.tickUpper,
 318 | *   |             params.liquidityDelta,
 319 |     |             _slot0.tick
 320 |     |         );
 321 |     | 
 322 | *   |         if (params.liquidityDelta != 0) {
 323 | *   |             if (_slot0.tick < params.tickLower) {
 324 |     |                 // current tick is below the passed range; liquidity can only become in range by crossing from left to
 325 |     |                 // right, when we'll need _more_ token0 (it's becoming more valuable) so user must provide it
 326 | *   |                 amount0 = SqrtPriceMath.getAmount0Delta(
 327 | *   |                     TickMath.getSqrtRatioAtTick(params.tickLower),
 328 | *   |                     TickMath.getSqrtRatioAtTick(params.tickUpper),
 329 | *   |                     params.liquidityDelta
 330 |     |                 );
 331 | *   |             } else if (_slot0.tick < params.tickUpper) {
 332 |     |                 // current tick is inside the passed range
 333 | *   |                 uint128 liquidityBefore = liquidity; // SLOAD for gas optimization
 334 |     | 
 335 |     |                 // write an oracle entry
 336 | *   |                 (slot0.observationIndex, slot0.observationCardinality) = observations.write(
 337 | *   |                     _slot0.observationIndex,
 338 | *   |                     _blockTimestamp(),
 339 | *   |                     _slot0.tick,
 340 | *   |                     liquidityBefore,
 341 | *   |                     _slot0.observationCardinality,
 342 | *   |                     _slot0.observationCardinalityNext
 343 |     |                 );
 344 |     | 
 345 | *   |                 amount0 = SqrtPriceMath.getAmount0Delta(
 346 | *   |                     _slot0.sqrtPriceX96,
 347 | *   |                     TickMath.getSqrtRatioAtTick(params.tickUpper),
 348 | *   |                     params.liquidityDelta
 349 |     |                 );
 350 | *   |                 amount1 = SqrtPriceMath.getAmount1Delta(
 351 | *   |                     TickMath.getSqrtRatioAtTick(params.tickLower),
 352 | *   |                     _slot0.sqrtPriceX96,
 353 | *   |                     params.liquidityDelta
 354 |     |                 );
 355 |     | 
 356 | *   |                 liquidity = LiquidityMath.addDelta(liquidityBefore, params.liquidityDelta);
 357 |     |             } else {
 358 |     |                 // current tick is above the passed range; liquidity can only become in range by crossing from right to
 359 |     |                 // left, when we'll need _more_ token1 (it's becoming more valuable) so user must provide it
 360 | *   |                 amount1 = SqrtPriceMath.getAmount1Delta(
 361 | *   |                     TickMath.getSqrtRatioAtTick(params.tickLower),
 362 | *   |                     TickMath.getSqrtRatioAtTick(params.tickUpper),
 363 | *   |                     params.liquidityDelta
 364 |     |                 );
 365 |     |             }
 366 |     |         }
 367 |     |     }
 368 |     | 
 369 |     |     /// @dev Gets and updates a position with the given liquidity delta
 370 |     |     /// @param owner the owner of the position
 371 |     |     /// @param tickLower the lower tick of the position's tick range
 372 |     |     /// @param tickUpper the upper tick of the position's tick range
 373 |     |     /// @param tick the current tick, passed to avoid sloads
 374 | *   |     function _updatePosition(
 375 |     |         address owner,
 376 |     |         int24 tickLower,
 377 |     |         int24 tickUpper,
 378 |     |         int128 liquidityDelta,
 379 |     |         int24 tick
 380 |     |     ) private returns (Position.Info storage position) {
 381 |     |         position = positions.get(owner, tickLower, tickUpper);
 382 |     | 
 383 |     |         uint256 _feeGrowthGlobal0X128 = feeGrowthGlobal0X128; // SLOAD for gas optimization
 384 |     |         uint256 _feeGrowthGlobal1X128 = feeGrowthGlobal1X128; // SLOAD for gas optimization
 385 |     | 
 386 |     |         // if we need to update the ticks, do it
 387 |     |         bool flippedLower;
 388 |     |         bool flippedUpper;
 389 | *   |         if (liquidityDelta != 0) {
 390 | *   |             uint32 time = _blockTimestamp();
 391 | *   |             (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) = observations.observeSingle(
 392 |     |                 time,
 393 |     |                 0,
 394 | *   |                 slot0.tick,
 395 | *   |                 slot0.observationIndex,
 396 | *   |                 liquidity,
 397 | *   |                 slot0.observationCardinality
 398 |     |             );
 399 |     | 
 400 | *   |             flippedLower = ticks.update(
 401 | *   |                 tickLower,
 402 | *   |                 tick,
 403 | *   |                 liquidityDelta,
 404 | *   |                 _feeGrowthGlobal0X128,
 405 | *   |                 _feeGrowthGlobal1X128,
 406 |     |                 secondsPerLiquidityCumulativeX128,
 407 |     |                 tickCumulative,
 408 | *   |                 time,
 409 | *   |                 false,
 410 | *   |                 maxLiquidityPerTick
 411 |     |             );
 412 | *   |             flippedUpper = ticks.update(
 413 | *   |                 tickUpper,
 414 | *   |                 tick,
 415 | *   |                 liquidityDelta,
 416 | *   |                 _feeGrowthGlobal0X128,
 417 | *   |                 _feeGrowthGlobal1X128,
 418 | *   |                 secondsPerLiquidityCumulativeX128,
 419 | *   |                 tickCumulative,
 420 | *   |                 time,
 421 | *   |                 true,
 422 | *   |                 maxLiquidityPerTick
 423 |     |             );
 424 |     | 
 425 | *   |             if (flippedLower) {
 426 | *   |                 tickBitmap.flipTick(tickLower, tickSpacing);
 427 |     |             }
 428 | *   |             if (flippedUpper) {
 429 | *   |                 tickBitmap.flipTick(tickUpper, tickSpacing);
 430 |     |             }
 431 |     |         }
 432 |     | 
 433 | *   |         (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) = ticks.getFeeGrowthInside(
 434 | *   |             tickLower,
 435 | *   |             tickUpper,
 436 | *   |             tick,
 437 | *   |             _feeGrowthGlobal0X128,
 438 | *   |             _feeGrowthGlobal1X128
 439 |     |         );
 440 |     | 
 441 | *   |         position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);
 442 |     | 
 443 |     |         // clear any tick data that is no longer needed
 444 | *   |         if (liquidityDelta < 0) {
 445 | *   |             if (flippedLower) {
 446 | *   |                 ticks.clear(tickLower);
 447 |     |             }
 448 | *   |             if (flippedUpper) {
 449 | *   |                 ticks.clear(tickUpper);
 450 |     |             }
 451 |     |         }
 452 |     |     }
 453 |     | 
 454 |     |     /// @inheritdoc IUniswapV3PoolActions
 455 |     |     /// @dev noDelegateCall is applied indirectly via _modifyPosition
 456 | *   |     function mint(
 457 |     |         address recipient,
 458 |     |         int24 tickLower,
 459 |     |         int24 tickUpper,
 460 |     |         uint128 amount,
 461 |     |         bytes calldata data
 462 | *   |     ) external override lock returns (uint256 amount0, uint256 amount1) {
 463 |     |         require(amount > 0);
 464 | *   |         (, int256 amount0Int, int256 amount1Int) = _modifyPosition(
 465 | *   |             ModifyPositionParams({
 466 | *   |                 owner: recipient,
 467 |     |                 tickLower: tickLower,
 468 | *   |                 tickUpper: tickUpper,
 469 | *   |                 liquidityDelta: int256(amount).toInt128()
 470 |     |             })
 471 |     |         );
 472 |     | 
 473 | *   |         amount0 = uint256(amount0Int);
 474 | *   |         amount1 = uint256(amount1Int);
 475 |     | 
 476 | *   |         uint256 balance0Before;
 477 | *   |         uint256 balance1Before;
 478 | *   |         if (amount0 > 0) balance0Before = balance0();
 479 | *   |         if (amount1 > 0) balance1Before = balance1();
 480 | *   |         IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(amount0, amount1, data);
 481 | *   |         if (amount0 > 0) require(balance0Before.add(amount0) <= balance0(), 'M0');
 482 | *   |         if (amount1 > 0) require(balance1Before.add(amount1) <= balance1(), 'M1');
 483 |     | 
 484 | *   |         emit Mint(msg.sender, recipient, tickLower, tickUpper, amount, amount0, amount1);
 485 |     |     }
 486 |     | 
 487 |     |     /// @inheritdoc IUniswapV3PoolActions
 488 |     |     function collect(
 489 |     |         address recipient,
 490 |     |         int24 tickLower,
 491 |     |         int24 tickUpper,
 492 |     |         uint128 amount0Requested,
 493 |     |         uint128 amount1Requested
 494 |     |     ) external override lock returns (uint128 amount0, uint128 amount1) {
 495 |     |         // we don't need to checkTicks here, because invalid positions will never have non-zero tokensOwed{0,1}
 496 |     |         Position.Info storage position = positions.get(msg.sender, tickLower, tickUpper);
 497 |     | 
 498 |     |         amount0 = amount0Requested > position.tokensOwed0 ? position.tokensOwed0 : amount0Requested;
 499 |     |         amount1 = amount1Requested > position.tokensOwed1 ? position.tokensOwed1 : amount1Requested;
 500 |     | 
 501 |     |         if (amount0 > 0) {
 502 |     |             position.tokensOwed0 -= amount0;
 503 |     |             TransferHelper.safeTransfer(token0, recipient, amount0);
 504 |     |         }
 505 |     |         if (amount1 > 0) {
 506 |     |             position.tokensOwed1 -= amount1;
 507 |     |             TransferHelper.safeTransfer(token1, recipient, amount1);
 508 |     |         }
 509 |     | 
 510 |     |         emit Collect(msg.sender, recipient, tickLower, tickUpper, amount0, amount1);
 511 |     |     }
 512 |     | 
 513 |     |     /// @inheritdoc IUniswapV3PoolActions
 514 |     |     /// @dev noDelegateCall is applied indirectly via _modifyPosition
 515 |     |     function burn(
 516 |     |         int24 tickLower,
 517 |     |         int24 tickUpper,
 518 |     |         uint128 amount
 519 |     |     ) external override lock returns (uint256 amount0, uint256 amount1) {
 520 |     |         (Position.Info storage position, int256 amount0Int, int256 amount1Int) = _modifyPosition(
 521 |     |             ModifyPositionParams({
 522 |     |                 owner: msg.sender,
 523 |     |                 tickLower: tickLower,
 524 |     |                 tickUpper: tickUpper,
 525 |     |                 liquidityDelta: -int256(amount).toInt128()
 526 |     |             })
 527 |     |         );
 528 |     | 
 529 |     |         amount0 = uint256(-amount0Int);
 530 |     |         amount1 = uint256(-amount1Int);
 531 |     | 
 532 |     |         if (amount0 > 0 || amount1 > 0) {
 533 |     |             (position.tokensOwed0, position.tokensOwed1) = (
 534 |     |                 position.tokensOwed0 + uint128(amount0),
 535 |     |                 position.tokensOwed1 + uint128(amount1)
 536 |     |             );
 537 |     |         }
 538 |     | 
 539 |     |         emit Burn(msg.sender, tickLower, tickUpper, amount, amount0, amount1);
 540 |     |     }
 541 |     | 
 542 |     |     struct SwapCache {
 543 |     |         // the protocol fee for the input token
 544 |     |         uint8 feeProtocol;
 545 |     |         // liquidity at the beginning of the swap
 546 |     |         uint128 liquidityStart;
 547 |     |         // the timestamp of the current block
 548 |     |         uint32 blockTimestamp;
 549 |     |         // the current value of the tick accumulator, computed only if we cross an initialized tick
 550 |     |         int56 tickCumulative;
 551 |     |         // the current value of seconds per liquidity accumulator, computed only if we cross an initialized tick
 552 |     |         uint160 secondsPerLiquidityCumulativeX128;
 553 |     |         // whether we've computed and cached the above two accumulators
 554 |     |         bool computedLatestObservation;
 555 |     |     }
 556 |     | 
 557 |     |     // the top level state of the swap, the results of which are recorded in storage at the end
 558 |     |     struct SwapState {
 559 |     |         // the amount remaining to be swapped in/out of the input/output asset
 560 |     |         int256 amountSpecifiedRemaining;
 561 |     |         // the amount already swapped out/in of the output/input asset
 562 |     |         int256 amountCalculated;
 563 |     |         // current sqrt(price)
 564 |     |         uint160 sqrtPriceX96;
 565 |     |         // the tick associated with the current price
 566 |     |         int24 tick;
 567 |     |         // the global fee growth of the input token
 568 |     |         uint256 feeGrowthGlobalX128;
 569 |     |         // amount of input token paid as protocol fee
 570 |     |         uint128 protocolFee;
 571 |     |         // the current liquidity in range
 572 |     |         uint128 liquidity;
 573 |     |     }
 574 |     | 
 575 |     |     struct StepComputations {
 576 |     |         // the price at the beginning of the step
 577 |     |         uint160 sqrtPriceStartX96;
 578 |     |         // the next tick to swap to from the current tick in the swap direction
 579 |     |         int24 tickNext;
 580 |     |         // whether tickNext is initialized or not
 581 |     |         bool initialized;
 582 |     |         // sqrt(price) for the next tick (1/0)
 583 |     |         uint160 sqrtPriceNextX96;
 584 |     |         // how much is being swapped in in this step
 585 |     |         uint256 amountIn;
 586 |     |         // how much is being swapped out
 587 |     |         uint256 amountOut;
 588 |     |         // how much fee is being paid in
 589 |     |         uint256 feeAmount;
 590 |     |     }
 591 |     | 
 592 |     |     /// @inheritdoc IUniswapV3PoolActions
 593 | *   |     function swap(
 594 |     |         address recipient,
 595 |     |         bool zeroForOne,
 596 |     |         int256 amountSpecified,
 597 |     |         uint160 sqrtPriceLimitX96,
 598 |     |         bytes calldata data
 599 |     |     ) external override noDelegateCall returns (int256 amount0, int256 amount1) {
 600 | *   |         require(amountSpecified != 0, 'AS');
 601 |     | 
 602 | *   |         Slot0 memory slot0Start = slot0;
 603 |     | 
 604 | *   |         require(slot0Start.unlocked, 'LOK');
 605 | *   |         require(
 606 | *   |             zeroForOne
 607 | *   |                 ? sqrtPriceLimitX96 < slot0Start.sqrtPriceX96 && sqrtPriceLimitX96 > TickMath.MIN_SQRT_RATIO
 608 | *   |                 : sqrtPriceLimitX96 > slot0Start.sqrtPriceX96 && sqrtPriceLimitX96 < TickMath.MAX_SQRT_RATIO,
 609 |     |             'SPL'
 610 |     |         );
 611 |     | 
 612 | *   |         slot0.unlocked = false;
 613 |     | 
 614 | *   |         SwapCache memory cache = SwapCache({
 615 | *   |             liquidityStart: liquidity,
 616 | *   |             blockTimestamp: _blockTimestamp(),
 617 | *   |             feeProtocol: zeroForOne ? (slot0Start.feeProtocol % 16) : (slot0Start.feeProtocol >> 4),
 618 |     |             secondsPerLiquidityCumulativeX128: 0,
 619 | *   |             tickCumulative: 0,
 620 |     |             computedLatestObservation: false
 621 |     |         });
 622 |     | 
 623 | *   |         bool exactInput = amountSpecified > 0;
 624 |     | 
 625 | *   |         SwapState memory state = SwapState({
 626 |     |             amountSpecifiedRemaining: amountSpecified,
 627 |     |             amountCalculated: 0,
 628 | *   |             sqrtPriceX96: slot0Start.sqrtPriceX96,
 629 | *   |             tick: slot0Start.tick,
 630 | *   |             feeGrowthGlobalX128: zeroForOne ? feeGrowthGlobal0X128 : feeGrowthGlobal1X128,
 631 | *   |             protocolFee: 0,
 632 |     |             // liquidity: cache.liquidityStart
 633 |     |             // MUTATION change liquidity to 0
 634 |     |             liquidity: 0
 635 |     |         });
 636 |     | 
 637 |     |         // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit
 638 | *   |         while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != sqrtPriceLimitX96) {
 639 | *   |             StepComputations memory step;
 640 |     | 
 641 | *   |             step.sqrtPriceStartX96 = state.sqrtPriceX96;
 642 |     | 
 643 | *   |             (step.tickNext, step.initialized) = tickBitmap.nextInitializedTickWithinOneWord(
 644 | *   |                 state.tick,
 645 | *   |                 tickSpacing,
 646 | *   |                 zeroForOne
 647 |     |             );
 648 |     | 
 649 |     |             // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds
 650 | *   |             if (step.tickNext < TickMath.MIN_TICK) {
 651 | *   |                 step.tickNext = TickMath.MIN_TICK;
 652 | *   |             } else if (step.tickNext > TickMath.MAX_TICK) {
 653 | *   |                 step.tickNext = TickMath.MAX_TICK;
 654 |     |             }
 655 |     | 
 656 |     |             // get the price for the next tick
 657 | *   |             step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);
 658 |     | 
 659 |     |             // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted
 660 | *   |             (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(
 661 | *   |                 state.sqrtPriceX96,
 662 | *   |                 (zeroForOne ? step.sqrtPriceNextX96 < sqrtPriceLimitX96 : step.sqrtPriceNextX96 > sqrtPriceLimitX96)
 663 | *   |                     ? sqrtPriceLimitX96
 664 | *   |                     : step.sqrtPriceNextX96,
 665 | *   |                 state.liquidity,
 666 | *   |                 state.amountSpecifiedRemaining,
 667 | *   |                 fee
 668 |     |             );
 669 |     | 
 670 | *   |             if (exactInput) {
 671 | *   |                 state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();
 672 | *   |                 state.amountCalculated = state.amountCalculated.sub(step.amountOut.toInt256());
 673 |     |             } else {
 674 | *   |                 state.amountSpecifiedRemaining += step.amountOut.toInt256();
 675 | *   |                 state.amountCalculated = state.amountCalculated.add((step.amountIn + step.feeAmount).toInt256());
 676 |     |             }
 677 |     | 
 678 |     |             // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee
 679 | *   |             if (cache.feeProtocol > 0) {
 680 | *   |                 uint256 delta = step.feeAmount / cache.feeProtocol;
 681 | *   |                 step.feeAmount -= delta;
 682 |     |                 state.protocolFee += uint128(delta);
 683 |     |             }
 684 |     | 
 685 |     |             // update global fee tracker
 686 | *   |             if (state.liquidity > 0)
 687 | *   |                 state.feeGrowthGlobalX128 += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);
 688 |     | 
 689 |     |             // shift tick if we reached the next price
 690 | *   |             if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {
 691 |     |                 // if the tick is initialized, run the tick transition
 692 | *   |                 if (step.initialized) {
 693 |     |                     // check for the placeholder value, which we replace with the actual value the first time the swap
 694 |     |                     // crosses an initialized tick
 695 | *   |                     if (!cache.computedLatestObservation) {
 696 | *   |                         (cache.tickCumulative, cache.secondsPerLiquidityCumulativeX128) = observations.observeSingle(
 697 | *   |                             cache.blockTimestamp,
 698 | *   |                             0,
 699 | *   |                             slot0Start.tick,
 700 | *   |                             slot0Start.observationIndex,
 701 | *   |                             cache.liquidityStart,
 702 | *   |                             slot0Start.observationCardinality
 703 |     |                         );
 704 | *   |                         cache.computedLatestObservation = true;
 705 |     |                     }
 706 | *   |                     int128 liquidityNet = ticks.cross(
 707 | *   |                         step.tickNext,
 708 | *   |                         (zeroForOne ? state.feeGrowthGlobalX128 : feeGrowthGlobal0X128),
 709 | *   |                         (zeroForOne ? feeGrowthGlobal1X128 : state.feeGrowthGlobalX128),
 710 | *   |                         cache.secondsPerLiquidityCumulativeX128,
 711 | *   |                         cache.tickCumulative,
 712 |     |                         cache.blockTimestamp
 713 |     |                     );
 714 |     |                     // if we're moving leftward, we interpret liquidityNet as the opposite sign
 715 |     |                     // safe because liquidityNet cannot be type(int128).min
 716 | *   |                     if (zeroForOne) liquidityNet = -liquidityNet;
 717 |     | 
 718 | *   |                     state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);
 719 |     |                 }
 720 |     | 
 721 | *   |                 state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;
 722 | *   |             } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {
 723 |     |                 // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved
 724 | *   |                 state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);
 725 |     |             }
 726 |     |         }
 727 |     | 
 728 |     |         // update tick and write an oracle entry if the tick change
 729 | *   |         if (state.tick != slot0Start.tick) {
 730 | *   |             (uint16 observationIndex, uint16 observationCardinality) = observations.write(
 731 | *   |                 slot0Start.observationIndex,
 732 | *   |                 cache.blockTimestamp,
 733 | *   |                 slot0Start.tick,
 734 | *   |                 cache.liquidityStart,
 735 | *   |                 slot0Start.observationCardinality,
 736 | *   |                 slot0Start.observationCardinalityNext
 737 |     |             );
 738 | *   |             (slot0.sqrtPriceX96, slot0.tick, slot0.observationIndex, slot0.observationCardinality) = (
 739 | *   |                 state.sqrtPriceX96,
 740 | *   |                 state.tick,
 741 |     |                 observationIndex,
 742 |     |                 observationCardinality
 743 |     |             );
 744 |     |         } else {
 745 |     |             // otherwise just update the price
 746 | *   |             slot0.sqrtPriceX96 = state.sqrtPriceX96;
 747 |     |         }
 748 |     | 
 749 |     |         // update liquidity if it changed
 750 | *   |         if (cache.liquidityStart != state.liquidity) liquidity = state.liquidity;
 751 |     | 
 752 |     |         // update fee growth global and, if necessary, protocol fees
 753 |     |         // overflow is acceptable, protocol has to withdraw before it hits type(uint128).max fees
 754 | *   |         if (zeroForOne) {
 755 | *   |             feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;
 756 | *   |             if (state.protocolFee > 0) protocolFees.token0 += state.protocolFee;
 757 |     |         } else {
 758 |     |             feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;
 759 | *   |             if (state.protocolFee > 0) protocolFees.token1 += state.protocolFee;
 760 |     |         }
 761 |     | 
 762 | *   |         (amount0, amount1) = zeroForOne == exactInput
 763 | *   |             ? (amountSpecified - state.amountSpecifiedRemaining, state.amountCalculated)
 764 |     |             : (state.amountCalculated, amountSpecified - state.amountSpecifiedRemaining);
 765 |     | 
 766 |     |         // do the transfers and collect payment
 767 | *   |         if (zeroForOne) {
 768 | *   |             if (amount1 < 0) TransferHelper.safeTransfer(token1, recipient, uint256(-amount1));
 769 |     | 
 770 | *   |             uint256 balance0Before = balance0();
 771 | *   |             IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);
 772 | *   |             require(balance0Before.add(uint256(amount0)) <= balance0(), 'IIA');
 773 |     |         } else {
 774 |     |             if (amount0 < 0) TransferHelper.safeTransfer(token0, recipient, uint256(-amount0));
 775 |     | 
 776 |     |             uint256 balance1Before = balance1();
 777 | *   |             IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);
 778 |     |             require(balance1Before.add(uint256(amount1)) <= balance1(), 'IIA');
 779 |     |         }
 780 |     | 
 781 | *   |         emit Swap(msg.sender, recipient, amount0, amount1, state.sqrtPriceX96, state.liquidity, state.tick);
 782 | *   |         slot0.unlocked = true;
 783 |     |     }
 784 |     | 
 785 |     |     /// @inheritdoc IUniswapV3PoolActions
 786 | *   |     function flash(
 787 |     |         address recipient,
 788 |     |         uint256 amount0,
 789 |     |         uint256 amount1,
 790 |     |         bytes calldata data
 791 |     |     ) external override lock noDelegateCall {
 792 |     |         uint128 _liquidity = liquidity;
 793 |     |         require(_liquidity > 0, 'L');
 794 |     | 
 795 |     |         uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e6);
 796 |     |         uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e6);
 797 |     |         uint256 balance0Before = balance0();
 798 |     |         uint256 balance1Before = balance1();
 799 |     | 
 800 |     |         if (amount0 > 0) TransferHelper.safeTransfer(token0, recipient, amount0);
 801 |     |         if (amount1 > 0) TransferHelper.safeTransfer(token1, recipient, amount1);
 802 |     | 
 803 |     |         IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback(fee0, fee1, data);
 804 |     | 
 805 |     |         uint256 balance0After = balance0();
 806 |     |         uint256 balance1After = balance1();
 807 |     | 
 808 |     |         require(balance0Before.add(fee0) <= balance0After, 'F0');
 809 |     |         require(balance1Before.add(fee1) <= balance1After, 'F1');
 810 |     | 
 811 |     |         // sub is safe because we know balanceAfter is gt balanceBefore by at least fee
 812 |     |         uint256 paid0 = balance0After - balance0Before;
 813 |     |         uint256 paid1 = balance1After - balance1Before;
 814 |     | 
 815 |     |         if (paid0 > 0) {
 816 |     |             uint8 feeProtocol0 = slot0.feeProtocol % 16;
 817 |     |             uint256 fees0 = feeProtocol0 == 0 ? 0 : paid0 / feeProtocol0;
 818 |     |             if (uint128(fees0) > 0) protocolFees.token0 += uint128(fees0);
 819 |     |             feeGrowthGlobal0X128 += FullMath.mulDiv(paid0 - fees0, FixedPoint128.Q128, _liquidity);
 820 |     |         }
 821 |     |         if (paid1 > 0) {
 822 |     |             uint8 feeProtocol1 = slot0.feeProtocol >> 4;
 823 |     |             uint256 fees1 = feeProtocol1 == 0 ? 0 : paid1 / feeProtocol1;
 824 |     |             if (uint128(fees1) > 0) protocolFees.token1 += uint128(fees1);
 825 |     |             feeGrowthGlobal1X128 += FullMath.mulDiv(paid1 - fees1, FixedPoint128.Q128, _liquidity);
 826 |     |         }
 827 |     | 
 828 |     |         emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);
 829 |     |     }
 830 |     | 
 831 |     |     /// @inheritdoc IUniswapV3PoolOwnerActions
 832 |     |     function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external override lock onlyFactoryOwner {
 833 |     |         require(
 834 |     |             (feeProtocol0 == 0 || (feeProtocol0 >= 4 && feeProtocol0 <= 10)) &&
 835 |     |                 (feeProtocol1 == 0 || (feeProtocol1 >= 4 && feeProtocol1 <= 10))
 836 |     |         );
 837 |     |         uint8 feeProtocolOld = slot0.feeProtocol;
 838 |     |         slot0.feeProtocol = feeProtocol0 + (feeProtocol1 << 4);
 839 |     |         emit SetFeeProtocol(feeProtocolOld % 16, feeProtocolOld >> 4, feeProtocol0, feeProtocol1);
 840 |     |     }
 841 |     | 
 842 |     |     /// @inheritdoc IUniswapV3PoolOwnerActions
 843 |     |     function collectProtocol(
 844 |     |         address recipient,
 845 |     |         uint128 amount0Requested,
 846 |     |         uint128 amount1Requested
 847 |     |     ) external override lock onlyFactoryOwner returns (uint128 amount0, uint128 amount1) {
 848 |     |         amount0 = amount0Requested > protocolFees.token0 ? protocolFees.token0 : amount0Requested;
 849 |     |         amount1 = amount1Requested > protocolFees.token1 ? protocolFees.token1 : amount1Requested;
 850 |     | 
 851 |     |         if (amount0 > 0) {
 852 |     |             if (amount0 == protocolFees.token0) amount0--; // ensure that the slot is not cleared, for gas savings
 853 |     |             protocolFees.token0 -= amount0;
 854 |     |             TransferHelper.safeTransfer(token0, recipient, amount0);
 855 |     |         }
 856 |     |         if (amount1 > 0) {
 857 |     |             if (amount1 == protocolFees.token1) amount1--; // ensure that the slot is not cleared, for gas savings
 858 |     |             protocolFees.token1 -= amount1;
 859 |     |             TransferHelper.safeTransfer(token1, recipient, amount1);
 860 |     |         }
 861 |     | 
 862 |     |         emit CollectProtocol(msg.sender, recipient, amount0, amount1);
 863 |     |     }
 864 |     | }
 865 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/UniswapV3PoolDeployer.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity =0.7.6;
  3 |     | 
  4 |     | import './interfaces/IUniswapV3PoolDeployer.sol';
  5 |     | 
  6 |     | import './UniswapV3Pool.sol';
  7 |     | 
  8 |     | contract UniswapV3PoolDeployer is IUniswapV3PoolDeployer {
  9 |     |     struct Parameters {
 10 |     |         address factory;
 11 |     |         address token0;
 12 |     |         address token1;
 13 |     |         uint24 fee;
 14 |     |         int24 tickSpacing;
 15 |     |     }
 16 |     | 
 17 |     |     /// @inheritdoc IUniswapV3PoolDeployer
 18 | *   |     Parameters public override parameters;
 19 |     | 
 20 |     |     /// @dev Deploys a pool with the given parameters by transiently setting the parameters storage slot and then
 21 |     |     /// clearing it after deploying the pool.
 22 |     |     /// @param factory The contract address of the Uniswap V3 factory
 23 |     |     /// @param token0 The first token of the pool by address sort order
 24 |     |     /// @param token1 The second token of the pool by address sort order
 25 |     |     /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 26 |     |     /// @param tickSpacing The spacing between usable ticks
 27 | *   |     function deploy(
 28 |     |         address factory,
 29 |     |         address token0,
 30 |     |         address token1,
 31 |     |         uint24 fee,
 32 |     |         int24 tickSpacing
 33 |     |     ) internal returns (address pool) {
 34 | *   |         parameters = Parameters({factory: factory, token0: token0, token1: token1, fee: fee, tickSpacing: tickSpacing});
 35 | *   |         pool = address(new UniswapV3Pool{salt: keccak256(abi.encode(token0, token1, fee))}());
 36 | *   |         delete parameters;
 37 |     |     }
 38 |     | }
 39 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/IERC20Minimal.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Minimal ERC20 interface for Uniswap
  5 |     | /// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3
  6 |     | interface IERC20Minimal {
  7 |     |     /// @notice Returns the balance of a token
  8 |     |     /// @param account The account for which to look up the number of tokens it has, i.e. its balance
  9 |     |     /// @return The number of tokens held by the account
 10 |     |     function balanceOf(address account) external view returns (uint256);
 11 |     | 
 12 |     |     /// @notice Transfers the amount of token from the `msg.sender` to the recipient
 13 |     |     /// @param recipient The account that will receive the amount transferred
 14 |     |     /// @param amount The number of tokens to send from the sender to the recipient
 15 |     |     /// @return Returns true for a successful transfer, false for an unsuccessful transfer
 16 |     |     function transfer(address recipient, uint256 amount) external returns (bool);
 17 |     | 
 18 |     |     /// @notice Returns the current allowance given to a spender by an owner
 19 |     |     /// @param owner The account of the token owner
 20 |     |     /// @param spender The account of the token spender
 21 |     |     /// @return The current allowance granted by `owner` to `spender`
 22 |     |     function allowance(address owner, address spender) external view returns (uint256);
 23 |     | 
 24 |     |     /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`
 25 |     |     /// @param spender The account which will be allowed to spend a given amount of the owners tokens
 26 |     |     /// @param amount The amount of tokens allowed to be used by `spender`
 27 |     |     /// @return Returns true for a successful approval, false for unsuccessful
 28 |     |     function approve(address spender, uint256 amount) external returns (bool);
 29 |     | 
 30 |     |     /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`
 31 |     |     /// @param sender The account from which the transfer will be initiated
 32 |     |     /// @param recipient The recipient of the transfer
 33 |     |     /// @param amount The amount of the transfer
 34 |     |     /// @return Returns true for a successful transfer, false for unsuccessful
 35 |     |     function transferFrom(
 36 |     |         address sender,
 37 |     |         address recipient,
 38 |     |         uint256 amount
 39 |     |     ) external returns (bool);
 40 |     | 
 41 |     |     /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.
 42 |     |     /// @param from The account from which the tokens were sent, i.e. the balance decreased
 43 |     |     /// @param to The account to which the tokens were sent, i.e. the balance increased
 44 |     |     /// @param value The amount of tokens that were transferred
 45 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 46 |     | 
 47 |     |     /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.
 48 |     |     /// @param owner The account that approved spending of its tokens
 49 |     |     /// @param spender The account for which the spending allowance was modified
 50 |     |     /// @param value The new allowance from the owner to the spender
 51 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 52 |     | }
 53 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/IUniswapV3Factory.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title The interface for the Uniswap V3 Factory
  5 |     | /// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees
  6 |     | interface IUniswapV3Factory {
  7 |     |     /// @notice Emitted when the owner of the factory is changed
  8 |     |     /// @param oldOwner The owner before the owner was changed
  9 |     |     /// @param newOwner The owner after the owner was changed
 10 |     |     event OwnerChanged(address indexed oldOwner, address indexed newOwner);
 11 |     | 
 12 |     |     /// @notice Emitted when a pool is created
 13 |     |     /// @param token0 The first token of the pool by address sort order
 14 |     |     /// @param token1 The second token of the pool by address sort order
 15 |     |     /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 16 |     |     /// @param tickSpacing The minimum number of ticks between initialized ticks
 17 |     |     /// @param pool The address of the created pool
 18 |     |     event PoolCreated(
 19 |     |         address indexed token0,
 20 |     |         address indexed token1,
 21 |     |         uint24 indexed fee,
 22 |     |         int24 tickSpacing,
 23 |     |         address pool
 24 |     |     );
 25 |     | 
 26 |     |     /// @notice Emitted when a new fee amount is enabled for pool creation via the factory
 27 |     |     /// @param fee The enabled fee, denominated in hundredths of a bip
 28 |     |     /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee
 29 |     |     event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);
 30 |     | 
 31 |     |     /// @notice Returns the current owner of the factory
 32 |     |     /// @dev Can be changed by the current owner via setOwner
 33 |     |     /// @return The address of the factory owner
 34 |     |     function owner() external view returns (address);
 35 |     | 
 36 |     |     /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled
 37 |     |     /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context
 38 |     |     /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee
 39 |     |     /// @return The tick spacing
 40 |     |     function feeAmountTickSpacing(uint24 fee) external view returns (int24);
 41 |     | 
 42 |     |     /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist
 43 |     |     /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order
 44 |     |     /// @param tokenA The contract address of either token0 or token1
 45 |     |     /// @param tokenB The contract address of the other token
 46 |     |     /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 47 |     |     /// @return pool The pool address
 48 |     |     function getPool(
 49 |     |         address tokenA,
 50 |     |         address tokenB,
 51 |     |         uint24 fee
 52 |     |     ) external view returns (address pool);
 53 |     | 
 54 |     |     /// @notice Creates a pool for the given two tokens and fee
 55 |     |     /// @param tokenA One of the two tokens in the desired pool
 56 |     |     /// @param tokenB The other of the two tokens in the desired pool
 57 |     |     /// @param fee The desired fee for the pool
 58 |     |     /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved
 59 |     |     /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments
 60 |     |     /// are invalid.
 61 |     |     /// @return pool The address of the newly created pool
 62 |     |     function createPool(
 63 |     |         address tokenA,
 64 |     |         address tokenB,
 65 |     |         uint24 fee
 66 |     |     ) external returns (address pool);
 67 |     | 
 68 |     |     /// @notice Updates the owner of the factory
 69 |     |     /// @dev Must be called by the current owner
 70 |     |     /// @param _owner The new owner of the factory
 71 |     |     function setOwner(address _owner) external;
 72 |     | 
 73 |     |     /// @notice Enables a fee amount with the given tickSpacing
 74 |     |     /// @dev Fee amounts may never be removed once enabled
 75 |     |     /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)
 76 |     |     /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount
 77 |     |     function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
 78 |     | }
 79 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/IUniswapV3Pool.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | import './pool/IUniswapV3PoolImmutables.sol';
  5 |     | import './pool/IUniswapV3PoolState.sol';
  6 |     | import './pool/IUniswapV3PoolDerivedState.sol';
  7 |     | import './pool/IUniswapV3PoolActions.sol';
  8 |     | import './pool/IUniswapV3PoolOwnerActions.sol';
  9 |     | import './pool/IUniswapV3PoolEvents.sol';
 10 |     | 
 11 |     | /// @title The interface for a Uniswap V3 Pool
 12 |     | /// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform
 13 |     | /// to the ERC20 specification
 14 |     | /// @dev The pool interface is broken up into many smaller pieces
 15 |     | interface IUniswapV3Pool is
 16 |     |     IUniswapV3PoolImmutables,
 17 |     |     IUniswapV3PoolState,
 18 |     |     IUniswapV3PoolDerivedState,
 19 |     |     IUniswapV3PoolActions,
 20 |     |     IUniswapV3PoolOwnerActions,
 21 |     |     IUniswapV3PoolEvents
 22 |     | {
 23 |     | 
 24 |     | }
 25 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/IUniswapV3PoolDeployer.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title An interface for a contract that is capable of deploying Uniswap V3 Pools
  5 |     | /// @notice A contract that constructs a pool must implement this to pass arguments to the pool
  6 |     | /// @dev This is used to avoid having constructor arguments in the pool contract, which results in the init code hash
  7 |     | /// of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain
  8 |     | interface IUniswapV3PoolDeployer {
  9 |     |     /// @notice Get the parameters to be used in constructing the pool, set transiently during pool creation.
 10 |     |     /// @dev Called by the pool constructor to fetch the parameters of the pool
 11 |     |     /// Returns factory The factory address
 12 |     |     /// Returns token0 The first token of the pool by address sort order
 13 |     |     /// Returns token1 The second token of the pool by address sort order
 14 |     |     /// Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 15 |     |     /// Returns tickSpacing The minimum number of ticks between initialized ticks
 16 |     |     function parameters()
 17 |     |         external
 18 |     |         view
 19 |     |         returns (
 20 |     |             address factory,
 21 |     |             address token0,
 22 |     |             address token1,
 23 |     |             uint24 fee,
 24 |     |             int24 tickSpacing
 25 |     |         );
 26 |     | }
 27 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/callback/IUniswapV3FlashCallback.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Callback for IUniswapV3PoolActions#flash
  5 |     | /// @notice Any contract that calls IUniswapV3PoolActions#flash must implement this interface
  6 |     | interface IUniswapV3FlashCallback {
  7 |     |     /// @notice Called to `msg.sender` after transferring to the recipient from IUniswapV3Pool#flash.
  8 |     |     /// @dev In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts.
  9 |     |     /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.
 10 |     |     /// @param fee0 The fee amount in token0 due to the pool by the end of the flash
 11 |     |     /// @param fee1 The fee amount in token1 due to the pool by the end of the flash
 12 |     |     /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#flash call
 13 |     |     function uniswapV3FlashCallback(
 14 |     |         uint256 fee0,
 15 |     |         uint256 fee1,
 16 |     |         bytes calldata data
 17 |     |     ) external;
 18 |     | }
 19 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Callback for IUniswapV3PoolActions#mint
  5 |     | /// @notice Any contract that calls IUniswapV3PoolActions#mint must implement this interface
  6 |     | interface IUniswapV3MintCallback {
  7 |     |     /// @notice Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.
  8 |     |     /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.
  9 |     |     /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.
 10 |     |     /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity
 11 |     |     /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity
 12 |     |     /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call
 13 |     |     function uniswapV3MintCallback(
 14 |     |         uint256 amount0Owed,
 15 |     |         uint256 amount1Owed,
 16 |     |         bytes calldata data
 17 |     |     ) external;
 18 |     | }
 19 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Callback for IUniswapV3PoolActions#swap
  5 |     | /// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface
  6 |     | interface IUniswapV3SwapCallback {
  7 |     |     /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.
  8 |     |     /// @dev In the implementation you must pay the pool tokens owed for the swap.
  9 |     |     /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.
 10 |     |     /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.
 11 |     |     /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by
 12 |     |     /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.
 13 |     |     /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by
 14 |     |     /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.
 15 |     |     /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call
 16 |     |     function uniswapV3SwapCallback(
 17 |     |         int256 amount0Delta,
 18 |     |         int256 amount1Delta,
 19 |     |         bytes calldata data
 20 |     |     ) external;
 21 |     | }
 22 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | /// @title Permissionless pool actions
   5 |     | /// @notice Contains pool methods that can be called by anyone
   6 |     | interface IUniswapV3PoolActions {
   7 |     |     /// @notice Sets the initial price for the pool
   8 |     |     /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value
   9 |     |     /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96
  10 |     |     function initialize(uint160 sqrtPriceX96) external;
  11 |     | 
  12 |     |     /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position
  13 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
  14 |     |     /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
  15 |     |     /// on tickLower, tickUpper, the amount of liquidity, and the current price.
  16 |     |     /// @param recipient The address for which the liquidity will be created
  17 |     |     /// @param tickLower The lower tick of the position in which to add liquidity
  18 |     |     /// @param tickUpper The upper tick of the position in which to add liquidity
  19 |     |     /// @param amount The amount of liquidity to mint
  20 |     |     /// @param data Any data that should be passed through to the callback
  21 |     |     /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback
  22 |     |     /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback
  23 |     |     function mint(
  24 |     |         address recipient,
  25 |     |         int24 tickLower,
  26 |     |         int24 tickUpper,
  27 |     |         uint128 amount,
  28 |     |         bytes calldata data
  29 |     |     ) external returns (uint256 amount0, uint256 amount1);
  30 |     | 
  31 |     |     /// @notice Collects tokens owed to a position
  32 |     |     /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
  33 |     |     /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
  34 |     |     /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
  35 |     |     /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
  36 |     |     /// @param recipient The address which should receive the fees collected
  37 |     |     /// @param tickLower The lower tick of the position for which to collect fees
  38 |     |     /// @param tickUpper The upper tick of the position for which to collect fees
  39 |     |     /// @param amount0Requested How much token0 should be withdrawn from the fees owed
  40 |     |     /// @param amount1Requested How much token1 should be withdrawn from the fees owed
  41 |     |     /// @return amount0 The amount of fees collected in token0
  42 |     |     /// @return amount1 The amount of fees collected in token1
  43 |     |     function collect(
  44 |     |         address recipient,
  45 |     |         int24 tickLower,
  46 |     |         int24 tickUpper,
  47 |     |         uint128 amount0Requested,
  48 |     |         uint128 amount1Requested
  49 |     |     ) external returns (uint128 amount0, uint128 amount1);
  50 |     | 
  51 |     |     /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position
  52 |     |     /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
  53 |     |     /// @dev Fees must be collected separately via a call to #collect
  54 |     |     /// @param tickLower The lower tick of the position for which to burn liquidity
  55 |     |     /// @param tickUpper The upper tick of the position for which to burn liquidity
  56 |     |     /// @param amount How much liquidity to burn
  57 |     |     /// @return amount0 The amount of token0 sent to the recipient
  58 |     |     /// @return amount1 The amount of token1 sent to the recipient
  59 |     |     function burn(
  60 |     |         int24 tickLower,
  61 |     |         int24 tickUpper,
  62 |     |         uint128 amount
  63 |     |     ) external returns (uint256 amount0, uint256 amount1);
  64 |     | 
  65 |     |     /// @notice Swap token0 for token1, or token1 for token0
  66 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
  67 |     |     /// @param recipient The address to receive the output of the swap
  68 |     |     /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
  69 |     |     /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
  70 |     |     /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this
  71 |     |     /// value after the swap. If one for zero, the price cannot be greater than this value after the swap
  72 |     |     /// @param data Any data to be passed through to the callback
  73 |     |     /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive
  74 |     |     /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive
  75 |     |     function swap(
  76 |     |         address recipient,
  77 |     |         bool zeroForOne,
  78 |     |         int256 amountSpecified,
  79 |     |         uint160 sqrtPriceLimitX96,
  80 |     |         bytes calldata data
  81 |     |     ) external returns (int256 amount0, int256 amount1);
  82 |     | 
  83 |     |     /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback
  84 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback
  85 |     |     /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling
  86 |     |     /// with 0 amount{0,1} and sending the donation amount(s) from the callback
  87 |     |     /// @param recipient The address which will receive the token0 and token1 amounts
  88 |     |     /// @param amount0 The amount of token0 to send
  89 |     |     /// @param amount1 The amount of token1 to send
  90 |     |     /// @param data Any data to be passed through to the callback
  91 |     |     function flash(
  92 |     |         address recipient,
  93 |     |         uint256 amount0,
  94 |     |         uint256 amount1,
  95 |     |         bytes calldata data
  96 |     |     ) external;
  97 |     | 
  98 |     |     /// @notice Increase the maximum number of price and liquidity observations that this pool will store
  99 |     |     /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to
 100 |     |     /// the input observationCardinalityNext.
 101 |     |     /// @param observationCardinalityNext The desired minimum number of observations for the pool to store
 102 |     |     function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
 103 |     | }
 104 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Pool state that is not stored
  5 |     | /// @notice Contains view functions to provide information about the pool that is computed rather than stored on the
  6 |     | /// blockchain. The functions here may have variable gas costs.
  7 |     | interface IUniswapV3PoolDerivedState {
  8 |     |     /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp
  9 |     |     /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
 10 |     |     /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
 11 |     |     /// you must call it with secondsAgos = [3600, 0].
 12 |     |     /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
 13 |     |     /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
 14 |     |     /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned
 15 |     |     /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp
 16 |     |     /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block
 17 |     |     /// timestamp
 18 |     |     function observe(uint32[] calldata secondsAgos)
 19 |     |         external
 20 |     |         view
 21 |     |         returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
 22 |     | 
 23 |     |     /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range
 24 |     |     /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.
 25 |     |     /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first
 26 |     |     /// snapshot is taken and the second snapshot is taken.
 27 |     |     /// @param tickLower The lower tick of the range
 28 |     |     /// @param tickUpper The upper tick of the range
 29 |     |     /// @return tickCumulativeInside The snapshot of the tick accumulator for the range
 30 |     |     /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range
 31 |     |     /// @return secondsInside The snapshot of seconds per liquidity for the range
 32 |     |     function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)
 33 |     |         external
 34 |     |         view
 35 |     |         returns (
 36 |     |             int56 tickCumulativeInside,
 37 |     |             uint160 secondsPerLiquidityInsideX128,
 38 |     |             uint32 secondsInside
 39 |     |         );
 40 |     | }
 41 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | /// @title Events emitted by a pool
   5 |     | /// @notice Contains all events emitted by the pool
   6 |     | interface IUniswapV3PoolEvents {
   7 |     |     /// @notice Emitted exactly once by a pool when #initialize is first called on the pool
   8 |     |     /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize
   9 |     |     /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96
  10 |     |     /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool
  11 |     |     event Initialize(uint160 sqrtPriceX96, int24 tick);
  12 |     | 
  13 |     |     /// @notice Emitted when liquidity is minted for a given position
  14 |     |     /// @param sender The address that minted the liquidity
  15 |     |     /// @param owner The owner of the position and recipient of any minted liquidity
  16 |     |     /// @param tickLower The lower tick of the position
  17 |     |     /// @param tickUpper The upper tick of the position
  18 |     |     /// @param amount The amount of liquidity minted to the position range
  19 |     |     /// @param amount0 How much token0 was required for the minted liquidity
  20 |     |     /// @param amount1 How much token1 was required for the minted liquidity
  21 |     |     event Mint(
  22 |     |         address sender,
  23 |     |         address indexed owner,
  24 |     |         int24 indexed tickLower,
  25 |     |         int24 indexed tickUpper,
  26 |     |         uint128 amount,
  27 |     |         uint256 amount0,
  28 |     |         uint256 amount1
  29 |     |     );
  30 |     | 
  31 |     |     /// @notice Emitted when fees are collected by the owner of a position
  32 |     |     /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees
  33 |     |     /// @param owner The owner of the position for which fees are collected
  34 |     |     /// @param tickLower The lower tick of the position
  35 |     |     /// @param tickUpper The upper tick of the position
  36 |     |     /// @param amount0 The amount of token0 fees collected
  37 |     |     /// @param amount1 The amount of token1 fees collected
  38 |     |     event Collect(
  39 |     |         address indexed owner,
  40 |     |         address recipient,
  41 |     |         int24 indexed tickLower,
  42 |     |         int24 indexed tickUpper,
  43 |     |         uint128 amount0,
  44 |     |         uint128 amount1
  45 |     |     );
  46 |     | 
  47 |     |     /// @notice Emitted when a position's liquidity is removed
  48 |     |     /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect
  49 |     |     /// @param owner The owner of the position for which liquidity is removed
  50 |     |     /// @param tickLower The lower tick of the position
  51 |     |     /// @param tickUpper The upper tick of the position
  52 |     |     /// @param amount The amount of liquidity to remove
  53 |     |     /// @param amount0 The amount of token0 withdrawn
  54 |     |     /// @param amount1 The amount of token1 withdrawn
  55 |     |     event Burn(
  56 |     |         address indexed owner,
  57 |     |         int24 indexed tickLower,
  58 |     |         int24 indexed tickUpper,
  59 |     |         uint128 amount,
  60 |     |         uint256 amount0,
  61 |     |         uint256 amount1
  62 |     |     );
  63 |     | 
  64 |     |     /// @notice Emitted by the pool for any swaps between token0 and token1
  65 |     |     /// @param sender The address that initiated the swap call, and that received the callback
  66 |     |     /// @param recipient The address that received the output of the swap
  67 |     |     /// @param amount0 The delta of the token0 balance of the pool
  68 |     |     /// @param amount1 The delta of the token1 balance of the pool
  69 |     |     /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96
  70 |     |     /// @param liquidity The liquidity of the pool after the swap
  71 |     |     /// @param tick The log base 1.0001 of price of the pool after the swap
  72 |     |     event Swap(
  73 |     |         address indexed sender,
  74 |     |         address indexed recipient,
  75 |     |         int256 amount0,
  76 |     |         int256 amount1,
  77 |     |         uint160 sqrtPriceX96,
  78 |     |         uint128 liquidity,
  79 |     |         int24 tick
  80 |     |     );
  81 |     | 
  82 |     |     /// @notice Emitted by the pool for any flashes of token0/token1
  83 |     |     /// @param sender The address that initiated the swap call, and that received the callback
  84 |     |     /// @param recipient The address that received the tokens from flash
  85 |     |     /// @param amount0 The amount of token0 that was flashed
  86 |     |     /// @param amount1 The amount of token1 that was flashed
  87 |     |     /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee
  88 |     |     /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee
  89 |     |     event Flash(
  90 |     |         address indexed sender,
  91 |     |         address indexed recipient,
  92 |     |         uint256 amount0,
  93 |     |         uint256 amount1,
  94 |     |         uint256 paid0,
  95 |     |         uint256 paid1
  96 |     |     );
  97 |     | 
  98 |     |     /// @notice Emitted by the pool for increases to the number of observations that can be stored
  99 |     |     /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index
 100 |     |     /// just before a mint/swap/burn.
 101 |     |     /// @param observationCardinalityNextOld The previous value of the next observation cardinality
 102 |     |     /// @param observationCardinalityNextNew The updated value of the next observation cardinality
 103 |     |     event IncreaseObservationCardinalityNext(
 104 |     |         uint16 observationCardinalityNextOld,
 105 |     |         uint16 observationCardinalityNextNew
 106 |     |     );
 107 |     | 
 108 |     |     /// @notice Emitted when the protocol fee is changed by the pool
 109 |     |     /// @param feeProtocol0Old The previous value of the token0 protocol fee
 110 |     |     /// @param feeProtocol1Old The previous value of the token1 protocol fee
 111 |     |     /// @param feeProtocol0New The updated value of the token0 protocol fee
 112 |     |     /// @param feeProtocol1New The updated value of the token1 protocol fee
 113 |     |     event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);
 114 |     | 
 115 |     |     /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner
 116 |     |     /// @param sender The address that collects the protocol fees
 117 |     |     /// @param recipient The address that receives the collected protocol fees
 118 |     |     /// @param amount0 The amount of token0 protocol fees that is withdrawn
 119 |     |     /// @param amount0 The amount of token1 protocol fees that is withdrawn
 120 |     |     event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);
 121 |     | }
 122 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Pool state that never changes
  5 |     | /// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values
  6 |     | interface IUniswapV3PoolImmutables {
  7 |     |     /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface
  8 |     |     /// @return The contract address
  9 |     |     function factory() external view returns (address);
 10 |     | 
 11 |     |     /// @notice The first of the two tokens of the pool, sorted by address
 12 |     |     /// @return The token contract address
 13 |     |     function token0() external view returns (address);
 14 |     | 
 15 |     |     /// @notice The second of the two tokens of the pool, sorted by address
 16 |     |     /// @return The token contract address
 17 |     |     function token1() external view returns (address);
 18 |     | 
 19 |     |     /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6
 20 |     |     /// @return The fee
 21 |     |     function fee() external view returns (uint24);
 22 |     | 
 23 |     |     /// @notice The pool tick spacing
 24 |     |     /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
 25 |     |     /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
 26 |     |     /// This value is an int24 to avoid casting even though it is always positive.
 27 |     |     /// @return The tick spacing
 28 |     |     function tickSpacing() external view returns (int24);
 29 |     | 
 30 |     |     /// @notice The maximum amount of position liquidity that can use any tick in the range
 31 |     |     /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and
 32 |     |     /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool
 33 |     |     /// @return The max amount of liquidity per tick
 34 |     |     function maxLiquidityPerTick() external view returns (uint128);
 35 |     | }
 36 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Permissioned pool actions
  5 |     | /// @notice Contains pool methods that may only be called by the factory owner
  6 |     | interface IUniswapV3PoolOwnerActions {
  7 |     |     /// @notice Set the denominator of the protocol's % share of the fees
  8 |     |     /// @param feeProtocol0 new protocol fee for token0 of the pool
  9 |     |     /// @param feeProtocol1 new protocol fee for token1 of the pool
 10 |     |     function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;
 11 |     | 
 12 |     |     /// @notice Collect the protocol fee accrued to the pool
 13 |     |     /// @param recipient The address to which collected protocol fees should be sent
 14 |     |     /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1
 15 |     |     /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0
 16 |     |     /// @return amount0 The protocol fee collected in token0
 17 |     |     /// @return amount1 The protocol fee collected in token1
 18 |     |     function collectProtocol(
 19 |     |         address recipient,
 20 |     |         uint128 amount0Requested,
 21 |     |         uint128 amount1Requested
 22 |     |     ) external returns (uint128 amount0, uint128 amount1);
 23 |     | }
 24 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | /// @title Pool state that can change
   5 |     | /// @notice These methods compose the pool's state, and can change with any frequency including multiple times
   6 |     | /// per transaction
   7 |     | interface IUniswapV3PoolState {
   8 |     |     /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
   9 |     |     /// when accessed externally.
  10 |     |     /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
  11 |     |     /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
  12 |     |     /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
  13 |     |     /// boundary.
  14 |     |     /// observationIndex The index of the last oracle observation that was written,
  15 |     |     /// observationCardinality The current maximum number of observations stored in the pool,
  16 |     |     /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
  17 |     |     /// feeProtocol The protocol fee for both tokens of the pool.
  18 |     |     /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
  19 |     |     /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
  20 |     |     /// unlocked Whether the pool is currently locked to reentrancy
  21 |     |     function slot0()
  22 |     |         external
  23 |     |         view
  24 |     |         returns (
  25 |     |             uint160 sqrtPriceX96,
  26 |     |             int24 tick,
  27 |     |             uint16 observationIndex,
  28 |     |             uint16 observationCardinality,
  29 |     |             uint16 observationCardinalityNext,
  30 |     |             uint8 feeProtocol,
  31 |     |             bool unlocked
  32 |     |         );
  33 |     | 
  34 |     |     /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
  35 |     |     /// @dev This value can overflow the uint256
  36 |     |     function feeGrowthGlobal0X128() external view returns (uint256);
  37 |     | 
  38 |     |     /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
  39 |     |     /// @dev This value can overflow the uint256
  40 |     |     function feeGrowthGlobal1X128() external view returns (uint256);
  41 |     | 
  42 |     |     /// @notice The amounts of token0 and token1 that are owed to the protocol
  43 |     |     /// @dev Protocol fees will never exceed uint128 max in either token
  44 |     |     function protocolFees() external view returns (uint128 token0, uint128 token1);
  45 |     | 
  46 |     |     /// @notice The currently in range liquidity available to the pool
  47 |     |     /// @dev This value has no relationship to the total liquidity across all ticks
  48 |     |     function liquidity() external view returns (uint128);
  49 |     | 
  50 |     |     /// @notice Look up information about a specific tick in the pool
  51 |     |     /// @param tick The tick to look up
  52 |     |     /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or
  53 |     |     /// tick upper,
  54 |     |     /// liquidityNet how much liquidity changes when the pool price crosses the tick,
  55 |     |     /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,
  56 |     |     /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,
  57 |     |     /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick
  58 |     |     /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,
  59 |     |     /// secondsOutside the seconds spent on the other side of the tick from the current tick,
  60 |     |     /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.
  61 |     |     /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.
  62 |     |     /// In addition, these values are only relative and must be used only in comparison to previous snapshots for
  63 |     |     /// a specific position.
  64 |     |     function ticks(int24 tick)
  65 |     |         external
  66 |     |         view
  67 |     |         returns (
  68 |     |             uint128 liquidityGross,
  69 |     |             int128 liquidityNet,
  70 |     |             uint256 feeGrowthOutside0X128,
  71 |     |             uint256 feeGrowthOutside1X128,
  72 |     |             int56 tickCumulativeOutside,
  73 |     |             uint160 secondsPerLiquidityOutsideX128,
  74 |     |             uint32 secondsOutside,
  75 |     |             bool initialized
  76 |     |         );
  77 |     | 
  78 |     |     /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information
  79 |     |     function tickBitmap(int16 wordPosition) external view returns (uint256);
  80 |     | 
  81 |     |     /// @notice Returns the information about a position by the position's key
  82 |     |     /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
  83 |     |     /// @return _liquidity The amount of liquidity in the position,
  84 |     |     /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
  85 |     |     /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
  86 |     |     /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
  87 |     |     /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
  88 |     |     function positions(bytes32 key)
  89 |     |         external
  90 |     |         view
  91 |     |         returns (
  92 |     |             uint128 _liquidity,
  93 |     |             uint256 feeGrowthInside0LastX128,
  94 |     |             uint256 feeGrowthInside1LastX128,
  95 |     |             uint128 tokensOwed0,
  96 |     |             uint128 tokensOwed1
  97 |     |         );
  98 |     | 
  99 |     |     /// @notice Returns data about a specific observation index
 100 |     |     /// @param index The element of the observations array to fetch
 101 |     |     /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time
 102 |     |     /// ago, rather than at a specific index in the array.
 103 |     |     /// @return blockTimestamp The timestamp of the observation,
 104 |     |     /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,
 105 |     |     /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,
 106 |     |     /// Returns initialized whether the observation has been initialized and the values are safe to use
 107 |     |     function observations(uint256 index)
 108 |     |         external
 109 |     |         view
 110 |     |         returns (
 111 |     |             uint32 blockTimestamp,
 112 |     |             int56 tickCumulative,
 113 |     |             uint160 secondsPerLiquidityCumulativeX128,
 114 |     |             bool initialized
 115 |     |         );
 116 |     | }
 117 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/BitMath.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title BitMath
  5 |     | /// @dev This library provides functionality for computing bit properties of an unsigned integer
  6 |     | library BitMath {
  7 |     |     /// @notice Returns the index of the most significant bit of the number,
  8 |     |     ///     where the least significant bit is at index 0 and the most significant bit is at index 255
  9 |     |     /// @dev The function satisfies the property:
 10 |     |     ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)
 11 |     |     /// @param x the value for which to compute the most significant bit, must be greater than 0
 12 |     |     /// @return r the index of the most significant bit
 13 | *   |     function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {
 14 | *   |         require(x > 0);
 15 |     | 
 16 | *   |         if (x >= 0x100000000000000000000000000000000) {
 17 | *   |             x >>= 128;
 18 | *   |             r += 128;
 19 |     |         }
 20 | *   |         if (x >= 0x10000000000000000) {
 21 | *   |             x >>= 64;
 22 | *   |             r += 64;
 23 |     |         }
 24 | *   |         if (x >= 0x100000000) {
 25 | *   |             x >>= 32;
 26 | *   |             r += 32;
 27 |     |         }
 28 | *   |         if (x >= 0x10000) {
 29 | *   |             x >>= 16;
 30 | *   |             r += 16;
 31 |     |         }
 32 | *   |         if (x >= 0x100) {
 33 | *   |             x >>= 8;
 34 | *   |             r += 8;
 35 |     |         }
 36 | *   |         if (x >= 0x10) {
 37 | *   |             x >>= 4;
 38 | *   |             r += 4;
 39 |     |         }
 40 | *   |         if (x >= 0x4) {
 41 | *   |             x >>= 2;
 42 | *   |             r += 2;
 43 |     |         }
 44 | *   |         if (x >= 0x2) r += 1;
 45 |     |     }
 46 |     | 
 47 |     |     /// @notice Returns the index of the least significant bit of the number,
 48 |     |     ///     where the least significant bit is at index 0 and the most significant bit is at index 255
 49 |     |     /// @dev The function satisfies the property:
 50 |     |     ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)
 51 |     |     /// @param x the value for which to compute the least significant bit, must be greater than 0
 52 |     |     /// @return r the index of the least significant bit
 53 | *   |     function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {
 54 | *   |         require(x > 0);
 55 |     | 
 56 | *   |         r = 255;
 57 | *   |         if (x & type(uint128).max > 0) {
 58 | *   |             r -= 128;
 59 |     |         } else {
 60 |     |             x >>= 128;
 61 |     |         }
 62 |     |         if (x & type(uint64).max > 0) {
 63 |     |             r -= 64;
 64 |     |         } else {
 65 |     |             x >>= 64;
 66 |     |         }
 67 |     |         if (x & type(uint32).max > 0) {
 68 |     |             r -= 32;
 69 |     |         } else {
 70 |     |             x >>= 32;
 71 |     |         }
 72 |     |         if (x & type(uint16).max > 0) {
 73 |     |             r -= 16;
 74 |     |         } else {
 75 |     |             x >>= 16;
 76 |     |         }
 77 |     |         if (x & type(uint8).max > 0) {
 78 |     |             r -= 8;
 79 |     |         } else {
 80 |     |             x >>= 8;
 81 |     |         }
 82 |     |         if (x & 0xf > 0) {
 83 |     |             r -= 4;
 84 |     |         } else {
 85 |     |             x >>= 4;
 86 |     |         }
 87 |     |         if (x & 0x3 > 0) {
 88 |     |             r -= 2;
 89 |     |         } else {
 90 |     |             x >>= 2;
 91 |     |         }
 92 |     |         if (x & 0x1 > 0) r -= 1;
 93 |     |     }
 94 |     | }
 95 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/FixedPoint128.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.4.0;
  3 |     | 
  4 |     | /// @title FixedPoint128
  5 |     | /// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)
  6 |     | library FixedPoint128 {
  7 |     |     uint256 internal constant Q128 = 0x100000000000000000000000000000000;
  8 |     | }
  9 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/FixedPoint96.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.4.0;
  3 |     | 
  4 |     | /// @title FixedPoint96
  5 |     | /// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)
  6 |     | /// @dev Used in SqrtPriceMath.sol
  7 |     | library FixedPoint96 {
  8 | *   |     uint8 internal constant RESOLUTION = 96;
  9 |     |     uint256 internal constant Q96 = 0x1000000000000000000000000;
 10 |     | }
 11 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/FullMath.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.4.0 <0.8.0;
   3 |     | 
   4 |     | /// @title Contains 512-bit math functions
   5 |     | /// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision
   6 |     | /// @dev Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits
   7 |     | library FullMath {
   8 |     |     /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
   9 |     |     /// @param a The multiplicand
  10 |     |     /// @param b The multiplier
  11 |     |     /// @param denominator The divisor
  12 |     |     /// @return result The 256-bit result
  13 |     |     /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv
  14 | *   |     function mulDiv(
  15 |     |         uint256 a,
  16 |     |         uint256 b,
  17 |     |         uint256 denominator
  18 | *   |     ) internal pure returns (uint256 result) {
  19 |     |         // 512-bit multiply [prod1 prod0] = a * b
  20 |     |         // Compute the product mod 2**256 and mod 2**256 - 1
  21 |     |         // then use the Chinese Remainder Theorem to reconstruct
  22 |     |         // the 512 bit result. The result is stored in two 256
  23 |     |         // variables such that product = prod1 * 2**256 + prod0
  24 |     |         uint256 prod0; // Least significant 256 bits of the product
  25 |     |         uint256 prod1; // Most significant 256 bits of the product
  26 |     |         assembly {
  27 | *   |             let mm := mulmod(a, b, not(0))
  28 | *   |             prod0 := mul(a, b)
  29 | *   |             prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  30 |     |         }
  31 |     | 
  32 |     |         // Handle non-overflow cases, 256 by 256 division
  33 | *   |         if (prod1 == 0) {
  34 | *   |             require(denominator > 0);
  35 |     |             assembly {
  36 | *   |                 result := div(prod0, denominator)
  37 |     |             }
  38 | *   |             return result;
  39 |     |         }
  40 |     | 
  41 |     |         // Make sure the result is less than 2**256.
  42 |     |         // Also prevents denominator == 0
  43 | *   |         require(denominator > prod1);
  44 |     | 
  45 |     |         ///////////////////////////////////////////////
  46 |     |         // 512 by 256 division.
  47 |     |         ///////////////////////////////////////////////
  48 |     | 
  49 |     |         // Make division exact by subtracting the remainder from [prod1 prod0]
  50 |     |         // Compute remainder using mulmod
  51 | *   |         uint256 remainder;
  52 |     |         assembly {
  53 | *   |             remainder := mulmod(a, b, denominator)
  54 |     |         }
  55 |     |         // Subtract 256 bit number from 512 bit number
  56 |     |         assembly {
  57 | *   |             prod1 := sub(prod1, gt(remainder, prod0))
  58 | *   |             prod0 := sub(prod0, remainder)
  59 |     |         }
  60 |     | 
  61 |     |         // Factor powers of two out of denominator
  62 |     |         // Compute largest power of two divisor of denominator.
  63 |     |         // Always >= 1.
  64 | *   |         uint256 twos = -denominator & denominator;
  65 |     |         // Divide denominator by power of two
  66 |     |         assembly {
  67 | *   |             denominator := div(denominator, twos)
  68 |     |         }
  69 |     | 
  70 |     |         // Divide [prod1 prod0] by the factors of two
  71 |     |         assembly {
  72 | *   |             prod0 := div(prod0, twos)
  73 |     |         }
  74 |     |         // Shift in bits from prod1 into prod0. For this we need
  75 |     |         // to flip `twos` such that it is 2**256 / twos.
  76 |     |         // If twos is zero, then it becomes one
  77 |     |         assembly {
  78 | *   |             twos := add(div(sub(0, twos), twos), 1)
  79 |     |         }
  80 | *   |         prod0 |= prod1 * twos;
  81 |     | 
  82 |     |         // Invert denominator mod 2**256
  83 |     |         // Now that denominator is an odd number, it has an inverse
  84 |     |         // modulo 2**256 such that denominator * inv = 1 mod 2**256.
  85 |     |         // Compute the inverse by starting with a seed that is correct
  86 |     |         // correct for four bits. That is, denominator * inv = 1 mod 2**4
  87 | *   |         uint256 inv = (3 * denominator) ^ 2;
  88 |     |         // Now use Newton-Raphson iteration to improve the precision.
  89 |     |         // Thanks to Hensel's lifting lemma, this also works in modular
  90 |     |         // arithmetic, doubling the correct bits in each step.
  91 | *   |         inv *= 2 - denominator * inv; // inverse mod 2**8
  92 | *   |         inv *= 2 - denominator * inv; // inverse mod 2**16
  93 | *   |         inv *= 2 - denominator * inv; // inverse mod 2**32
  94 | *   |         inv *= 2 - denominator * inv; // inverse mod 2**64
  95 | *   |         inv *= 2 - denominator * inv; // inverse mod 2**128
  96 | *   |         inv *= 2 - denominator * inv; // inverse mod 2**256
  97 |     | 
  98 |     |         // Because the division is now exact we can divide by multiplying
  99 |     |         // with the modular inverse of denominator. This will give us the
 100 |     |         // correct result modulo 2**256. Since the precoditions guarantee
 101 |     |         // that the outcome is less than 2**256, this is the final result.
 102 |     |         // We don't need to compute the high bits of the result and prod1
 103 |     |         // is no longer required.
 104 | *   |         result = prod0 * inv;
 105 |     |         return result;
 106 |     |     }
 107 |     | 
 108 |     |     /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
 109 |     |     /// @param a The multiplicand
 110 |     |     /// @param b The multiplier
 111 |     |     /// @param denominator The divisor
 112 |     |     /// @return result The 256-bit result
 113 | *   |     function mulDivRoundingUp(
 114 |     |         uint256 a,
 115 |     |         uint256 b,
 116 |     |         uint256 denominator
 117 | *   |     ) internal pure returns (uint256 result) {
 118 | *   |         result = mulDiv(a, b, denominator);
 119 | *   |         if (mulmod(a, b, denominator) > 0) {
 120 | *   |             require(result < type(uint256).max);
 121 | *   |             result++;
 122 |     |         }
 123 |     |     }
 124 |     | }
 125 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/LiquidityMath.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Math library for liquidity
  5 |     | library LiquidityMath {
  6 |     |     /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows
  7 |     |     /// @param x The liquidity before change
  8 |     |     /// @param y The delta by which liquidity should be changed
  9 |     |     /// @return z The liquidity delta
 10 | *   |     function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {
 11 | *   |         if (y < 0) {
 12 | *   |             require((z = x - uint128(-y)) < x, 'LS');
 13 |     |         } else {
 14 | *   |             require((z = x + uint128(y)) >= x, 'LA');
 15 |     |         }
 16 |     |     }
 17 |     | }
 18 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/LowGasSafeMath.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.7.0;
  3 |     | 
  4 |     | /// @title Optimized overflow and underflow safe math operations
  5 |     | /// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost
  6 |     | library LowGasSafeMath {
  7 |     |     /// @notice Returns x + y, reverts if sum overflows uint256
  8 |     |     /// @param x The augend
  9 |     |     /// @param y The addend
 10 |     |     /// @return z The sum of x and y
 11 | *   |     function add(uint256 x, uint256 y) internal pure returns (uint256 z) {
 12 | *   |         require((z = x + y) >= x);
 13 |     |     }
 14 |     | 
 15 |     |     /// @notice Returns x - y, reverts if underflows
 16 |     |     /// @param x The minuend
 17 |     |     /// @param y The subtrahend
 18 |     |     /// @return z The difference of x and y
 19 |     |     function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
 20 |     |         require((z = x - y) <= x);
 21 |     |     }
 22 |     | 
 23 |     |     /// @notice Returns x * y, reverts if overflows
 24 |     |     /// @param x The multiplicand
 25 |     |     /// @param y The multiplier
 26 |     |     /// @return z The product of x and y
 27 |     |     function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
 28 |     |         require(x == 0 || (z = x * y) / x == y);
 29 |     |     }
 30 |     | 
 31 |     |     /// @notice Returns x + y, reverts if overflows or underflows
 32 |     |     /// @param x The augend
 33 |     |     /// @param y The addend
 34 |     |     /// @return z The sum of x and y
 35 | *   |     function add(int256 x, int256 y) internal pure returns (int256 z) {
 36 | *   |         require((z = x + y) >= x == (y >= 0));
 37 |     |     }
 38 |     | 
 39 |     |     /// @notice Returns x - y, reverts if overflows or underflows
 40 |     |     /// @param x The minuend
 41 |     |     /// @param y The subtrahend
 42 |     |     /// @return z The difference of x and y
 43 | *   |     function sub(int256 x, int256 y) internal pure returns (int256 z) {
 44 | *   |         require((z = x - y) <= x == (y >= 0));
 45 |     |     }
 46 |     | }
 47 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/Oracle.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity >=0.5.0 <0.8.0;
   3 |     | 
   4 |     | /// @title Oracle
   5 |     | /// @notice Provides price and liquidity data useful for a wide variety of system designs
   6 |     | /// @dev Instances of stored oracle data, "observations", are collected in the oracle array
   7 |     | /// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the
   8 |     | /// maximum length of the oracle array. New slots will be added when the array is fully populated.
   9 |     | /// Observations are overwritten when the full length of the oracle array is populated.
  10 |     | /// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()
  11 |     | library Oracle {
  12 |     |     struct Observation {
  13 |     |         // the block timestamp of the observation
  14 |     |         uint32 blockTimestamp;
  15 |     |         // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized
  16 |     |         int56 tickCumulative;
  17 |     |         // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized
  18 |     |         uint160 secondsPerLiquidityCumulativeX128;
  19 |     |         // whether or not the observation is initialized
  20 |     |         bool initialized;
  21 |     |     }
  22 |     | 
  23 |     |     /// @notice Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values
  24 |     |     /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows
  25 |     |     /// @param last The specified observation to be transformed
  26 |     |     /// @param blockTimestamp The timestamp of the new observation
  27 |     |     /// @param tick The active tick at the time of the new observation
  28 |     |     /// @param liquidity The total in-range liquidity at the time of the new observation
  29 |     |     /// @return Observation The newly populated observation
  30 | *   |     function transform(
  31 |     |         Observation memory last,
  32 |     |         uint32 blockTimestamp,
  33 |     |         int24 tick,
  34 |     |         uint128 liquidity
  35 | *   |     ) private pure returns (Observation memory) {
  36 | *   |         uint32 delta = blockTimestamp - last.blockTimestamp;
  37 | *   |         return
  38 | *   |             Observation({
  39 |     |                 blockTimestamp: blockTimestamp,
  40 | *   |                 tickCumulative: last.tickCumulative + int56(tick) * delta,
  41 | *   |                 secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +
  42 | *   |                     ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),
  43 | *   |                 initialized: true
  44 |     |             });
  45 |     |     }
  46 |     | 
  47 |     |     /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array
  48 |     |     /// @param self The stored oracle array
  49 |     |     /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32
  50 |     |     /// @return cardinality The number of populated elements in the oracle array
  51 |     |     /// @return cardinalityNext The new length of the oracle array, independent of population
  52 | *   |     function initialize(Observation[65535] storage self, uint32 time)
  53 |     |         internal
  54 |     |         returns (uint16 cardinality, uint16 cardinalityNext)
  55 |     |     {
  56 | *   |         self[0] = Observation({
  57 |     |             blockTimestamp: time,
  58 |     |             tickCumulative: 0,
  59 |     |             secondsPerLiquidityCumulativeX128: 0,
  60 | *   |             initialized: true
  61 |     |         });
  62 |     |         return (1, 1);
  63 |     |     }
  64 |     | 
  65 |     |     /// @notice Writes an oracle observation to the array
  66 |     |     /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.
  67 |     |     /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality
  68 |     |     /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.
  69 |     |     /// @param self The stored oracle array
  70 |     |     /// @param index The index of the observation that was most recently written to the observations array
  71 |     |     /// @param blockTimestamp The timestamp of the new observation
  72 |     |     /// @param tick The active tick at the time of the new observation
  73 |     |     /// @param liquidity The total in-range liquidity at the time of the new observation
  74 |     |     /// @param cardinality The number of populated elements in the oracle array
  75 |     |     /// @param cardinalityNext The new length of the oracle array, independent of population
  76 |     |     /// @return indexUpdated The new index of the most recently written element in the oracle array
  77 |     |     /// @return cardinalityUpdated The new cardinality of the oracle array
  78 | *   |     function write(
  79 |     |         Observation[65535] storage self,
  80 |     |         uint16 index,
  81 |     |         uint32 blockTimestamp,
  82 |     |         int24 tick,
  83 |     |         uint128 liquidity,
  84 |     |         uint16 cardinality,
  85 |     |         uint16 cardinalityNext
  86 | *   |     ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {
  87 | *   |         Observation memory last = self[index];
  88 |     | 
  89 |     |         // early return if we've already written an observation this block
  90 | *   |         if (last.blockTimestamp == blockTimestamp) return (index, cardinality);
  91 |     | 
  92 |     |         // if the conditions are right, we can bump the cardinality
  93 | *   |         if (cardinalityNext > cardinality && index == (cardinality - 1)) {
  94 | *   |             cardinalityUpdated = cardinalityNext;
  95 |     |         } else {
  96 | *   |             cardinalityUpdated = cardinality;
  97 |     |         }
  98 |     | 
  99 | *   |         indexUpdated = (index + 1) % cardinalityUpdated;
 100 | *   |         self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);
 101 |     |     }
 102 |     | 
 103 |     |     /// @notice Prepares the oracle array to store up to `next` observations
 104 |     |     /// @param self The stored oracle array
 105 |     |     /// @param current The current next cardinality of the oracle array
 106 |     |     /// @param next The proposed next cardinality which will be populated in the oracle array
 107 |     |     /// @return next The next cardinality which will be populated in the oracle array
 108 | *   |     function grow(
 109 |     |         Observation[65535] storage self,
 110 |     |         uint16 current,
 111 |     |         uint16 next
 112 | *   |     ) internal returns (uint16) {
 113 | *   |         require(current > 0, 'I');
 114 |     |         // no-op if the passed next value isn't greater than the current next value
 115 |     |         if (next <= current) return current;
 116 |     |         // store in each slot to prevent fresh SSTOREs in swaps
 117 |     |         // this data will not be used because the initialized boolean is still false
 118 |     |         for (uint16 i = current; i < next; i++) self[i].blockTimestamp = 1;
 119 |     |         return next;
 120 |     |     }
 121 |     | 
 122 |     |     /// @notice comparator for 32-bit timestamps
 123 |     |     /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time
 124 |     |     /// @param time A timestamp truncated to 32 bits
 125 |     |     /// @param a A comparison timestamp from which to determine the relative position of `time`
 126 |     |     /// @param b From which to determine the relative position of `time`
 127 |     |     /// @return bool Whether `a` is chronologically <= `b`
 128 |     |     function lte(
 129 |     |         uint32 time,
 130 |     |         uint32 a,
 131 |     |         uint32 b
 132 |     |     ) private pure returns (bool) {
 133 |     |         // if there hasn't been overflow, no need to adjust
 134 |     |         if (a <= time && b <= time) return a <= b;
 135 |     | 
 136 |     |         uint256 aAdjusted = a > time ? a : a + 2**32;
 137 |     |         uint256 bAdjusted = b > time ? b : b + 2**32;
 138 |     | 
 139 |     |         return aAdjusted <= bAdjusted;
 140 |     |     }
 141 |     | 
 142 |     |     /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.
 143 |     |     /// The result may be the same observation, or adjacent observations.
 144 |     |     /// @dev The answer must be contained in the array, used when the target is located within the stored observation
 145 |     |     /// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation
 146 |     |     /// @param self The stored oracle array
 147 |     |     /// @param time The current block.timestamp
 148 |     |     /// @param target The timestamp at which the reserved observation should be for
 149 |     |     /// @param index The index of the observation that was most recently written to the observations array
 150 |     |     /// @param cardinality The number of populated elements in the oracle array
 151 |     |     /// @return beforeOrAt The observation recorded before, or at, the target
 152 |     |     /// @return atOrAfter The observation recorded at, or after, the target
 153 |     |     function binarySearch(
 154 |     |         Observation[65535] storage self,
 155 |     |         uint32 time,
 156 |     |         uint32 target,
 157 |     |         uint16 index,
 158 |     |         uint16 cardinality
 159 |     |     ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {
 160 |     |         uint256 l = (index + 1) % cardinality; // oldest observation
 161 |     |         uint256 r = l + cardinality - 1; // newest observation
 162 |     |         uint256 i;
 163 |     |         while (true) {
 164 |     |             i = (l + r) / 2;
 165 |     | 
 166 |     |             beforeOrAt = self[i % cardinality];
 167 |     | 
 168 |     |             // we've landed on an uninitialized tick, keep searching higher (more recently)
 169 |     |             if (!beforeOrAt.initialized) {
 170 |     |                 l = i + 1;
 171 |     |                 continue;
 172 |     |             }
 173 |     | 
 174 |     |             atOrAfter = self[(i + 1) % cardinality];
 175 |     | 
 176 |     |             bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);
 177 |     | 
 178 |     |             // check if we've found the answer!
 179 |     |             if (targetAtOrAfter && lte(time, target, atOrAfter.blockTimestamp)) break;
 180 |     | 
 181 |     |             if (!targetAtOrAfter) r = i - 1;
 182 |     |             else l = i + 1;
 183 |     |         }
 184 |     |     }
 185 |     | 
 186 |     |     /// @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied
 187 |     |     /// @dev Assumes there is at least 1 initialized observation.
 188 |     |     /// Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.
 189 |     |     /// @param self The stored oracle array
 190 |     |     /// @param time The current block.timestamp
 191 |     |     /// @param target The timestamp at which the reserved observation should be for
 192 |     |     /// @param tick The active tick at the time of the returned or simulated observation
 193 |     |     /// @param index The index of the observation that was most recently written to the observations array
 194 |     |     /// @param liquidity The total pool liquidity at the time of the call
 195 |     |     /// @param cardinality The number of populated elements in the oracle array
 196 |     |     /// @return beforeOrAt The observation which occurred at, or before, the given timestamp
 197 |     |     /// @return atOrAfter The observation which occurred at, or after, the given timestamp
 198 | *   |     function getSurroundingObservations(
 199 |     |         Observation[65535] storage self,
 200 |     |         uint32 time,
 201 |     |         uint32 target,
 202 |     |         int24 tick,
 203 |     |         uint16 index,
 204 |     |         uint128 liquidity,
 205 |     |         uint16 cardinality
 206 | *   |     ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {
 207 |     |         // optimistically set before to the newest observation
 208 | *   |         beforeOrAt = self[index];
 209 |     | 
 210 |     |         // if the target is chronologically at or after the newest observation, we can early return
 211 |     |         if (lte(time, beforeOrAt.blockTimestamp, target)) {
 212 |     |             if (beforeOrAt.blockTimestamp == target) {
 213 |     |                 // if newest observation equals target, we're in the same block, so we can ignore atOrAfter
 214 |     |                 return (beforeOrAt, atOrAfter);
 215 |     |             } else {
 216 |     |                 // otherwise, we need to transform
 217 |     |                 return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));
 218 |     |             }
 219 |     |         }
 220 |     | 
 221 |     |         // now, set before to the oldest observation
 222 |     |         beforeOrAt = self[(index + 1) % cardinality];
 223 |     |         if (!beforeOrAt.initialized) beforeOrAt = self[0];
 224 |     | 
 225 |     |         // ensure that the target is chronologically at or after the oldest observation
 226 |     |         require(lte(time, beforeOrAt.blockTimestamp, target), 'OLD');
 227 |     | 
 228 |     |         // if we've reached this point, we have to binary search
 229 |     |         return binarySearch(self, time, target, index, cardinality);
 230 |     |     }
 231 |     | 
 232 |     |     /// @dev Reverts if an observation at or before the desired observation timestamp does not exist.
 233 |     |     /// 0 may be passed as `secondsAgo' to return the current cumulative values.
 234 |     |     /// If called with a timestamp falling between two observations, returns the counterfactual accumulator values
 235 |     |     /// at exactly the timestamp between the two observations.
 236 |     |     /// @param self The stored oracle array
 237 |     |     /// @param time The current block timestamp
 238 |     |     /// @param secondsAgo The amount of time to look back, in seconds, at which point to return an observation
 239 |     |     /// @param tick The current tick
 240 |     |     /// @param index The index of the observation that was most recently written to the observations array
 241 |     |     /// @param liquidity The current in-range pool liquidity
 242 |     |     /// @param cardinality The number of populated elements in the oracle array
 243 |     |     /// @return tickCumulative The tick * time elapsed since the pool was first initialized, as of `secondsAgo`
 244 |     |     /// @return secondsPerLiquidityCumulativeX128 The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`
 245 | *   |     function observeSingle(
 246 |     |         Observation[65535] storage self,
 247 |     |         uint32 time,
 248 |     |         uint32 secondsAgo,
 249 |     |         int24 tick,
 250 |     |         uint16 index,
 251 |     |         uint128 liquidity,
 252 |     |         uint16 cardinality
 253 | *   |     ) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) {
 254 | *   |         if (secondsAgo == 0) {
 255 | *   |             Observation memory last = self[index];
 256 | *   |             if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);
 257 | *   |             return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);
 258 |     |         }
 259 |     | 
 260 | *   |         uint32 target = time - secondsAgo;
 261 |     | 
 262 | *   |         (Observation memory beforeOrAt, Observation memory atOrAfter) =
 263 | *   |             getSurroundingObservations(self, time, target, tick, index, liquidity, cardinality);
 264 |     | 
 265 | *   |         if (target == beforeOrAt.blockTimestamp) {
 266 |     |             // we're at the left boundary
 267 |     |             return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);
 268 |     |         } else if (target == atOrAfter.blockTimestamp) {
 269 |     |             // we're at the right boundary
 270 |     |             return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);
 271 |     |         } else {
 272 |     |             // we're in the middle
 273 |     |             uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;
 274 |     |             uint32 targetDelta = target - beforeOrAt.blockTimestamp;
 275 |     |             return (
 276 |     |                 beforeOrAt.tickCumulative +
 277 |     |                     ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / observationTimeDelta) *
 278 |     |                     targetDelta,
 279 |     |                 beforeOrAt.secondsPerLiquidityCumulativeX128 +
 280 |     |                     uint160(
 281 |     |                         (uint256(
 282 |     |                             atOrAfter.secondsPerLiquidityCumulativeX128 - beforeOrAt.secondsPerLiquidityCumulativeX128
 283 |     |                         ) * targetDelta) / observationTimeDelta
 284 |     |                     )
 285 |     |             );
 286 |     |         }
 287 |     |     }
 288 |     | 
 289 |     |     /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`
 290 |     |     /// @dev Reverts if `secondsAgos` > oldest observation
 291 |     |     /// @param self The stored oracle array
 292 |     |     /// @param time The current block.timestamp
 293 |     |     /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation
 294 |     |     /// @param tick The current tick
 295 |     |     /// @param index The index of the observation that was most recently written to the observations array
 296 |     |     /// @param liquidity The current in-range pool liquidity
 297 |     |     /// @param cardinality The number of populated elements in the oracle array
 298 |     |     /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`
 299 |     |     /// @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`
 300 | *   |     function observe(
 301 |     |         Observation[65535] storage self,
 302 |     |         uint32 time,
 303 |     |         uint32[] memory secondsAgos,
 304 |     |         int24 tick,
 305 |     |         uint16 index,
 306 |     |         uint128 liquidity,
 307 |     |         uint16 cardinality
 308 | *   |     ) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {
 309 | *   |         require(cardinality > 0, 'I');
 310 |     | 
 311 |     |         tickCumulatives = new int56[](secondsAgos.length);
 312 |     |         secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);
 313 |     |         for (uint256 i = 0; i < secondsAgos.length; i++) {
 314 |     |             (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(
 315 |     |                 self,
 316 |     |                 time,
 317 |     |                 secondsAgos[i],
 318 |     |                 tick,
 319 |     |                 index,
 320 |     |                 liquidity,
 321 |     |                 cardinality
 322 |     |             );
 323 |     |         }
 324 |     |     }
 325 |     | }
 326 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/Position.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity >=0.5.0 <0.8.0;
  3 |     | 
  4 |     | import './FullMath.sol';
  5 |     | import './FixedPoint128.sol';
  6 |     | import './LiquidityMath.sol';
  7 |     | 
  8 |     | /// @title Position
  9 |     | /// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary
 10 |     | /// @dev Positions store additional state for tracking fees owed to the position
 11 |     | library Position {
 12 |     |     // info stored for each user's position
 13 |     |     struct Info {
 14 |     |         // the amount of liquidity owned by this position
 15 |     |         uint128 liquidity;
 16 |     |         // fee growth per unit of liquidity as of the last update to liquidity or fees owed
 17 |     |         uint256 feeGrowthInside0LastX128;
 18 |     |         uint256 feeGrowthInside1LastX128;
 19 |     |         // the fees owed to the position owner in token0/token1
 20 |     |         uint128 tokensOwed0;
 21 |     |         uint128 tokensOwed1;
 22 |     |     }
 23 |     | 
 24 |     |     /// @notice Returns the Info struct of a position, given an owner and position boundaries
 25 |     |     /// @param self The mapping containing all user positions
 26 |     |     /// @param owner The address of the position owner
 27 |     |     /// @param tickLower The lower tick boundary of the position
 28 |     |     /// @param tickUpper The upper tick boundary of the position
 29 |     |     /// @return position The position info struct of the given owners' position
 30 | *   |     function get(
 31 |     |         mapping(bytes32 => Info) storage self,
 32 |     |         address owner,
 33 |     |         int24 tickLower,
 34 |     |         int24 tickUpper
 35 |     |     ) internal view returns (Position.Info storage position) {
 36 | *   |         position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];
 37 |     |     }
 38 |     | 
 39 |     |     /// @notice Credits accumulated fees to a user's position
 40 |     |     /// @param self The individual position to update
 41 |     |     /// @param liquidityDelta The change in pool liquidity as a result of the position update
 42 |     |     /// @param feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries
 43 |     |     /// @param feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries
 44 | *   |     function update(
 45 |     |         Info storage self,
 46 |     |         int128 liquidityDelta,
 47 |     |         uint256 feeGrowthInside0X128,
 48 |     |         uint256 feeGrowthInside1X128
 49 |     |     ) internal {
 50 | *   |         Info memory _self = self;
 51 |     | 
 52 |     |         uint128 liquidityNext;
 53 | *   |         if (liquidityDelta == 0) {
 54 | *   |             require(_self.liquidity > 0, 'NP'); // disallow pokes for 0 liquidity positions
 55 |     |             liquidityNext = _self.liquidity;
 56 |     |         } else {
 57 |     |             liquidityNext = LiquidityMath.addDelta(_self.liquidity, liquidityDelta);
 58 |     |         }
 59 |     | 
 60 |     |         // calculate accumulated fees
 61 |     |         uint128 tokensOwed0 =
 62 |     |             uint128(
 63 |     |                 FullMath.mulDiv(
 64 |     |                     feeGrowthInside0X128 - _self.feeGrowthInside0LastX128,
 65 |     |                     _self.liquidity,
 66 |     |                     FixedPoint128.Q128
 67 |     |                 )
 68 |     |             );
 69 | *   |         uint128 tokensOwed1 =
 70 |     |             uint128(
 71 | *   |                 FullMath.mulDiv(
 72 | *   |                     feeGrowthInside1X128 - _self.feeGrowthInside1LastX128,
 73 |     |                     _self.liquidity,
 74 |     |                     FixedPoint128.Q128
 75 |     |                 )
 76 |     |             );
 77 |     | 
 78 |     |         // update the position
 79 | *   |         if (liquidityDelta != 0) self.liquidity = liquidityNext;
 80 | *   |         self.feeGrowthInside0LastX128 = feeGrowthInside0X128;
 81 | *   |         self.feeGrowthInside1LastX128 = feeGrowthInside1X128;
 82 | *   |         if (tokensOwed0 > 0 || tokensOwed1 > 0) {
 83 |     |             // overflow is acceptable, have to withdraw before you hit type(uint128).max fees
 84 | *   |             self.tokensOwed0 += tokensOwed0;
 85 | *   |             self.tokensOwed1 += tokensOwed1;
 86 |     |         }
 87 |     |     }
 88 |     | }
 89 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/SafeCast.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Safe casting methods
  5 |     | /// @notice Contains methods for safely casting between types
  6 |     | library SafeCast {
  7 |     |     /// @notice Cast a uint256 to a uint160, revert on overflow
  8 |     |     /// @param y The uint256 to be downcasted
  9 |     |     /// @return z The downcasted integer, now type uint160
 10 | *   |     function toUint160(uint256 y) internal pure returns (uint160 z) {
 11 | *   |         require((z = uint160(y)) == y);
 12 |     |     }
 13 |     | 
 14 |     |     /// @notice Cast a int256 to a int128, revert on overflow or underflow
 15 |     |     /// @param y The int256 to be downcasted
 16 |     |     /// @return z The downcasted integer, now type int128
 17 |     |     function toInt128(int256 y) internal pure returns (int128 z) {
 18 |     |         require((z = int128(y)) == y);
 19 |     |     }
 20 |     | 
 21 |     |     /// @notice Cast a uint256 to a int256, revert on overflow
 22 |     |     /// @param y The uint256 to be casted
 23 |     |     /// @return z The casted integer, now type int256
 24 | *   |     function toInt256(uint256 y) internal pure returns (int256 z) {
 25 | *   |         require(y < 2**255);
 26 | *   |         z = int256(y);
 27 |     |     }
 28 |     | }
 29 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/SqrtPriceMath.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | import './LowGasSafeMath.sol';
   5 |     | import './SafeCast.sol';
   6 |     | 
   7 |     | import './FullMath.sol';
   8 |     | import './UnsafeMath.sol';
   9 |     | import './FixedPoint96.sol';
  10 |     | 
  11 |     | /// @title Functions based on Q64.96 sqrt price and liquidity
  12 |     | /// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas
  13 |     | library SqrtPriceMath {
  14 |     |     using LowGasSafeMath for uint256;
  15 |     |     using SafeCast for uint256;
  16 |     | 
  17 |     |     /// @notice Gets the next sqrt price given a delta of token0
  18 |     |     /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least
  19 |     |     /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the
  20 |     |     /// price less in order to not send too much output.
  21 |     |     /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),
  22 |     |     /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).
  23 |     |     /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta
  24 |     |     /// @param liquidity The amount of usable liquidity
  25 |     |     /// @param amount How much of token0 to add or remove from virtual reserves
  26 |     |     /// @param add Whether to add or remove the amount of token0
  27 |     |     /// @return The price after adding or removing amount, depending on add
  28 | *   |     function getNextSqrtPriceFromAmount0RoundingUp(
  29 |     |         uint160 sqrtPX96,
  30 |     |         uint128 liquidity,
  31 |     |         uint256 amount,
  32 |     |         bool add
  33 | *   |     ) internal pure returns (uint160) {
  34 |     |         // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price
  35 | *   |         if (amount == 0) return sqrtPX96;
  36 | *   |         uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;
  37 |     | 
  38 | *   |         if (add) {
  39 |     |             uint256 product;
  40 | *   |             if ((product = amount * sqrtPX96) / amount == sqrtPX96) {
  41 | *   |                 uint256 denominator = numerator1 + product;
  42 | *   |                 if (denominator >= numerator1)
  43 |     |                     // always fits in 160 bits
  44 | *   |                     return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));
  45 |     |             }
  46 |     | 
  47 | *   |             return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96).add(amount)));
  48 |     |         } else {
  49 |     |             uint256 product;
  50 |     |             // if the product overflows, we know the denominator underflows
  51 |     |             // in addition, we must check that the denominator does not underflow
  52 | *   |             require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);
  53 |     |             uint256 denominator = numerator1 - product;
  54 |     |             return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();
  55 |     |         }
  56 |     |     }
  57 |     | 
  58 |     |     /// @notice Gets the next sqrt price given a delta of token1
  59 |     |     /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least
  60 |     |     /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the
  61 |     |     /// price less in order to not send too much output.
  62 |     |     /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity
  63 |     |     /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta
  64 |     |     /// @param liquidity The amount of usable liquidity
  65 |     |     /// @param amount How much of token1 to add, or remove, from virtual reserves
  66 |     |     /// @param add Whether to add, or remove, the amount of token1
  67 |     |     /// @return The price after adding or removing `amount`
  68 |     |     function getNextSqrtPriceFromAmount1RoundingDown(
  69 |     |         uint160 sqrtPX96,
  70 |     |         uint128 liquidity,
  71 |     |         uint256 amount,
  72 |     |         bool add
  73 |     |     ) internal pure returns (uint160) {
  74 |     |         // if we're adding (subtracting), rounding down requires rounding the quotient down (up)
  75 |     |         // in both cases, avoid a mulDiv for most inputs
  76 | *   |         if (add) {
  77 | *   |             uint256 quotient =
  78 |     |                 (
  79 | *   |                     amount <= type(uint160).max
  80 | *   |                         ? (amount << FixedPoint96.RESOLUTION) / liquidity
  81 | *   |                         : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)
  82 |     |                 );
  83 |     | 
  84 |     |             return uint256(sqrtPX96).add(quotient).toUint160();
  85 |     |         } else {
  86 | *   |             uint256 quotient =
  87 |     |                 (
  88 |     |                     amount <= type(uint160).max
  89 | *   |                         ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)
  90 |     |                         : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)
  91 |     |                 );
  92 |     | 
  93 | *   |             require(sqrtPX96 > quotient);
  94 |     |             // always fits 160 bits
  95 | *   |             return uint160(sqrtPX96 - quotient);
  96 |     |         }
  97 |     |     }
  98 |     | 
  99 |     |     /// @notice Gets the next sqrt price given an input amount of token0 or token1
 100 |     |     /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds
 101 |     |     /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount
 102 |     |     /// @param liquidity The amount of usable liquidity
 103 |     |     /// @param amountIn How much of token0, or token1, is being swapped in
 104 |     |     /// @param zeroForOne Whether the amount in is token0 or token1
 105 |     |     /// @return sqrtQX96 The price after adding the input amount to token0 or token1
 106 | *   |     function getNextSqrtPriceFromInput(
 107 |     |         uint160 sqrtPX96,
 108 |     |         uint128 liquidity,
 109 |     |         uint256 amountIn,
 110 |     |         bool zeroForOne
 111 | *   |     ) internal pure returns (uint160 sqrtQX96) {
 112 | *   |         require(sqrtPX96 > 0);
 113 | *   |         require(liquidity > 0);
 114 |     | 
 115 |     |         // round to make sure that we don't pass the target price
 116 |     |         return
 117 | *   |             zeroForOne
 118 | *   |                 ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)
 119 | *   |                 : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);
 120 |     |     }
 121 |     | 
 122 |     |     /// @notice Gets the next sqrt price given an output amount of token0 or token1
 123 |     |     /// @dev Throws if price or liquidity are 0 or the next price is out of bounds
 124 |     |     /// @param sqrtPX96 The starting price before accounting for the output amount
 125 |     |     /// @param liquidity The amount of usable liquidity
 126 |     |     /// @param amountOut How much of token0, or token1, is being swapped out
 127 |     |     /// @param zeroForOne Whether the amount out is token0 or token1
 128 |     |     /// @return sqrtQX96 The price after removing the output amount of token0 or token1
 129 | *   |     function getNextSqrtPriceFromOutput(
 130 |     |         uint160 sqrtPX96,
 131 |     |         uint128 liquidity,
 132 |     |         uint256 amountOut,
 133 |     |         bool zeroForOne
 134 | *   |     ) internal pure returns (uint160 sqrtQX96) {
 135 | *   |         require(sqrtPX96 > 0);
 136 | *   |         require(liquidity > 0);
 137 |     | 
 138 |     |         // round to make sure that we pass the target price
 139 |     |         return
 140 | *   |             zeroForOne
 141 | *   |                 ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)
 142 | *   |                 : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);
 143 |     |     }
 144 |     | 
 145 |     |     /// @notice Gets the amount0 delta between two prices
 146 |     |     /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),
 147 |     |     /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))
 148 |     |     /// @param sqrtRatioAX96 A sqrt price
 149 |     |     /// @param sqrtRatioBX96 Another sqrt price
 150 |     |     /// @param liquidity The amount of usable liquidity
 151 |     |     /// @param roundUp Whether to round the amount up or down
 152 |     |     /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices
 153 | *   |     function getAmount0Delta(
 154 |     |         uint160 sqrtRatioAX96,
 155 |     |         uint160 sqrtRatioBX96,
 156 |     |         uint128 liquidity,
 157 |     |         bool roundUp
 158 | *   |     ) internal pure returns (uint256 amount0) {
 159 | *   |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
 160 |     | 
 161 | *   |         uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;
 162 | *   |         uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;
 163 |     | 
 164 | *   |         require(sqrtRatioAX96 > 0);
 165 |     | 
 166 |     |         return
 167 | *   |             roundUp
 168 |     |                 ? UnsafeMath.divRoundingUp(
 169 | *   |                     FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96),
 170 |     |                     sqrtRatioAX96
 171 |     |                 )
 172 | *   |                 : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;
 173 |     |     }
 174 |     | 
 175 |     |     /// @notice Gets the amount1 delta between two prices
 176 |     |     /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))
 177 |     |     /// @param sqrtRatioAX96 A sqrt price
 178 |     |     /// @param sqrtRatioBX96 Another sqrt price
 179 |     |     /// @param liquidity The amount of usable liquidity
 180 |     |     /// @param roundUp Whether to round the amount up, or down
 181 |     |     /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices
 182 | *   |     function getAmount1Delta(
 183 |     |         uint160 sqrtRatioAX96,
 184 |     |         uint160 sqrtRatioBX96,
 185 |     |         uint128 liquidity,
 186 |     |         bool roundUp
 187 |     |     ) internal pure returns (uint256 amount1) {
 188 |     |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
 189 |     | 
 190 | *   |         return
 191 | *   |             roundUp
 192 | *   |                 ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)
 193 | *   |                 : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
 194 |     |     }
 195 |     | 
 196 |     |     /// @notice Helper that gets signed token0 delta
 197 |     |     /// @param sqrtRatioAX96 A sqrt price
 198 |     |     /// @param sqrtRatioBX96 Another sqrt price
 199 |     |     /// @param liquidity The change in liquidity for which to compute the amount0 delta
 200 |     |     /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices
 201 | *   |     function getAmount0Delta(
 202 |     |         uint160 sqrtRatioAX96,
 203 |     |         uint160 sqrtRatioBX96,
 204 |     |         int128 liquidity
 205 | *   |     ) internal pure returns (int256 amount0) {
 206 | *   |         return
 207 | *   |             liquidity < 0
 208 | *   |                 ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()
 209 |     |                 : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();
 210 |     |     }
 211 |     | 
 212 |     |     /// @notice Helper that gets signed token1 delta
 213 |     |     /// @param sqrtRatioAX96 A sqrt price
 214 |     |     /// @param sqrtRatioBX96 Another sqrt price
 215 |     |     /// @param liquidity The change in liquidity for which to compute the amount1 delta
 216 |     |     /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices
 217 | *   |     function getAmount1Delta(
 218 |     |         uint160 sqrtRatioAX96,
 219 |     |         uint160 sqrtRatioBX96,
 220 |     |         int128 liquidity
 221 | *   |     ) internal pure returns (int256 amount1) {
 222 |     |         return
 223 | *   |             liquidity < 0
 224 | *   |                 ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()
 225 | *   |                 : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();
 226 |     |     }
 227 |     | }
 228 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/SwapMath.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | import './FullMath.sol';
   5 |     | import './SqrtPriceMath.sol';
   6 |     | 
   7 |     | /// @title Computes the result of a swap within ticks
   8 |     | /// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.
   9 |     | library SwapMath {
  10 |     |     /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap
  11 |     |     /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive
  12 |     |     /// @param sqrtRatioCurrentX96 The current sqrt price of the pool
  13 |     |     /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred
  14 |     |     /// @param liquidity The usable liquidity
  15 |     |     /// @param amountRemaining How much input or output amount is remaining to be swapped in/out
  16 |     |     /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip
  17 |     |     /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target
  18 |     |     /// @return amountIn The amount to be swapped in, of either token0 or token1, based on the direction of the swap
  19 |     |     /// @return amountOut The amount to be received, of either token0 or token1, based on the direction of the swap
  20 |     |     /// @return feeAmount The amount of input that will be taken as a fee
  21 | *   |     function computeSwapStep(
  22 |     |         uint160 sqrtRatioCurrentX96,
  23 |     |         uint160 sqrtRatioTargetX96,
  24 |     |         uint128 liquidity,
  25 |     |         int256 amountRemaining,
  26 |     |         uint24 feePips
  27 |     |     )
  28 |     |         internal
  29 |     |         pure
  30 |     |         returns (
  31 | *   |             uint160 sqrtRatioNextX96,
  32 |     |             uint256 amountIn,
  33 |     |             uint256 amountOut,
  34 |     |             uint256 feeAmount
  35 |     |         )
  36 |     |     {
  37 | *   |         bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;
  38 | *   |         bool exactIn = amountRemaining >= 0;
  39 |     | 
  40 | *   |         if (exactIn) {
  41 | *   |             uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);
  42 | *   |             amountIn = zeroForOne
  43 | *   |                 ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)
  44 | *   |                 : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);
  45 | *   |             if (amountRemainingLessFee >= amountIn) sqrtRatioNextX96 = sqrtRatioTargetX96;
  46 |     |             else
  47 | *   |                 sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(
  48 |     |                     sqrtRatioCurrentX96,
  49 | *   |                     liquidity,
  50 | *   |                     amountRemainingLessFee,
  51 | *   |                     zeroForOne
  52 |     |                 );
  53 |     |         } else {
  54 | *   |             amountOut = zeroForOne
  55 | *   |                 ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)
  56 | *   |                 : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);
  57 | *   |             if (uint256(-amountRemaining) >= amountOut) sqrtRatioNextX96 = sqrtRatioTargetX96;
  58 |     |             else
  59 | *   |                 sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(
  60 | *   |                     sqrtRatioCurrentX96,
  61 | *   |                     liquidity,
  62 | *   |                     uint256(-amountRemaining),
  63 | *   |                     zeroForOne
  64 |     |                 );
  65 |     |         }
  66 |     | 
  67 | *   |         bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;
  68 |     | 
  69 |     |         // get the input/output amounts
  70 | *   |         if (zeroForOne) {
  71 | *   |             amountIn = max && exactIn
  72 | *   |                 ? amountIn
  73 | *   |                 : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);
  74 | *   |             amountOut = max && !exactIn
  75 | *   |                 ? amountOut
  76 | *   |                 : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);
  77 |     |         } else {
  78 | *   |             amountIn = max && exactIn
  79 | *   |                 ? amountIn
  80 | *   |                 : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);
  81 |     |             amountOut = max && !exactIn
  82 |     |                 ? amountOut
  83 |     |                 : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);
  84 |     |         }
  85 |     | 
  86 |     |         // cap the output amount to not exceed the remaining output amount
  87 |     |         if (!exactIn && amountOut > uint256(-amountRemaining)) {
  88 |     |             amountOut = uint256(-amountRemaining);
  89 |     |         }
  90 |     | 
  91 | *   |         if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {
  92 |     |             // we didn't reach the target, so take the remainder of the maximum input as fee
  93 | *   |             feeAmount = uint256(amountRemaining) - amountIn;
  94 |     |         } else {
  95 | *   |             feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);
  96 |     |         }
  97 |     |     }
  98 |     | }
  99 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/Tick.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity >=0.5.0 <0.8.0;
   3 |     | 
   4 |     | import './LowGasSafeMath.sol';
   5 |     | import './SafeCast.sol';
   6 |     | 
   7 |     | import './TickMath.sol';
   8 |     | import './LiquidityMath.sol';
   9 |     | 
  10 |     | /// @title Tick
  11 |     | /// @notice Contains functions for managing tick processes and relevant calculations
  12 |     | library Tick {
  13 |     |     using LowGasSafeMath for int256;
  14 |     |     using SafeCast for int256;
  15 |     | 
  16 |     |     // info stored for each initialized individual tick
  17 |     |     struct Info {
  18 |     |         // the total position liquidity that references this tick
  19 |     |         uint128 liquidityGross;
  20 |     |         // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),
  21 |     |         int128 liquidityNet;
  22 |     |         // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)
  23 |     |         // only has relative meaning, not absolute — the value depends on when the tick is initialized
  24 |     |         uint256 feeGrowthOutside0X128;
  25 |     |         uint256 feeGrowthOutside1X128;
  26 |     |         // the cumulative tick value on the other side of the tick
  27 |     |         int56 tickCumulativeOutside;
  28 |     |         // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)
  29 |     |         // only has relative meaning, not absolute — the value depends on when the tick is initialized
  30 |     |         uint160 secondsPerLiquidityOutsideX128;
  31 |     |         // the seconds spent on the other side of the tick (relative to the current tick)
  32 |     |         // only has relative meaning, not absolute — the value depends on when the tick is initialized
  33 |     |         uint32 secondsOutside;
  34 |     |         // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0
  35 |     |         // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks
  36 |     |         bool initialized;
  37 |     |     }
  38 |     | 
  39 |     |     /// @notice Derives max liquidity per tick from given tick spacing
  40 |     |     /// @dev Executed within the pool constructor
  41 |     |     /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`
  42 |     |     ///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...
  43 |     |     /// @return The max liquidity per tick
  44 | *   |     function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) {
  45 | *   |         int24 minTick = (TickMath.MIN_TICK / tickSpacing) * tickSpacing;
  46 | *   |         int24 maxTick = (TickMath.MAX_TICK / tickSpacing) * tickSpacing;
  47 |     |         uint24 numTicks = uint24((maxTick - minTick) / tickSpacing) + 1;
  48 |     |         return type(uint128).max / numTicks;
  49 |     |     }
  50 |     | 
  51 |     |     /// @notice Retrieves fee growth data
  52 |     |     /// @param self The mapping containing all tick information for initialized ticks
  53 |     |     /// @param tickLower The lower tick boundary of the position
  54 |     |     /// @param tickUpper The upper tick boundary of the position
  55 |     |     /// @param tickCurrent The current tick
  56 |     |     /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0
  57 |     |     /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1
  58 |     |     /// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries
  59 |     |     /// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries
  60 | *   |     function getFeeGrowthInside(
  61 |     |         mapping(int24 => Tick.Info) storage self,
  62 |     |         int24 tickLower,
  63 |     |         int24 tickUpper,
  64 |     |         int24 tickCurrent,
  65 |     |         uint256 feeGrowthGlobal0X128,
  66 |     |         uint256 feeGrowthGlobal1X128
  67 | *   |     ) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {
  68 | *   |         Info storage lower = self[tickLower];
  69 | *   |         Info storage upper = self[tickUpper];
  70 |     | 
  71 |     |         // calculate fee growth below
  72 |     |         uint256 feeGrowthBelow0X128;
  73 |     |         uint256 feeGrowthBelow1X128;
  74 | *   |         if (tickCurrent >= tickLower) {
  75 | *   |             feeGrowthBelow0X128 = lower.feeGrowthOutside0X128;
  76 | *   |             feeGrowthBelow1X128 = lower.feeGrowthOutside1X128;
  77 |     |         } else {
  78 | *   |             feeGrowthBelow0X128 = feeGrowthGlobal0X128 - lower.feeGrowthOutside0X128;
  79 | *   |             feeGrowthBelow1X128 = feeGrowthGlobal1X128 - lower.feeGrowthOutside1X128;
  80 |     |         }
  81 |     | 
  82 |     |         // calculate fee growth above
  83 | *   |         uint256 feeGrowthAbove0X128;
  84 | *   |         uint256 feeGrowthAbove1X128;
  85 | *   |         if (tickCurrent < tickUpper) {
  86 | *   |             feeGrowthAbove0X128 = upper.feeGrowthOutside0X128;
  87 | *   |             feeGrowthAbove1X128 = upper.feeGrowthOutside1X128;
  88 |     |         } else {
  89 | *   |             feeGrowthAbove0X128 = feeGrowthGlobal0X128 - upper.feeGrowthOutside0X128;
  90 | *   |             feeGrowthAbove1X128 = feeGrowthGlobal1X128 - upper.feeGrowthOutside1X128;
  91 |     |         }
  92 |     | 
  93 | *   |         feeGrowthInside0X128 = feeGrowthGlobal0X128 - feeGrowthBelow0X128 - feeGrowthAbove0X128;
  94 | *   |         feeGrowthInside1X128 = feeGrowthGlobal1X128 - feeGrowthBelow1X128 - feeGrowthAbove1X128;
  95 |     |     }
  96 |     | 
  97 |     |     /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa
  98 |     |     /// @param self The mapping containing all tick information for initialized ticks
  99 |     |     /// @param tick The tick that will be updated
 100 |     |     /// @param tickCurrent The current tick
 101 |     |     /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)
 102 |     |     /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0
 103 |     |     /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1
 104 |     |     /// @param secondsPerLiquidityCumulativeX128 The all-time seconds per max(1, liquidity) of the pool
 105 |     |     /// @param tickCumulative The tick * time elapsed since the pool was first initialized
 106 |     |     /// @param time The current block timestamp cast to a uint32
 107 |     |     /// @param upper true for updating a position's upper tick, or false for updating a position's lower tick
 108 |     |     /// @param maxLiquidity The maximum liquidity allocation for a single tick
 109 |     |     /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa
 110 | *   |     function update(
 111 |     |         mapping(int24 => Tick.Info) storage self,
 112 |     |         int24 tick,
 113 |     |         int24 tickCurrent,
 114 |     |         int128 liquidityDelta,
 115 |     |         uint256 feeGrowthGlobal0X128,
 116 |     |         uint256 feeGrowthGlobal1X128,
 117 |     |         uint160 secondsPerLiquidityCumulativeX128,
 118 |     |         int56 tickCumulative,
 119 |     |         uint32 time,
 120 |     |         bool upper,
 121 |     |         uint128 maxLiquidity
 122 |     |     ) internal returns (bool flipped) {
 123 |     |         Tick.Info storage info = self[tick];
 124 |     | 
 125 |     |         uint128 liquidityGrossBefore = info.liquidityGross;
 126 |     |         uint128 liquidityGrossAfter = LiquidityMath.addDelta(liquidityGrossBefore, liquidityDelta);
 127 |     | 
 128 | *   |         require(liquidityGrossAfter <= maxLiquidity, 'LO');
 129 |     | 
 130 | *   |         flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);
 131 |     | 
 132 | *   |         if (liquidityGrossBefore == 0) {
 133 |     |             // by convention, we assume that all growth before a tick was initialized happened _below_ the tick
 134 | *   |             if (tick <= tickCurrent) {
 135 |     |                 info.feeGrowthOutside0X128 = feeGrowthGlobal0X128;
 136 |     |                 info.feeGrowthOutside1X128 = feeGrowthGlobal1X128;
 137 | *   |                 info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128;
 138 | *   |                 info.tickCumulativeOutside = tickCumulative;
 139 | *   |                 info.secondsOutside = time;
 140 |     |             }
 141 | *   |             info.initialized = true;
 142 |     |         }
 143 |     | 
 144 | *   |         info.liquidityGross = liquidityGrossAfter;
 145 |     | 
 146 |     |         // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)
 147 | *   |         info.liquidityNet = upper
 148 | *   |             ? int256(info.liquidityNet).sub(liquidityDelta).toInt128()
 149 | *   |             : int256(info.liquidityNet).add(liquidityDelta).toInt128();
 150 |     |     }
 151 |     | 
 152 |     |     /// @notice Clears tick data
 153 |     |     /// @param self The mapping containing all initialized tick information for initialized ticks
 154 |     |     /// @param tick The tick that will be cleared
 155 | *   |     function clear(mapping(int24 => Tick.Info) storage self, int24 tick) internal {
 156 | *   |         delete self[tick];
 157 |     |     }
 158 |     | 
 159 |     |     /// @notice Transitions to next tick as needed by price movement
 160 |     |     /// @param self The mapping containing all tick information for initialized ticks
 161 |     |     /// @param tick The destination tick of the transition
 162 |     |     /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0
 163 |     |     /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1
 164 |     |     /// @param secondsPerLiquidityCumulativeX128 The current seconds per liquidity
 165 |     |     /// @param tickCumulative The tick * time elapsed since the pool was first initialized
 166 |     |     /// @param time The current block.timestamp
 167 |     |     /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)
 168 | *   |     function cross(
 169 |     |         mapping(int24 => Tick.Info) storage self,
 170 |     |         int24 tick,
 171 |     |         uint256 feeGrowthGlobal0X128,
 172 |     |         uint256 feeGrowthGlobal1X128,
 173 |     |         uint160 secondsPerLiquidityCumulativeX128,
 174 |     |         int56 tickCumulative,
 175 |     |         uint32 time
 176 |     |     ) internal returns (int128 liquidityNet) {
 177 | *   |         Tick.Info storage info = self[tick];
 178 | *   |         info.feeGrowthOutside0X128 = feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;
 179 | *   |         info.feeGrowthOutside1X128 = feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;
 180 | *   |         info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128 - info.secondsPerLiquidityOutsideX128;
 181 | *   |         info.tickCumulativeOutside = tickCumulative - info.tickCumulativeOutside;
 182 | *   |         info.secondsOutside = time - info.secondsOutside;
 183 | *   |         liquidityNet = info.liquidityNet;
 184 |     |     }
 185 |     | }
 186 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/TickBitmap.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | import './BitMath.sol';
  5 |     | 
  6 |     | /// @title Packed tick initialized state library
  7 |     | /// @notice Stores a packed mapping of tick index to its initialized state
  8 |     | /// @dev The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.
  9 |     | library TickBitmap {
 10 |     |     /// @notice Computes the position in the mapping where the initialized bit for a tick lives
 11 |     |     /// @param tick The tick for which to compute the position
 12 |     |     /// @return wordPos The key in the mapping containing the word in which the bit is stored
 13 |     |     /// @return bitPos The bit position in the word where the flag is stored
 14 | *   |     function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {
 15 | *   |         wordPos = int16(tick >> 8);
 16 | *   |         bitPos = uint8(tick % 256);
 17 |     |     }
 18 |     | 
 19 |     |     /// @notice Flips the initialized state for a given tick from false to true, or vice versa
 20 |     |     /// @param self The mapping in which to flip the tick
 21 |     |     /// @param tick The tick to flip
 22 |     |     /// @param tickSpacing The spacing between usable ticks
 23 | *   |     function flipTick(
 24 |     |         mapping(int16 => uint256) storage self,
 25 |     |         int24 tick,
 26 |     |         int24 tickSpacing
 27 |     |     ) internal {
 28 | *   |         require(tick % tickSpacing == 0); // ensure that the tick is spaced
 29 | *   |         (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);
 30 | *   |         uint256 mask = 1 << bitPos;
 31 | *   |         self[wordPos] ^= mask;
 32 |     |     }
 33 |     | 
 34 |     |     /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either
 35 |     |     /// to the left (less than or equal to) or right (greater than) of the given tick
 36 |     |     /// @param self The mapping in which to compute the next initialized tick
 37 |     |     /// @param tick The starting tick
 38 |     |     /// @param tickSpacing The spacing between usable ticks
 39 |     |     /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)
 40 |     |     /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick
 41 |     |     /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks
 42 | *   |     function nextInitializedTickWithinOneWord(
 43 |     |         mapping(int16 => uint256) storage self,
 44 |     |         int24 tick,
 45 |     |         int24 tickSpacing,
 46 |     |         bool lte
 47 | *   |     ) internal view returns (int24 next, bool initialized) {
 48 | *   |         int24 compressed = tick / tickSpacing;
 49 | *   |         if (tick < 0 && tick % tickSpacing != 0) compressed--; // round towards negative infinity
 50 |     | 
 51 | *   |         if (lte) {
 52 | *   |             (int16 wordPos, uint8 bitPos) = position(compressed);
 53 |     |             // all the 1s at or to the right of the current bitPos
 54 | *   |             uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);
 55 | *   |             uint256 masked = self[wordPos] & mask;
 56 |     | 
 57 |     |             // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word
 58 | *   |             initialized = masked != 0;
 59 |     |             // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick
 60 | *   |             next = initialized
 61 | *   |                 ? (compressed - int24(bitPos - BitMath.mostSignificantBit(masked))) * tickSpacing
 62 | *   |                 : (compressed - int24(bitPos)) * tickSpacing;
 63 |     |         } else {
 64 |     |             // start from the word of the next tick, since the current tick state doesn't matter
 65 | *   |             (int16 wordPos, uint8 bitPos) = position(compressed + 1);
 66 |     |             // all the 1s at or to the left of the bitPos
 67 | *   |             uint256 mask = ~((1 << bitPos) - 1);
 68 |     |             uint256 masked = self[wordPos] & mask;
 69 |     | 
 70 |     |             // if there are no initialized ticks to the left of the current tick, return leftmost in the word
 71 |     |             initialized = masked != 0;
 72 |     |             // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick
 73 |     |             next = initialized
 74 |     |                 ? (compressed + 1 + int24(BitMath.leastSignificantBit(masked) - bitPos)) * tickSpacing
 75 |     |                 : (compressed + 1 + int24(type(uint8).max - bitPos)) * tickSpacing;
 76 |     |         }
 77 |     |     }
 78 |     | }
 79 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/TickMath.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0 <0.8.0;
   3 |     | 
   4 |     | /// @title Math library for computing sqrt prices from ticks and vice versa
   5 |     | /// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports
   6 |     | /// prices between 2**-128 and 2**128
   7 |     | library TickMath {
   8 |     |     /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128
   9 |     |     int24 internal constant MIN_TICK = -887272;
  10 |     |     /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128
  11 | *   |     int24 internal constant MAX_TICK = -MIN_TICK;
  12 |     | 
  13 |     |     /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
  14 | *   |     uint160 internal constant MIN_SQRT_RATIO = 4295128739;
  15 |     |     /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)
  16 | *   |     uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;
  17 |     | 
  18 |     |     /// @notice Calculates sqrt(1.0001^tick) * 2^96
  19 |     |     /// @dev Throws if |tick| > max tick
  20 |     |     /// @param tick The input tick for the above formula
  21 |     |     /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
  22 |     |     /// at the given tick
  23 | *   |     function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
  24 | *   |         uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
  25 | *   |         require(absTick <= uint256(MAX_TICK), 'T');
  26 |     | 
  27 | *   |         uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
  28 | *   |         if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
  29 | *   |         if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
  30 | *   |         if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
  31 | *   |         if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
  32 | *   |         if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
  33 | *   |         if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
  34 | *   |         if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
  35 | *   |         if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
  36 | *   |         if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
  37 | *   |         if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
  38 | *   |         if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
  39 | *   |         if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
  40 | *   |         if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
  41 | *   |         if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
  42 | *   |         if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
  43 | *   |         if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
  44 | *   |         if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
  45 | *   |         if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
  46 | *   |         if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
  47 |     | 
  48 | *   |         if (tick > 0) ratio = type(uint256).max / ratio;
  49 |     | 
  50 |     |         // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
  51 |     |         // we then downcast because we know the result always fits within 160 bits due to our tick input constraint
  52 |     |         // we round up in the division so getTickAtSqrtRatio of the output price is always consistent
  53 | *   |         sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
  54 |     |     }
  55 |     | 
  56 |     |     /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio
  57 |     |     /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may
  58 |     |     /// ever return.
  59 |     |     /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96
  60 |     |     /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio
  61 | *   |     function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
  62 |     |         // second inequality must be < because the price can never reach the price at the max tick
  63 | *   |         require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');
  64 |     |         uint256 ratio = uint256(sqrtPriceX96) << 32;
  65 |     | 
  66 |     |         uint256 r = ratio;
  67 |     |         uint256 msb = 0;
  68 |     | 
  69 |     |         assembly {
  70 |     |             let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
  71 |     |             msb := or(msb, f)
  72 |     |             r := shr(f, r)
  73 |     |         }
  74 |     |         assembly {
  75 |     |             let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
  76 | *   |             msb := or(msb, f)
  77 |     |             r := shr(f, r)
  78 |     |         }
  79 |     |         assembly {
  80 | *   |             let f := shl(5, gt(r, 0xFFFFFFFF))
  81 | *   |             msb := or(msb, f)
  82 | *   |             r := shr(f, r)
  83 |     |         }
  84 |     |         assembly {
  85 | *   |             let f := shl(4, gt(r, 0xFFFF))
  86 | *   |             msb := or(msb, f)
  87 | *   |             r := shr(f, r)
  88 |     |         }
  89 |     |         assembly {
  90 | *   |             let f := shl(3, gt(r, 0xFF))
  91 | *   |             msb := or(msb, f)
  92 | *   |             r := shr(f, r)
  93 |     |         }
  94 |     |         assembly {
  95 | *   |             let f := shl(2, gt(r, 0xF))
  96 | *   |             msb := or(msb, f)
  97 | *   |             r := shr(f, r)
  98 |     |         }
  99 |     |         assembly {
 100 | *   |             let f := shl(1, gt(r, 0x3))
 101 | *   |             msb := or(msb, f)
 102 | *   |             r := shr(f, r)
 103 |     |         }
 104 |     |         assembly {
 105 | *   |             let f := gt(r, 0x1)
 106 | *   |             msb := or(msb, f)
 107 |     |         }
 108 |     | 
 109 | *   |         if (msb >= 128) r = ratio >> (msb - 127);
 110 | *   |         else r = ratio << (127 - msb);
 111 |     | 
 112 | *   |         int256 log_2 = (int256(msb) - 128) << 64;
 113 |     | 
 114 |     |         assembly {
 115 | *   |             r := shr(127, mul(r, r))
 116 | *   |             let f := shr(128, r)
 117 | *   |             log_2 := or(log_2, shl(63, f))
 118 | *   |             r := shr(f, r)
 119 |     |         }
 120 |     |         assembly {
 121 | *   |             r := shr(127, mul(r, r))
 122 | *   |             let f := shr(128, r)
 123 | *   |             log_2 := or(log_2, shl(62, f))
 124 | *   |             r := shr(f, r)
 125 |     |         }
 126 |     |         assembly {
 127 | *   |             r := shr(127, mul(r, r))
 128 | *   |             let f := shr(128, r)
 129 | *   |             log_2 := or(log_2, shl(61, f))
 130 | *   |             r := shr(f, r)
 131 |     |         }
 132 |     |         assembly {
 133 | *   |             r := shr(127, mul(r, r))
 134 | *   |             let f := shr(128, r)
 135 | *   |             log_2 := or(log_2, shl(60, f))
 136 | *   |             r := shr(f, r)
 137 |     |         }
 138 |     |         assembly {
 139 | *   |             r := shr(127, mul(r, r))
 140 | *   |             let f := shr(128, r)
 141 | *   |             log_2 := or(log_2, shl(59, f))
 142 | *   |             r := shr(f, r)
 143 |     |         }
 144 |     |         assembly {
 145 | *   |             r := shr(127, mul(r, r))
 146 | *   |             let f := shr(128, r)
 147 | *   |             log_2 := or(log_2, shl(58, f))
 148 | *   |             r := shr(f, r)
 149 |     |         }
 150 |     |         assembly {
 151 | *   |             r := shr(127, mul(r, r))
 152 | *   |             let f := shr(128, r)
 153 | *   |             log_2 := or(log_2, shl(57, f))
 154 | *   |             r := shr(f, r)
 155 |     |         }
 156 |     |         assembly {
 157 | *   |             r := shr(127, mul(r, r))
 158 | *   |             let f := shr(128, r)
 159 | *   |             log_2 := or(log_2, shl(56, f))
 160 | *   |             r := shr(f, r)
 161 |     |         }
 162 |     |         assembly {
 163 | *   |             r := shr(127, mul(r, r))
 164 | *   |             let f := shr(128, r)
 165 | *   |             log_2 := or(log_2, shl(55, f))
 166 | *   |             r := shr(f, r)
 167 |     |         }
 168 |     |         assembly {
 169 | *   |             r := shr(127, mul(r, r))
 170 | *   |             let f := shr(128, r)
 171 | *   |             log_2 := or(log_2, shl(54, f))
 172 | *   |             r := shr(f, r)
 173 |     |         }
 174 |     |         assembly {
 175 | *   |             r := shr(127, mul(r, r))
 176 | *   |             let f := shr(128, r)
 177 | *   |             log_2 := or(log_2, shl(53, f))
 178 | *   |             r := shr(f, r)
 179 |     |         }
 180 |     |         assembly {
 181 | *   |             r := shr(127, mul(r, r))
 182 | *   |             let f := shr(128, r)
 183 | *   |             log_2 := or(log_2, shl(52, f))
 184 | *   |             r := shr(f, r)
 185 |     |         }
 186 |     |         assembly {
 187 | *   |             r := shr(127, mul(r, r))
 188 | *   |             let f := shr(128, r)
 189 | *   |             log_2 := or(log_2, shl(51, f))
 190 | *   |             r := shr(f, r)
 191 |     |         }
 192 |     |         assembly {
 193 | *   |             r := shr(127, mul(r, r))
 194 |     |             let f := shr(128, r)
 195 | *   |             log_2 := or(log_2, shl(50, f))
 196 |     |         }
 197 |     | 
 198 | *   |         int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number
 199 |     | 
 200 | *   |         int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
 201 | *   |         int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
 202 |     | 
 203 | *   |         tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
 204 |     |     }
 205 |     | }
 206 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/TransferHelper.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.6.0;
  3 |     | 
  4 |     | import '../interfaces/IERC20Minimal.sol';
  5 |     | 
  6 |     | /// @title TransferHelper
  7 |     | /// @notice Contains helper methods for interacting with ERC20 tokens that do not consistently return true/false
  8 |     | library TransferHelper {
  9 |     |     /// @notice Transfers tokens from msg.sender to a recipient
 10 |     |     /// @dev Calls transfer on token contract, errors with TF if transfer fails
 11 |     |     /// @param token The contract address of the token which will be transferred
 12 |     |     /// @param to The recipient of the transfer
 13 |     |     /// @param value The value of the transfer
 14 | *   |     function safeTransfer(
 15 |     |         address token,
 16 |     |         address to,
 17 |     |         uint256 value
 18 |     |     ) internal {
 19 | *   |         (bool success, bytes memory data) =
 20 | *   |             token.call(abi.encodeWithSelector(IERC20Minimal.transfer.selector, to, value));
 21 | *   |         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TF');
 22 |     |     }
 23 |     | }
 24 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/UnsafeMath.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Math functions that do not check inputs or outputs
  5 |     | /// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks
  6 |     | library UnsafeMath {
  7 |     |     /// @notice Returns ceil(x / y)
  8 |     |     /// @dev division by 0 has unspecified behavior, and must be checked externally
  9 |     |     /// @param x The dividend
 10 |     |     /// @param y The divisor
 11 |     |     /// @return z The quotient, ceil(x / y)
 12 |     |     function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
 13 |     |         assembly {
 14 |     |             z := add(div(x, y), gt(mod(x, y), 0))
 15 |     |         }
 16 |     |     }
 17 |     | }
 18 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/test/TestERC20.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity =0.7.6;
  3 |     | 
  4 |     | import '../interfaces/IERC20Minimal.sol';
  5 |     | 
  6 | *   | contract TestERC20 is IERC20Minimal {
  7 | *   |     mapping(address => uint256) public override balanceOf;
  8 |     |     mapping(address => mapping(address => uint256)) public override allowance;
  9 |     | 
 10 |     |     constructor(uint256 amountToMint) {
 11 |     |         mint(msg.sender, amountToMint);
 12 |     |     }
 13 |     | 
 14 | *   |     function mint(address to, uint256 amount) public {
 15 |     |         uint256 balanceNext = balanceOf[to] + amount;
 16 |     |         require(balanceNext >= amount, 'overflow balance');
 17 |     |         balanceOf[to] = balanceNext;
 18 |     |     }
 19 |     | 
 20 | *   |     function transfer(address recipient, uint256 amount) external override returns (bool) {
 21 | *   |         uint256 balanceBefore = balanceOf[msg.sender];
 22 | *   |         require(balanceBefore >= amount, 'insufficient balance');
 23 | *   |         balanceOf[msg.sender] = balanceBefore - amount;
 24 |     | 
 25 | *   |         uint256 balanceRecipient = balanceOf[recipient];
 26 | *   |         require(balanceRecipient + amount >= balanceRecipient, 'recipient balance overflow');
 27 | *   |         balanceOf[recipient] = balanceRecipient + amount;
 28 |     | 
 29 | *   |         emit Transfer(msg.sender, recipient, amount);
 30 | *   |         return true;
 31 |     |     }
 32 |     | 
 33 | *   |     function approve(address spender, uint256 amount) external override returns (bool) {
 34 |     |         allowance[msg.sender][spender] = amount;
 35 |     |         emit Approval(msg.sender, spender, amount);
 36 |     |         return true;
 37 |     |     }
 38 |     | 
 39 |     |     function transferFrom(
 40 |     |         address sender,
 41 |     |         address recipient,
 42 |     |         uint256 amount
 43 |     |     ) external override returns (bool) {
 44 |     |         uint256 allowanceBefore = allowance[sender][msg.sender];
 45 |     |         require(allowanceBefore >= amount, 'allowance insufficient');
 46 |     | 
 47 |     |         allowance[sender][msg.sender] = allowanceBefore - amount;
 48 |     | 
 49 |     |         uint256 balanceRecipient = balanceOf[recipient];
 50 |     |         require(balanceRecipient + amount >= balanceRecipient, 'overflow balance recipient');
 51 |     |         balanceOf[recipient] = balanceRecipient + amount;
 52 |     |         uint256 balanceSender = balanceOf[sender];
 53 |     |         require(balanceSender >= amount, 'underflow balance sender');
 54 |     |         balanceOf[sender] = balanceSender - amount;
 55 |     | 
 56 |     |         emit Transfer(sender, recipient, amount);
 57 |     |         return true;
 58 |     |     }
 59 |     | }
 60 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/lib/chimera/src/Asserts.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.7.6;
  3 |     | 
  4 |     | abstract contract Asserts {
  5 |     |     function gt(uint256 a, uint256 b, string memory reason) internal virtual;
  6 |     | 
  7 |     |     function gte(uint256 a, uint256 b, string memory reason) internal virtual;
  8 |     | 
  9 |     |     function lt(uint256 a, uint256 b, string memory reason) internal virtual;
 10 |     | 
 11 |     |     function lte(uint256 a, uint256 b, string memory reason) internal virtual;
 12 |     | 
 13 |     |     function eq(uint256 a, uint256 b, string memory reason) internal virtual;
 14 |     | 
 15 |     |     function t(bool b, string memory reason) internal virtual;
 16 |     | 
 17 |     |     function between(uint256 value, uint256 low, uint256 high) internal virtual returns (uint256);
 18 |     | 
 19 |     |     function between(int256 value, int256 low, int256 high) internal virtual returns (int256);
 20 |     | 
 21 |     |     function precondition(bool p) internal virtual;
 22 |     | }
 23 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/lib/chimera/src/BaseProperties.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity ^0.7.6;
 3 |     | 
 4 |     | import {BaseSetup} from './BaseSetup.sol';
 5 |     | 
 6 |     | abstract contract BaseProperties is BaseSetup {}
 7 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/lib/chimera/src/BaseSetup.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity ^0.7.6;
 3 |     | 
 4 |     | abstract contract BaseSetup {
 5 |     |     function setup() internal virtual;
 6 |     | }
 7 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/lib/chimera/src/BaseTargetFunctions.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity ^0.7.6;
 3 |     | 
 4 |     | import {BaseProperties} from './BaseProperties.sol';
 5 |     | import {Asserts} from './Asserts.sol';
 6 |     | 
 7 |     | abstract contract BaseTargetFunctions is BaseProperties, Asserts {}
 8 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/lib/chimera/src/CryticAsserts.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.7.6;
  3 |     | 
  4 |     | import {Asserts} from './Asserts.sol';
  5 |     | 
  6 |     | contract CryticAsserts is Asserts {
  7 |     |     event Log(string);
  8 |     | 
  9 |     |     function gt(uint256 a, uint256 b, string memory reason) internal virtual override {
 10 |     |         emit Log(reason);
 11 |     |         assert(a > b);
 12 |     |     }
 13 |     | 
 14 |     |     function gte(uint256 a, uint256 b, string memory reason) internal virtual override {
 15 |     |         emit Log(reason);
 16 |     |         assert(a >= b);
 17 |     |     }
 18 |     | 
 19 |     |     function lt(uint256 a, uint256 b, string memory reason) internal virtual override {
 20 |     |         emit Log(reason);
 21 |     |         assert(a < b);
 22 |     |     }
 23 |     | 
 24 |     |     function lte(uint256 a, uint256 b, string memory reason) internal virtual override {
 25 |     |         emit Log(reason);
 26 |     |         assert(a <= b);
 27 |     |     }
 28 |     | 
 29 |     |     function eq(uint256 a, uint256 b, string memory reason) internal virtual override {
 30 |     |         emit Log(reason);
 31 |     |         assert(a == b);
 32 |     |     }
 33 |     | 
 34 |     |     function t(bool b, string memory reason) internal virtual override {
 35 |     |         emit Log(reason);
 36 |     |         assert(b);
 37 |     |     }
 38 |     | 
 39 |     |     function between(uint256 value, uint256 low, uint256 high) internal virtual override returns (uint256) {
 40 |     |         if (value < low || value > high) {
 41 |     |             uint256 ans = low + (value % (high - low + 1));
 42 |     |             return ans;
 43 |     |         }
 44 |     |         return value;
 45 |     |     }
 46 |     | 
 47 |     |     function between(int256 value, int256 low, int256 high) internal virtual override returns (int256) {
 48 |     |         if (value < low || value > high) {
 49 |     |             int256 range = high - low + 1;
 50 |     |             int256 clamped = (value - low) % (range);
 51 |     |             if (clamped < 0) clamped += range;
 52 |     |             int256 ans = low + clamped;
 53 |     |             return ans;
 54 |     |         }
 55 |     |         return value;
 56 |     |     }
 57 |     | 
 58 |     |     function precondition(bool p) internal virtual override {
 59 |     |         require(p);
 60 |     |     }
 61 |     | }
 62 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/lib/chimera/src/Hevm.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma abicoder v2;
  3 |     | 
  4 |     | interface IHevm {
  5 |     |     // Set block.timestamp to newTimestamp
  6 |     |     function warp(uint256 newTimestamp) external;
  7 |     | 
  8 |     |     // Set block.number to newNumber
  9 |     |     function roll(uint256 newNumber) external;
 10 |     | 
 11 |     |     // Loads a storage slot from an address
 12 |     |     function load(address where, bytes32 slot) external returns (bytes32);
 13 |     | 
 14 |     |     // Stores a value to an address' storage slot
 15 |     |     function store(address where, bytes32 slot, bytes32 value) external;
 16 |     | 
 17 |     |     // Signs data (privateKey, digest) => (r, v, s)
 18 |     |     function sign(uint256 privateKey, bytes32 digest) external returns (uint8 r, bytes32 v, bytes32 s);
 19 |     | 
 20 |     |     // Gets address for a given private key
 21 |     |     function addr(uint256 privateKey) external returns (address account);
 22 |     | 
 23 |     |     // Performs a foreign function call via terminal
 24 |     |     function ffi(string[] calldata inputs) external returns (bytes memory result);
 25 |     | 
 26 |     |     // Performs the next smart contract call with specified `msg.sender`
 27 |     |     function prank(address newSender) external;
 28 |     | }
 29 |     | 
 30 |     | IHevm constant vm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
 31 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/test/recon/BeforeAfter.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.7.6;
  3 |     | 
  4 |     | import {Setup} from './Setup.sol';
  5 |     | import 'contracts/UniswapV3Pool.sol';
  6 |     | import 'contracts/libraries/Position.sol';
  7 |     | 
  8 |     | abstract contract BeforeAfter is Setup {
  9 |     |     struct Slot0 {
 10 |     |         // the current price
 11 |     |         uint160 sqrtPriceX96;
 12 |     |         // the current tick
 13 |     |         int24 tick;
 14 |     |         // the most-recently updated index of the observations array
 15 |     |         uint16 observationIndex;
 16 |     |         // the current maximum number of observations that are being stored
 17 |     |         uint16 observationCardinality;
 18 |     |         // the next maximum number of observations to store, triggered in observations.write
 19 |     |         uint16 observationCardinalityNext;
 20 |     |         // the current protocol fee as a percentage of the swap fee taken on withdrawal
 21 |     |         // represented as an integer denominator (1/x)%
 22 |     |         uint8 feeProtocol;
 23 |     |         // whether the pool is locked
 24 |     |         bool unlocked;
 25 |     |     }
 26 |     | 
 27 |     |     struct Vars {
 28 |     |         mapping(bytes32 => Position.Info) uniswapV3Pool_positions;
 29 |     |         uint256 testERC20_balanceOfToken0;
 30 |     |         uint256 testERC20_balanceOfToken1;
 31 |     |         // SwapperStats = liquidity, freeGrowthGlobal0, freeGrowthGlobal1, token0 balance, token1 balance
 32 |     |         uint256 uniswapV3Pool_feeGrowthGlobal0X128;
 33 |     |         uint256 uniswapV3Pool_feeGrowthGlobal1X128;
 34 |     |         uint128 uniswapV3Pool_liquidity;
 35 |     |         int24 uniswapV3Pool_currentTick;
 36 |     |     }
 37 |     | 
 38 |     |     Vars internal _before;
 39 |     |     Vars internal _after;
 40 |     | 
 41 | *   |     function __before() internal {
 42 |     |         // replaced original implementation to allow querying balance of token0 and token1
 43 | *   |         _before.testERC20_balanceOfToken0 = token0.balanceOf(address(this));
 44 | *   |         _before.testERC20_balanceOfToken1 = token1.balanceOf(address(this));
 45 |     | 
 46 | *   |         (, _before.uniswapV3Pool_currentTick, , , , , ) = uniswapV3Pool.slot0();
 47 | *   |         _before.uniswapV3Pool_feeGrowthGlobal0X128 = uniswapV3Pool.feeGrowthGlobal0X128();
 48 | *   |         _before.uniswapV3Pool_feeGrowthGlobal1X128 = uniswapV3Pool.feeGrowthGlobal1X128();
 49 | *   |         _before.uniswapV3Pool_liquidity = uniswapV3Pool.liquidity();
 50 |     |     }
 51 |     | 
 52 | *   |     function __after() internal {
 53 | *   |         _after.testERC20_balanceOfToken0 = token0.balanceOf(address(this));
 54 | *   |         _after.testERC20_balanceOfToken1 = token1.balanceOf(address(this));
 55 |     | 
 56 | *   |         (, _after.uniswapV3Pool_currentTick, , , , , ) = uniswapV3Pool.slot0();
 57 | *   |         _after.uniswapV3Pool_feeGrowthGlobal0X128 = uniswapV3Pool.feeGrowthGlobal0X128();
 58 | *   |         _after.uniswapV3Pool_feeGrowthGlobal1X128 = uniswapV3Pool.feeGrowthGlobal1X128();
 59 | *   |         _after.uniswapV3Pool_liquidity = uniswapV3Pool.liquidity();
 60 |     |     }
 61 |     | }
 62 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/test/recon/CryticTester.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.7.6;
  3 |     | 
  4 |     | import {TargetFunctions} from './TargetFunctions.sol';
  5 |     | import {CryticAsserts} from '@chimera/CryticAsserts.sol';
  6 |     | 
  7 |     | // echidna . --contract CryticTester --config echidna.yaml
  8 |     | // medusa fuzz
  9 | *or | contract CryticTester is TargetFunctions, CryticAsserts {
 10 |     |     constructor() payable {
 11 |     |         setup();
 12 |     |     }
 13 |     | }
 14 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/test/recon/Properties.sol
 1 |     | // SPDX-License-Identifier: UNLICENSED
 2 |     | pragma solidity ^0.7.6;
 3 |     | 
 4 |     | import {Asserts} from '@chimera/Asserts.sol';
 5 |     | import {Setup} from './Setup.sol';
 6 |     | 
 7 |     | abstract contract Properties is Setup, Asserts {}
 8 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/test/recon/Setup.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma abicoder v2;
   3 |     | 
   4 |     | import {BaseSetup} from '@chimera/BaseSetup.sol';
   5 |     | 
   6 |     | import 'contracts/interfaces/IUniswapV3Factory.sol';
   7 |     | import 'contracts/interfaces/callback/IUniswapV3FlashCallback.sol';
   8 |     | import 'contracts/UniswapV3PoolDeployer.sol';
   9 |     | import 'contracts/UniswapV3Factory.sol';
  10 |     | import 'contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol';
  11 |     | import 'contracts/interfaces/IUniswapV3PoolDeployer.sol';
  12 |     | import 'contracts/interfaces/IERC20Minimal.sol';
  13 |     | import 'contracts/interfaces/IUniswapV3Pool.sol';
  14 |     | import 'contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol';
  15 |     | import 'contracts/interfaces/pool/IUniswapV3PoolEvents.sol';
  16 |     | import 'contracts/interfaces/pool/IUniswapV3PoolState.sol';
  17 |     | import 'contracts/interfaces/pool/IUniswapV3PoolActions.sol';
  18 |     | import 'contracts/interfaces/callback/IUniswapV3SwapCallback.sol';
  19 |     | import 'contracts/interfaces/callback/IUniswapV3MintCallback.sol';
  20 |     | import 'contracts/interfaces/pool/IUniswapV3PoolImmutables.sol';
  21 |     | import 'contracts/UniswapV3Pool.sol';
  22 |     | import 'contracts/test/TestERC20.sol';
  23 |     | import 'test/recon/SetupUniswap.sol';
  24 |     | import 'contracts/libraries/TickMath.sol';
  25 |     | 
  26 |     | abstract contract Setup is BaseSetup {
  27 |     |     UniswapV3Pool uniswapV3Pool;
  28 |     |     TestERC20 testERC20; //default from harness
  29 |     |     TestERC20 token0;
  30 |     |     TestERC20 token1;
  31 |     | 
  32 |     |     SetupTokens tokens;
  33 |     |     SetupUniswap uniswap;
  34 |     | 
  35 |     |     // UniswapV3Pool pool;
  36 |     | 
  37 |     |     UniswapMinter minter;
  38 |     |     UniswapSwapper swapper;
  39 |     | 
  40 |     |     PoolParams poolParams;
  41 |     |     PoolPositions poolPositions;
  42 |     |     PoolPosition[] positions;
  43 |     | 
  44 |     |     int24[] usedTicks;
  45 |     |     bool inited;
  46 |     | 
  47 |     |     struct PoolParams {
  48 |     |         uint24 fee;
  49 |     |         int24 tickSpacing;
  50 |     |         int24 minTick;
  51 |     |         int24 maxTick;
  52 |     |         uint24 tickCount;
  53 |     |         uint160 startPrice;
  54 |     |         int24 startTick;
  55 |     |     }
  56 |     | 
  57 |     |     struct PoolPosition {
  58 |     |         int24 tickLower;
  59 |     |         int24 tickUpper;
  60 |     |         uint128 amount;
  61 |     |         bytes32 key;
  62 |     |     }
  63 |     | 
  64 |     |     struct PoolPositions {
  65 |     |         int24[] tickLowers;
  66 |     |         int24[] tickUppers;
  67 |     |         uint128[] amounts;
  68 |     |     }
  69 |     | 
  70 |     |     function setup() internal virtual override {
  71 |     |         // uniswapV3Pool = new UniswapV3Pool(); // pool requires more complicated initialization steps so using the ToB initialization function
  72 |     |         testERC20 = new TestERC20(1e9 ether);
  73 |     |         token0 = new TestERC20(1e9 ether);
  74 |     |         token1 = new TestERC20(1e9 ether);
  75 |     | 
  76 |     |         // setup for tests
  77 |     |         tokens = new SetupTokens();
  78 |     |         token0 = tokens.token0();
  79 |     |         token1 = tokens.token1();
  80 |     | 
  81 |     |         uniswap = new SetupUniswap(token0, token1);
  82 |     | 
  83 |     |         minter = new UniswapMinter(token0, token1);
  84 |     |         swapper = new UniswapSwapper(token0, token1);
  85 |     | 
  86 |     |         tokens.mintTo(0, address(swapper), 1e9 ether);
  87 |     |         tokens.mintTo(1, address(swapper), 1e9 ether);
  88 |     | 
  89 |     |         tokens.mintTo(0, address(minter), 1e10 ether);
  90 |     |         tokens.mintTo(1, address(minter), 1e10 ether);
  91 |     |     }
  92 |     | 
  93 |     |     // helper functions
  94 | *   |     function _init(uint128 _seed) internal {
  95 |     |         //
  96 |     |         // generate random pool params
  97 |     |         //
  98 | *   |         poolParams = forgePoolParams(_seed);
  99 |     | 
 100 |     |         //
 101 |     |         // deploy the pool
 102 |     |         //
 103 | *   |         uniswap.createPool(poolParams.fee, poolParams.startPrice);
 104 | *   |         uniswapV3Pool = uniswap.pool();
 105 |     | 
 106 |     |         //
 107 |     |         // set the pool inside the minter and swapper contracts
 108 |     |         //
 109 | *   |         minter.setPool(uniswapV3Pool);
 110 | *   |         swapper.setPool(uniswapV3Pool);
 111 |     | 
 112 |     |         //
 113 |     |         // generate random positions
 114 |     |         //
 115 | *   |         poolPositions = forgePoolPositions(_seed, poolParams.tickSpacing, poolParams.tickCount, poolParams.maxTick);
 116 |     | 
 117 |     |         //
 118 |     |         // create the positions
 119 |     |         //
 120 | *   |         for (uint8 i = 0; i < poolPositions.tickLowers.length; i++) {
 121 | *   |             int24 tickLower = poolPositions.tickLowers[i];
 122 | *   |             int24 tickUpper = poolPositions.tickUppers[i];
 123 | *   |             uint128 amount = poolPositions.amounts[i];
 124 |     | 
 125 | *r  |             minter.doMint(tickLower, tickUpper, amount);
 126 |     | 
 127 | *   |             bool lowerAlreadyUsed = false;
 128 | *   |             bool upperAlreadyUsed = false;
 129 | *   |             for (uint8 j = 0; j < usedTicks.length; j++) {
 130 | *   |                 if (usedTicks[j] == tickLower) lowerAlreadyUsed = true;
 131 | *   |                 else if (usedTicks[j] == tickUpper) upperAlreadyUsed = true;
 132 |     |             }
 133 | *   |             if (!lowerAlreadyUsed) usedTicks.push(tickLower);
 134 | *   |             if (!upperAlreadyUsed) usedTicks.push(tickUpper);
 135 |     |         }
 136 |     | 
 137 | *   |         inited = true;
 138 |     |     }
 139 |     | 
 140 | *   |     function forgePoolParams(uint128 _seed) internal view returns (PoolParams memory poolParams) {
 141 |     |         //
 142 |     |         // decide on one of the three fees, and corresponding tickSpacing
 143 |     |         //
 144 | *   |         if (_seed % 3 == 0) {
 145 | *   |             poolParams.fee = uint24(500);
 146 | *   |             poolParams.tickSpacing = int24(10);
 147 | *   |         } else if (_seed % 3 == 1) {
 148 | *   |             poolParams.fee = uint24(3000);
 149 | *   |             poolParams.tickSpacing = int24(60);
 150 | *   |         } else if (_seed % 3 == 2) {
 151 | *   |             poolParams.fee = uint24(10000);
 152 | *   |             poolParams.tickSpacing = int24(2000);
 153 |     |         }
 154 |     | 
 155 | *   |         poolParams.maxTick = (int24(887272) / poolParams.tickSpacing) * poolParams.tickSpacing;
 156 | *   |         poolParams.minTick = -poolParams.maxTick;
 157 | *   |         poolParams.tickCount = uint24(poolParams.maxTick / poolParams.tickSpacing);
 158 |     | 
 159 |     |         //
 160 |     |         // set the initial price
 161 |     |         //
 162 | *   |         poolParams.startTick = int24((_seed % uint128(poolParams.tickCount)) * uint128(poolParams.tickSpacing));
 163 | *   |         if (_seed % 3 == 0) {
 164 |     |             // set below 0
 165 | *   |             poolParams.startPrice = TickMath.getSqrtRatioAtTick(-poolParams.startTick);
 166 | *   |         } else if (_seed % 3 == 1) {
 167 |     |             // set at 0
 168 | *   |             poolParams.startPrice = TickMath.getSqrtRatioAtTick(0);
 169 | *   |             poolParams.startTick = 0;
 170 | *   |         } else if (_seed % 3 == 2) {
 171 |     |             // set above 0
 172 | *   |             poolParams.startPrice = TickMath.getSqrtRatioAtTick(poolParams.startTick);
 173 |     |         }
 174 |     |     }
 175 |     | 
 176 | *   |     function forgePoolPositions(
 177 |     |         uint128 _seed,
 178 |     |         int24 _poolTickSpacing,
 179 |     |         uint24 _poolTickCount,
 180 |     |         int24 _poolMaxTick
 181 | *   |     ) internal view returns (PoolPositions memory poolPositions_) {
 182 |     |         // between 1 and 10 (inclusive) positions
 183 | *   |         uint8 positionsCount = uint8(_seed % 10) + 1;
 184 |     | 
 185 | *   |         poolPositions_.tickLowers = new int24[](positionsCount);
 186 | *   |         poolPositions_.tickUppers = new int24[](positionsCount);
 187 | *   |         poolPositions_.amounts = new uint128[](positionsCount);
 188 |     | 
 189 | *   |         for (uint8 i = 0; i < positionsCount; i++) {
 190 | *   |             int24 tickLower;
 191 |     |             int24 tickUpper;
 192 |     |             uint128 amount;
 193 |     | 
 194 | *   |             int24 randomTick1 = int24((_seed % uint128(_poolTickCount)) * uint128(_poolTickSpacing));
 195 |     | 
 196 | *   |             if (_seed % 2 == 0) {
 197 |     |                 // make tickLower positive
 198 | *   |                 tickLower = randomTick1;
 199 |     | 
 200 |     |                 // tickUpper is somewhere above tickLower
 201 | *   |                 uint24 poolTickCountLeft = uint24((_poolMaxTick - randomTick1) / _poolTickSpacing);
 202 | *   |                 int24 randomTick2 = int24((_seed % uint128(poolTickCountLeft)) * uint128(_poolTickSpacing));
 203 | *   |                 tickUpper = tickLower + randomTick2;
 204 |     |             } else {
 205 |     |                 // make tickLower negative or zero
 206 | *   |                 tickLower = randomTick1 == 0 ? 0 : -randomTick1;
 207 |     | 
 208 | *   |                 uint24 poolTickCountNegativeLeft = uint24((_poolMaxTick - randomTick1) / _poolTickSpacing);
 209 | *   |                 uint24 poolTickCountTotalLeft = poolTickCountNegativeLeft + _poolTickCount;
 210 |     | 
 211 | *   |                 uint24 randomIncrement = uint24((_seed % uint128(poolTickCountTotalLeft)) * uint128(_poolTickSpacing));
 212 |     | 
 213 | *   |                 if (randomIncrement <= uint24(tickLower)) {
 214 |     |                     // tickUpper will also be negative
 215 | *   |                     tickUpper = tickLower + int24(randomIncrement);
 216 |     |                 } else {
 217 |     |                     // tickUpper is positive
 218 | *   |                     randomIncrement -= uint24(-tickLower);
 219 | *   |                     tickUpper = tickLower + int24(randomIncrement);
 220 |     |                 }
 221 |     |             }
 222 |     | 
 223 | *   |             amount = uint128(1e8 ether);
 224 |     | 
 225 | *   |             poolPositions_.tickLowers[i] = tickLower;
 226 | *   |             poolPositions_.tickUppers[i] = tickUpper;
 227 | *   |             poolPositions_.amounts[i] = amount;
 228 |     | 
 229 | *   |             _seed += uint128(tickLower);
 230 |     |         }
 231 |     |     }
 232 |     | 
 233 | *   |     function get_random_zeroForOne_priceLimit(
 234 |     |         int256 _amountSpecified
 235 | *   |     ) internal view returns (uint160 sqrtPriceLimitX96) {
 236 |     |         // help echidna a bit by calculating a valid sqrtPriceLimitX96 using the amount as random seed
 237 | *   |         (uint160 currentPrice, , , , , , ) = uniswapV3Pool.slot0();
 238 | *   |         uint160 minimumPrice = TickMath.MIN_SQRT_RATIO;
 239 |     |         sqrtPriceLimitX96 =
 240 | *   |             minimumPrice +
 241 |     |             uint160(
 242 | *   |                 (uint256(_amountSpecified > 0 ? _amountSpecified : -_amountSpecified) % (currentPrice - minimumPrice))
 243 |     |             );
 244 |     |     }
 245 |     | 
 246 | *   |     function get_random_oneForZero_priceLimit(
 247 |     |         int256 _amountSpecified
 248 | *   |     ) internal view returns (uint160 sqrtPriceLimitX96) {
 249 |     |         // help echidna a bit by calculating a valid sqrtPriceLimitX96 using the amount as random seed
 250 | *   |         (uint160 currentPrice, , , , , , ) = uniswapV3Pool.slot0();
 251 | *   |         uint160 maximumPrice = TickMath.MAX_SQRT_RATIO;
 252 | *   |         sqrtPriceLimitX96 =
 253 | *   |             currentPrice +
 254 |     |             uint160(
 255 | *   |                 (uint256(_amountSpecified > 0 ? _amountSpecified : -_amountSpecified) % (maximumPrice - currentPrice))
 256 |     |             );
 257 |     |     }
 258 |     | 
 259 | *   |     function check_swap_invariants(
 260 |     |         int24 tick_bfre,
 261 |     |         int24 tick_aftr,
 262 |     |         uint128 liq_bfre,
 263 |     |         uint128 liq_aftr,
 264 |     |         uint256 bal_sell_bfre,
 265 |     |         uint256 bal_sell_aftr,
 266 |     |         uint256 bal_buy_bfre,
 267 |     |         uint256 bal_buy_aftr,
 268 |     |         uint256 feegrowth_sell_bfre,
 269 |     |         uint256 feegrowth_sell_aftr,
 270 |     |         uint256 feegrowth_buy_bfre,
 271 |     |         uint256 feegrowth_buy_aftr
 272 |     |     ) internal {
 273 |     |         // prop #17
 274 | *   |         if (tick_bfre == tick_aftr) {
 275 | *   |             assert(liq_bfre == liq_aftr);
 276 |     |         }
 277 |     |     }
 278 |     | 
 279 |     |     function _getRandomPositionIdx(uint128 _seed, uint256 _positionsCount) internal view returns (uint128 positionIdx) {
 280 |     |         positionIdx = _seed % uint128(_positionsCount);
 281 |     |     }
 282 |     | 
 283 |     |     function _getRandomBurnAmount(uint128 _seed, uint128 _positionAmount) internal view returns (uint128 burnAmount) {
 284 |     |         burnAmount = _seed % _positionAmount;
 285 |     |         require(burnAmount < _positionAmount);
 286 |     |         require(burnAmount > 0);
 287 |     |     }
 288 |     | 
 289 |     |     function _getRandomPositionIdxAndBurnAmount(
 290 |     |         uint128 _seed
 291 |     |     ) internal view returns (uint128 positionIdx, uint128 burnAmount) {
 292 |     |         positionIdx = _getRandomPositionIdx(_seed, positions.length);
 293 |     |         burnAmount = _getRandomBurnAmount(_seed, positions[positionIdx].amount);
 294 |     |     }
 295 |     | 
 296 |     |     function check_burn_invariants(
 297 |     |         uint128 _burnAmount,
 298 |     |         int24 _tickLower,
 299 |     |         int24 _tickUpper,
 300 |     |         uint128 _newPosAmount,
 301 |     |         UniswapMinter.MinterStats memory bfre,
 302 |     |         UniswapMinter.MinterStats memory aftr
 303 |     |     ) internal {
 304 |     |         (, int24 currentTick, , , , , ) = uniswapV3Pool.slot0();
 305 |     | 
 306 |     |         bytes32 positionKey = keccak256(abi.encodePacked(address(minter), _tickLower, _tickUpper));
 307 |     |         (uint128 positionLiquidity, , , , ) = uniswapV3Pool.positions(positionKey);
 308 |     | 
 309 |     |         // prop #27
 310 |     |         assert(positionLiquidity == _newPosAmount);
 311 |     |     }
 312 |     | }
 313 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/test/recon/SetupUniswap.sol
   1 |     | pragma solidity =0.7.6;
   2 |     | pragma abicoder v2;
   3 |     | 
   4 |     | import '../../../../../contracts/test/TestERC20.sol';
   5 |     | import '../../../../../contracts/UniswapV3Pool.sol';
   6 |     | import '../../../../../contracts/UniswapV3Factory.sol';
   7 |     | 
   8 |     | contract SetupToken {
   9 |     |     TestERC20 public token;
  10 |     | 
  11 |     |     constructor() {
  12 |     |         // this contract will receive the total supply of 100 tokens
  13 |     |         token = new TestERC20(1e12 ether);
  14 |     |     }
  15 |     | 
  16 |     |     function mintTo(address _recipient, uint256 _amount) public {
  17 |     |         token.transfer(_recipient, _amount);
  18 |     |     }
  19 |     | }
  20 |     | 
  21 |     | contract SetupTokens {
  22 |     |     SetupToken tokenSetup0;
  23 |     |     SetupToken tokenSetup1;
  24 |     | 
  25 |     |     TestERC20 public token0;
  26 |     |     TestERC20 public token1;
  27 |     | 
  28 |     |     constructor() {
  29 |     |         // create the token wrappers
  30 |     |         tokenSetup0 = new SetupToken();
  31 |     |         tokenSetup1 = new SetupToken();
  32 |     | 
  33 |     |         // switch them around so that token0's address is lower than token1's
  34 |     |         // since this is what the uniswap factory will do when you create the pool
  35 |     |         if (address(tokenSetup0.token()) > address(tokenSetup1.token())) {
  36 |     |             (tokenSetup0, tokenSetup1) = (tokenSetup1, tokenSetup0);
  37 |     |         }
  38 |     | 
  39 |     |         // save the erc20 tokens
  40 |     |         token0 = tokenSetup0.token();
  41 |     |         token1 = tokenSetup1.token();
  42 |     |     }
  43 |     | 
  44 |     |     // mint either token0 or token1 to a chosen account
  45 |     |     function mintTo(uint256 _tokenIdx, address _recipient, uint256 _amount) public {
  46 |     |         require(_tokenIdx == 0 || _tokenIdx == 1, 'invalid token idx');
  47 |     |         if (_tokenIdx == 0) tokenSetup0.mintTo(_recipient, _amount);
  48 |     |         if (_tokenIdx == 1) tokenSetup1.mintTo(_recipient, _amount);
  49 |     |     }
  50 |     | }
  51 |     | 
  52 | *   | contract SetupUniswap {
  53 | *   |     UniswapV3Pool public pool;
  54 |     |     TestERC20 token0;
  55 |     |     TestERC20 token1;
  56 |     | 
  57 |     |     // will create the following enabled fees and corresponding tickSpacing
  58 |     |     // fee 500   + tickSpacing 10
  59 |     |     // fee 3000  + tickSpacing 60
  60 |     |     // fee 10000 + tickSpacing 200
  61 |     |     UniswapV3Factory factory;
  62 |     | 
  63 |     |     constructor(TestERC20 _token0, TestERC20 _token1) {
  64 |     |         factory = new UniswapV3Factory();
  65 |     |         token0 = _token0;
  66 |     |         token1 = _token1;
  67 |     |     }
  68 |     | 
  69 | *   |     function createPool(uint24 _fee, uint160 _startPrice) public {
  70 | *   |         pool = UniswapV3Pool(factory.createPool(address(token0), address(token1), _fee));
  71 | *   |         pool.initialize(_startPrice);
  72 |     |     }
  73 |     | }
  74 |     | 
  75 | *   | contract UniswapMinter {
  76 |     |     UniswapV3Pool pool;
  77 |     |     TestERC20 token0;
  78 |     |     TestERC20 token1;
  79 |     | 
  80 |     |     struct MinterStats {
  81 |     |         uint128 liq;
  82 |     |         uint128 tL_liqGross;
  83 |     |         int128 tL_liqNet;
  84 |     |         uint128 tU_liqGross;
  85 |     |         int128 tU_liqNet;
  86 |     |     }
  87 |     | 
  88 |     |     constructor(TestERC20 _token0, TestERC20 _token1) {
  89 |     |         token0 = _token0;
  90 |     |         token1 = _token1;
  91 |     |     }
  92 |     | 
  93 | *   |     function setPool(UniswapV3Pool _pool) public {
  94 | *   |         pool = _pool;
  95 |     |     }
  96 |     | 
  97 | *   |     function uniswapV3MintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes calldata data) external {
  98 | *   |         if (amount0Owed > 0) token0.transfer(address(pool), amount0Owed);
  99 | *   |         if (amount1Owed > 0) token1.transfer(address(pool), amount1Owed);
 100 |     |     }
 101 |     | 
 102 | *   |     function getTickLiquidityVars(
 103 |     |         int24 _tickLower,
 104 |     |         int24 _tickUpper
 105 | *   |     ) internal view returns (uint128, int128, uint128, int128) {
 106 | *   |         (uint128 tL_liqGross, int128 tL_liqNet, , , , , , ) = pool.ticks(_tickLower);
 107 | *   |         (uint128 tU_liqGross, int128 tU_liqNet, , , , , , ) = pool.ticks(_tickUpper);
 108 | *   |         return (tL_liqGross, tL_liqNet, tU_liqGross, tU_liqNet);
 109 |     |     }
 110 |     | 
 111 | *   |     function getStats(int24 _tickLower, int24 _tickUpper) internal view returns (MinterStats memory stats) {
 112 | *   |         (uint128 tL_lg, int128 tL_ln, uint128 tU_lg, int128 tU_ln) = getTickLiquidityVars(_tickLower, _tickUpper);
 113 | *   |         return MinterStats(pool.liquidity(), tL_lg, tL_ln, tU_lg, tU_ln);
 114 |     |     }
 115 |     | 
 116 | *   |     function doMint(
 117 |     |         int24 _tickLower,
 118 |     |         int24 _tickUpper,
 119 |     |         uint128 _amount
 120 | *   |     ) public returns (MinterStats memory bfre, MinterStats memory aftr) {
 121 | *   |         bfre = getStats(_tickLower, _tickUpper);
 122 | *   |         pool.mint(address(this), _tickLower, _tickUpper, _amount, new bytes(0));
 123 |     |         aftr = getStats(_tickLower, _tickUpper);
 124 |     |     }
 125 |     | 
 126 | *   |     function doBurn(
 127 |     |         int24 _tickLower,
 128 |     |         int24 _tickUpper,
 129 |     |         uint128 _amount
 130 |     |     ) public returns (MinterStats memory bfre, MinterStats memory aftr) {
 131 |     |         bfre = getStats(_tickLower, _tickUpper);
 132 | *   |         pool.burn(_tickLower, _tickUpper, _amount);
 133 | *   |         aftr = getStats(_tickLower, _tickUpper);
 134 |     |     }
 135 |     | }
 136 |     | 
 137 | *   | contract UniswapSwapper {
 138 |     |     UniswapV3Pool pool;
 139 |     |     TestERC20 token0;
 140 |     |     TestERC20 token1;
 141 |     | 
 142 |     |     struct SwapperStats {
 143 |     |         uint128 liq;
 144 |     |         uint256 feeGrowthGlobal0X128;
 145 |     |         uint256 feeGrowthGlobal1X128;
 146 |     |         uint256 bal0;
 147 |     |         uint256 bal1;
 148 |     |         int24 tick;
 149 |     |     }
 150 |     | 
 151 |     |     constructor(TestERC20 _token0, TestERC20 _token1) {
 152 |     |         token0 = _token0;
 153 |     |         token1 = _token1;
 154 |     |     }
 155 |     | 
 156 | *   |     function setPool(UniswapV3Pool _pool) public {
 157 | *   |         pool = _pool;
 158 |     |     }
 159 |     | 
 160 | *   |     function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external {
 161 | *   |         if (amount0Delta > 0) token0.transfer(address(pool), uint256(amount0Delta));
 162 | *   |         if (amount1Delta > 0) token1.transfer(address(pool), uint256(amount1Delta));
 163 |     |     }
 164 |     | 
 165 | *   |     function getStats() internal view returns (SwapperStats memory stats) {
 166 | *   |         (, int24 currentTick, , , , , ) = pool.slot0();
 167 | *   |         return
 168 | *   |             SwapperStats(
 169 | *   |                 pool.liquidity(),
 170 | *   |                 pool.feeGrowthGlobal0X128(),
 171 | *   |                 pool.feeGrowthGlobal1X128(),
 172 | *   |                 token0.balanceOf(address(this)),
 173 | *   |                 token1.balanceOf(address(this)),
 174 | *   |                 currentTick
 175 |     |             );
 176 |     |     }
 177 |     | 
 178 | *   |     function doSwap(
 179 |     |         bool _zeroForOne,
 180 |     |         int256 _amountSpecified,
 181 |     |         uint160 _sqrtPriceLimitX96
 182 | *   |     ) public returns (SwapperStats memory bfre, SwapperStats memory aftr) {
 183 | *   |         bfre = getStats();
 184 | *   |         pool.swap(address(this), _zeroForOne, _amountSpecified, _sqrtPriceLimitX96, new bytes(0));
 185 | *   |         aftr = getStats();
 186 |     |     }
 187 |     | }
 188 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/test/recon/TargetFunctions.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma abicoder v2;
   3 |     | 
   4 |     | import {BaseTargetFunctions} from '@chimera/BaseTargetFunctions.sol';
   5 |     | import {BeforeAfter} from './BeforeAfter.sol';
   6 |     | import {Properties} from './Properties.sol';
   7 |     | import {vm} from '@chimera/Hevm.sol';
   8 |     | import 'contracts/libraries/TickMath.sol';
   9 |     | import 'test/recon/SetupUniswap.sol';
  10 |     | 
  11 |     | abstract contract TargetFunctions is BaseTargetFunctions, Properties, BeforeAfter {
  12 |     |     function uniswapV3Pool_collect(
  13 |     |         address recipient,
  14 |     |         int24 tickLower,
  15 |     |         int24 tickUpper,
  16 |     |         uint128 amount0Requested,
  17 |     |         uint128 amount1Requested
  18 |     |     ) public {
  19 |     |         uniswapV3Pool.collect(recipient, tickLower, tickUpper, amount0Requested, amount1Requested);
  20 |     |     }
  21 |     | 
  22 |     |     function uniswapV3Pool_collectProtocol(
  23 |     |         address recipient,
  24 |     |         uint128 amount0Requested,
  25 |     |         uint128 amount1Requested
  26 |     |     ) public {
  27 |     |         uniswapV3Pool.collectProtocol(recipient, amount0Requested, amount1Requested);
  28 |     |     }
  29 |     | 
  30 |     |     function uniswapV3Pool_flash(address recipient, uint256 amount0, uint256 amount1, bytes calldata data) public {
  31 |     |         uniswapV3Pool.flash(recipient, amount0, amount1, data);
  32 |     |     }
  33 |     | 
  34 |     |     function uniswapV3Pool_increaseObservationCardinalityNext(uint16 observationCardinalityNext) public {
  35 |     |         uniswapV3Pool.increaseObservationCardinalityNext(observationCardinalityNext);
  36 |     |     }
  37 |     | 
  38 | *   |     function uniswapV3Pool_initialize(uint160 sqrtPriceX96) public {
  39 | *   |         uniswapV3Pool.initialize(sqrtPriceX96);
  40 |     |     }
  41 |     | 
  42 | *   |     function uniswapV3Pool_mint(
  43 |     |         address recipient,
  44 |     |         int24 tickLower,
  45 |     |         int24 tickUpper,
  46 |     |         uint128 amount,
  47 |     |         bytes calldata data
  48 |     |     ) public {
  49 |     |         uniswapV3Pool.mint(recipient, tickLower, tickUpper, amount, data);
  50 |     |     }
  51 |     | 
  52 |     |     function uniswapV3Pool_setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) public {
  53 |     |         uniswapV3Pool.setFeeProtocol(feeProtocol0, feeProtocol1);
  54 |     |     }
  55 |     | 
  56 |     |     function testERC20_approve(address spender, uint256 amount) public {
  57 |     |         testERC20.approve(spender, amount);
  58 |     |     }
  59 |     | 
  60 |     |     function testERC20_mint(address to, uint256 amount) public {
  61 |     |         testERC20.mint(to, amount);
  62 |     |     }
  63 |     | 
  64 |     |     function testERC20_transfer(address recipient, uint256 amount) public {
  65 |     |         testERC20.transfer(recipient, amount);
  66 |     |     }
  67 |     | 
  68 |     |     function testERC20_transferFrom(address sender, address recipient, uint256 amount) public {
  69 |     |         testERC20.transferFrom(sender, recipient, amount);
  70 |     |     }
  71 |     | 
  72 |     |     // swap invariant prop #17
  73 | *   |     function test_swap_exactIn_zeroForOne(uint128 _amount) public {
  74 | *r  |         require(_amount != 0);
  75 |     | 
  76 | *   |         if (!inited) _init(_amount);
  77 |     | 
  78 | *r  |         require(token0.balanceOf(address(swapper)) >= uint256(_amount));
  79 | *   |         int256 _amountSpecified = int256(_amount);
  80 |     | 
  81 | *   |         uint160 sqrtPriceLimitX96 = get_random_zeroForOne_priceLimit(_amount);
  82 |     |         // console.log('sqrtPriceLimitX96 = %s', sqrtPriceLimitX96);
  83 |     | 
  84 |     |         __before();
  85 |     |         swapper.doSwap(true, _amountSpecified, sqrtPriceLimitX96);
  86 |     |         __after();
  87 |     | 
  88 |     |         int24 beforeCurrentTick = _before.uniswapV3Pool_currentTick;
  89 |     |         int24 afterCurrentTick = _after.uniswapV3Pool_currentTick;
  90 |     | 
  91 |     |         check_swap_invariants(
  92 |     |             beforeCurrentTick,
  93 |     |             afterCurrentTick,
  94 |     |             _before.uniswapV3Pool_liquidity,
  95 |     |             _after.uniswapV3Pool_liquidity,
  96 |     |             _before.testERC20_balanceOfToken0,
  97 |     |             _after.testERC20_balanceOfToken0,
  98 |     |             _before.testERC20_balanceOfToken1,
  99 |     |             _after.testERC20_balanceOfToken1,
 100 |     |             _before.uniswapV3Pool_feeGrowthGlobal0X128,
 101 |     |             _after.uniswapV3Pool_feeGrowthGlobal0X128,
 102 |     |             _before.uniswapV3Pool_feeGrowthGlobal1X128,
 103 |     |             _after.uniswapV3Pool_feeGrowthGlobal1X128
 104 |     |         );
 105 |     |     }
 106 |     | 
 107 | *   |     function test_swap_exactIn_oneForZero(uint128 _amount) public {
 108 | *r  |         require(_amount != 0);
 109 |     | 
 110 | *   |         if (!inited) _init(_amount);
 111 |     | 
 112 | *r  |         require(token1.balanceOf(address(swapper)) >= uint256(_amount));
 113 | *   |         int256 _amountSpecified = int256(_amount);
 114 |     | 
 115 | *   |         uint160 sqrtPriceLimitX96 = get_random_oneForZero_priceLimit(_amount);
 116 |     |         // console.log('sqrtPriceLimitX96 = %s', sqrtPriceLimitX96);
 117 |     | 
 118 | *   |         __before();
 119 | *r  |         swapper.doSwap(true, _amountSpecified, sqrtPriceLimitX96);
 120 | *   |         __after();
 121 |     | 
 122 | *   |         int24 beforeCurrentTick = _before.uniswapV3Pool_currentTick;
 123 | *   |         int24 afterCurrentTick = _after.uniswapV3Pool_currentTick;
 124 |     | 
 125 | *   |         check_swap_invariants(
 126 |     |             beforeCurrentTick,
 127 |     |             afterCurrentTick,
 128 | *   |             _before.uniswapV3Pool_liquidity,
 129 | *   |             _after.uniswapV3Pool_liquidity,
 130 | *   |             _before.testERC20_balanceOfToken0,
 131 | *   |             _after.testERC20_balanceOfToken0,
 132 | *   |             _before.testERC20_balanceOfToken1,
 133 | *   |             _after.testERC20_balanceOfToken1,
 134 | *   |             _before.uniswapV3Pool_feeGrowthGlobal0X128,
 135 | *   |             _after.uniswapV3Pool_feeGrowthGlobal0X128,
 136 | *   |             _before.uniswapV3Pool_feeGrowthGlobal1X128,
 137 | *   |             _after.uniswapV3Pool_feeGrowthGlobal1X128
 138 |     |         );
 139 |     |     }
 140 |     | 
 141 | *   |     function test_swap_exactOut_zeroForOne(uint128 _amount) public {
 142 | *r  |         require(_amount != 0);
 143 |     | 
 144 | *   |         if (!inited) _init(_amount);
 145 |     | 
 146 | *   |         require(token0.balanceOf(address(swapper)) > 0);
 147 | *   |         int256 _amountSpecified = -int256(_amount);
 148 |     | 
 149 | *   |         uint160 sqrtPriceLimitX96 = get_random_zeroForOne_priceLimit(_amount);
 150 |     |         // console.log('sqrtPriceLimitX96 = %s', sqrtPriceLimitX96);
 151 |     | 
 152 |     |         __before();
 153 |     |         swapper.doSwap(true, _amountSpecified, sqrtPriceLimitX96);
 154 |     |         __after();
 155 |     | 
 156 |     |         int24 beforeCurrentTick = _before.uniswapV3Pool_currentTick;
 157 |     |         int24 afterCurrentTick = _after.uniswapV3Pool_currentTick;
 158 |     | 
 159 |     |         check_swap_invariants(
 160 |     |             beforeCurrentTick,
 161 |     |             afterCurrentTick,
 162 |     |             _before.uniswapV3Pool_liquidity,
 163 |     |             _after.uniswapV3Pool_liquidity,
 164 |     |             _before.testERC20_balanceOfToken0,
 165 |     |             _after.testERC20_balanceOfToken0,
 166 |     |             _before.testERC20_balanceOfToken1,
 167 |     |             _after.testERC20_balanceOfToken1,
 168 |     |             _before.uniswapV3Pool_feeGrowthGlobal0X128,
 169 |     |             _after.uniswapV3Pool_feeGrowthGlobal0X128,
 170 |     |             _before.uniswapV3Pool_feeGrowthGlobal1X128,
 171 |     |             _after.uniswapV3Pool_feeGrowthGlobal1X128
 172 |     |         );
 173 |     |     }
 174 |     | 
 175 | *   |     function test_swap_exactOut_oneForZero(uint128 _amount) public {
 176 | *r  |         require(_amount != 0);
 177 |     | 
 178 | *   |         if (!inited) _init(_amount);
 179 |     | 
 180 | *   |         require(token0.balanceOf(address(swapper)) > 0);
 181 | *   |         int256 _amountSpecified = -int256(_amount);
 182 |     | 
 183 | *   |         uint160 sqrtPriceLimitX96 = get_random_oneForZero_priceLimit(_amount);
 184 |     |         // console.log('sqrtPriceLimitX96 = %s', sqrtPriceLimitX96);
 185 |     | 
 186 |     |         __before();
 187 |     |         swapper.doSwap(true, _amountSpecified, sqrtPriceLimitX96);
 188 |     |         __after();
 189 |     | 
 190 |     |         int24 beforeCurrentTick = _before.uniswapV3Pool_currentTick;
 191 |     |         int24 afterCurrentTick = _after.uniswapV3Pool_currentTick;
 192 |     | 
 193 |     |         check_swap_invariants(
 194 |     |             beforeCurrentTick,
 195 |     |             afterCurrentTick,
 196 |     |             _before.uniswapV3Pool_liquidity,
 197 |     |             _after.uniswapV3Pool_liquidity,
 198 |     |             _before.testERC20_balanceOfToken0,
 199 |     |             _after.testERC20_balanceOfToken0,
 200 |     |             _before.testERC20_balanceOfToken1,
 201 |     |             _after.testERC20_balanceOfToken1,
 202 |     |             _before.uniswapV3Pool_feeGrowthGlobal0X128,
 203 |     |             _after.uniswapV3Pool_feeGrowthGlobal0X128,
 204 |     |             _before.uniswapV3Pool_feeGrowthGlobal1X128,
 205 |     |             _after.uniswapV3Pool_feeGrowthGlobal1X128
 206 |     |         );
 207 |     |     }
 208 |     | }
 209 |     | 

