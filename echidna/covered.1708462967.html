<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/NoDelegateCall.sol</b>
<code>
  1 |     | <span class='unexecuted'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity =0.7.6;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Prevents delegatecall to a contract</span>
  5 |     | <span class='neutral'>/// @notice Base contract that provides a modifier for preventing delegatecall to methods in a child contract</span>
  6 |     | <span class='neutral'>abstract contract NoDelegateCall {</span>
  7 |     | <span class='neutral'>    /// @dev The original address of this contract</span>
  8 |     | <span class='neutral'>    address private immutable original;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    constructor() {</span>
 11 |     | <span class='neutral'>        // Immutables are computed in the init code of the contract, and then inlined into the deployed bytecode.</span>
 12 |     | <span class='neutral'>        // In other words, this variable won&#39;t change when it&#39;s checked at runtime.</span>
 13 | *   | <span class='executed'>        original = address(this);</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    /// @dev Private method is used instead of inlining into modifier because modifiers are copied into each method,</span>
 17 |     | <span class='neutral'>    ///     and the use of immutable means the address bytes are copied in every place the modifier is used.</span>
 18 | *   | <span class='executed'>    function checkNotDelegateCall() private view {</span>
 19 | *   | <span class='executed'>        require(address(this) == original);</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    /// @notice Prevents delegatecall into the modified method</span>
 23 |     | <span class='neutral'>    modifier noDelegateCall() {</span>
 24 | *   | <span class='executed'>        checkNotDelegateCall();</span>
 25 | *   | <span class='executed'>        _;</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/UniswapV3Factory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity =0.7.6;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./interfaces/IUniswapV3Factory.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &#39;./UniswapV3PoolDeployer.sol&#39;;</span>
  7 |     | <span class='neutral'>import &#39;./NoDelegateCall.sol&#39;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>import &#39;./UniswapV3Pool.sol&#39;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>/// @title Canonical Uniswap V3 factory</span>
 12 |     | <span class='neutral'>/// @notice Deploys Uniswap V3 pools and manages ownership and control over pool protocol fees</span>
 13 | *   | <span class='executed'>contract UniswapV3Factory is IUniswapV3Factory, UniswapV3PoolDeployer, NoDelegateCall {</span>
 14 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3Factory</span>
 15 |     | <span class='unexecuted'>    address public override owner;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3Factory</span>
 18 |     | <span class='unexecuted'>    mapping(uint24 =&gt; int24) public override feeAmountTickSpacing;</span>
 19 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3Factory</span>
 20 | *   | <span class='executed'>    mapping(address =&gt; mapping(address =&gt; mapping(uint24 =&gt; address))) public override getPool;</span>
 21 |     | <span class='neutral'></span>
 22 | *   | <span class='executed'>    constructor() {</span>
 23 |     | <span class='unexecuted'>        owner = msg.sender;</span>
 24 |     | <span class='unexecuted'>        emit OwnerChanged(address(0), msg.sender);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>        feeAmountTickSpacing[500] = 10;</span>
 27 |     | <span class='unexecuted'>        emit FeeAmountEnabled(500, 10);</span>
 28 |     | <span class='unexecuted'>        feeAmountTickSpacing[3000] = 60;</span>
 29 |     | <span class='unexecuted'>        emit FeeAmountEnabled(3000, 60);</span>
 30 |     | <span class='unexecuted'>        feeAmountTickSpacing[10000] = 200;</span>
 31 |     | <span class='unexecuted'>        emit FeeAmountEnabled(10000, 200);</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3Factory</span>
 35 | *   | <span class='executed'>    function createPool(</span>
 36 |     | <span class='neutral'>        address tokenA,</span>
 37 |     | <span class='neutral'>        address tokenB,</span>
 38 |     | <span class='neutral'>        uint24 fee</span>
 39 | *   | <span class='executed'>    ) external override noDelegateCall returns (address pool) {</span>
 40 | *   | <span class='executed'>        require(tokenA != tokenB);</span>
 41 | *   | <span class='executed'>        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);</span>
 42 | *   | <span class='executed'>        require(token0 != address(0));</span>
 43 | *   | <span class='executed'>        int24 tickSpacing = feeAmountTickSpacing[fee];</span>
 44 | *   | <span class='executed'>        require(tickSpacing != 0);</span>
 45 | *   | <span class='executed'>        require(getPool[token0][token1][fee] == address(0));</span>
 46 | *   | <span class='executed'>        pool = deploy(address(this), token0, token1, fee, tickSpacing);</span>
 47 | *   | <span class='executed'>        getPool[token0][token1][fee] = pool;</span>
 48 |     | <span class='neutral'>        // populate mapping in the reverse direction, deliberate choice to avoid the cost of comparing addresses</span>
 49 | *   | <span class='executed'>        getPool[token1][token0][fee] = pool;</span>
 50 | *   | <span class='executed'>        emit PoolCreated(token0, token1, fee, tickSpacing, pool);</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3Factory</span>
 54 |     | <span class='unexecuted'>    function setOwner(address _owner) external override {</span>
 55 |     | <span class='unexecuted'>        require(msg.sender == owner);</span>
 56 |     | <span class='unexecuted'>        emit OwnerChanged(owner, _owner);</span>
 57 |     | <span class='unexecuted'>        owner = _owner;</span>
 58 |     | <span class='neutral'>    }</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3Factory</span>
 61 |     | <span class='unexecuted'>    function enableFeeAmount(uint24 fee, int24 tickSpacing) public override {</span>
 62 |     | <span class='unexecuted'>        require(msg.sender == owner);</span>
 63 |     | <span class='unexecuted'>        require(fee &lt; 1000000);</span>
 64 |     | <span class='neutral'>        // tick spacing is capped at 16384 to prevent the situation where tickSpacing is so large that</span>
 65 |     | <span class='neutral'>        // TickBitmap#nextInitializedTickWithinOneWord overflows int24 container from a valid tick</span>
 66 |     | <span class='neutral'>        // 16384 ticks represents a &gt;5x price change with ticks of 1 bips</span>
 67 |     | <span class='unexecuted'>        require(tickSpacing &gt; 0 &amp;&amp; tickSpacing &lt; 16384);</span>
 68 |     | <span class='unexecuted'>        require(feeAmountTickSpacing[fee] == 0);</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='unexecuted'>        feeAmountTickSpacing[fee] = tickSpacing;</span>
 71 |     | <span class='unexecuted'>        emit FeeAmountEnabled(fee, tickSpacing);</span>
 72 |     | <span class='neutral'>    }</span>
 73 |     | <span class='neutral'>}</span>
 74 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/UniswapV3Pool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity =0.7.6;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./interfaces/IUniswapV3Pool.sol&#39;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &#39;./NoDelegateCall.sol&#39;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>import &#39;./libraries/LowGasSafeMath.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./libraries/SafeCast.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./libraries/Tick.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./libraries/TickBitmap.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;./libraries/Position.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;./libraries/Oracle.sol&#39;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>import &#39;./libraries/FullMath.sol&#39;;</span>
  16 |     | <span class='neutral'>import &#39;./libraries/FixedPoint128.sol&#39;;</span>
  17 |     | <span class='neutral'>import &#39;./libraries/TransferHelper.sol&#39;;</span>
  18 |     | <span class='neutral'>import &#39;./libraries/TickMath.sol&#39;;</span>
  19 |     | <span class='neutral'>import &#39;./libraries/LiquidityMath.sol&#39;;</span>
  20 |     | <span class='neutral'>import &#39;./libraries/SqrtPriceMath.sol&#39;;</span>
  21 |     | <span class='neutral'>import &#39;./libraries/SwapMath.sol&#39;;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>import &#39;./interfaces/IUniswapV3PoolDeployer.sol&#39;;</span>
  24 |     | <span class='neutral'>import &#39;./interfaces/IUniswapV3Factory.sol&#39;;</span>
  25 |     | <span class='neutral'>import &#39;./interfaces/IERC20Minimal.sol&#39;;</span>
  26 |     | <span class='neutral'>import &#39;./interfaces/callback/IUniswapV3MintCallback.sol&#39;;</span>
  27 |     | <span class='neutral'>import &#39;./interfaces/callback/IUniswapV3SwapCallback.sol&#39;;</span>
  28 |     | <span class='neutral'>import &#39;./interfaces/callback/IUniswapV3FlashCallback.sol&#39;;</span>
  29 |     | <span class='neutral'></span>
  30 | *   | <span class='executed'>contract UniswapV3Pool is IUniswapV3Pool, NoDelegateCall {</span>
  31 |     | <span class='neutral'>    using LowGasSafeMath for uint256;</span>
  32 |     | <span class='neutral'>    using LowGasSafeMath for int256;</span>
  33 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  34 |     | <span class='neutral'>    using SafeCast for int256;</span>
  35 |     | <span class='neutral'>    using Tick for mapping(int24 =&gt; Tick.Info);</span>
  36 |     | <span class='neutral'>    using TickBitmap for mapping(int16 =&gt; uint256);</span>
  37 |     | <span class='neutral'>    using Position for mapping(bytes32 =&gt; Position.Info);</span>
  38 |     | <span class='neutral'>    using Position for Position.Info;</span>
  39 |     | <span class='neutral'>    using Oracle for Oracle.Observation[65535];</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolImmutables</span>
  42 |     | <span class='unexecuted'>    address public immutable override factory;</span>
  43 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolImmutables</span>
  44 | *   | <span class='executed'>    address public immutable override token0;</span>
  45 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolImmutables</span>
  46 |     | <span class='unexecuted'>    address public immutable override token1;</span>
  47 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolImmutables</span>
  48 |     | <span class='unexecuted'>    uint24 public immutable override fee;</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolImmutables</span>
  51 |     | <span class='unexecuted'>    int24 public immutable override tickSpacing;</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolImmutables</span>
  54 |     | <span class='unexecuted'>    uint128 public immutable override maxLiquidityPerTick;</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    struct Slot0 {</span>
  57 |     | <span class='neutral'>        // the current price</span>
  58 |     | <span class='neutral'>        uint160 sqrtPriceX96;</span>
  59 |     | <span class='neutral'>        // the current tick</span>
  60 |     | <span class='neutral'>        int24 tick;</span>
  61 |     | <span class='neutral'>        // the most-recently updated index of the observations array</span>
  62 |     | <span class='neutral'>        uint16 observationIndex;</span>
  63 |     | <span class='neutral'>        // the current maximum number of observations that are being stored</span>
  64 |     | <span class='neutral'>        uint16 observationCardinality;</span>
  65 |     | <span class='neutral'>        // the next maximum number of observations to store, triggered in observations.write</span>
  66 |     | <span class='neutral'>        uint16 observationCardinalityNext;</span>
  67 |     | <span class='neutral'>        // the current protocol fee as a percentage of the swap fee taken on withdrawal</span>
  68 |     | <span class='neutral'>        // represented as an integer denominator (1/x)%</span>
  69 |     | <span class='neutral'>        uint8 feeProtocol;</span>
  70 |     | <span class='neutral'>        // whether the pool is locked</span>
  71 |     | <span class='neutral'>        bool unlocked;</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
  74 | *   | <span class='executed'>    Slot0 public override slot0;</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
  77 |     | <span class='unexecuted'>    uint256 public override feeGrowthGlobal0X128;</span>
  78 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
  79 | *   | <span class='executed'>    uint256 public override feeGrowthGlobal1X128;</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    // accumulated protocol fees in token0/token1 units</span>
  82 |     | <span class='neutral'>    struct ProtocolFees {</span>
  83 |     | <span class='neutral'>        uint128 token0;</span>
  84 |     | <span class='neutral'>        uint128 token1;</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
  87 | *   | <span class='executed'>    ProtocolFees public override protocolFees;</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
  90 | *   | <span class='executed'>    uint128 public override liquidity;</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
  93 | *   | <span class='executed'>    mapping(int24 =&gt; Tick.Info) public override ticks;</span>
  94 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
  95 |     | <span class='unexecuted'>    mapping(int16 =&gt; uint256) public override tickBitmap;</span>
  96 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
  97 |     | <span class='unexecuted'>    mapping(bytes32 =&gt; Position.Info) public override positions;</span>
  98 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
  99 | *   | <span class='executed'>    Oracle.Observation[65535] public override observations;</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    /// @dev Mutually exclusive reentrancy protection into the pool to/from a method. This method also prevents entrance</span>
 102 |     | <span class='neutral'>    /// to a function before the pool is initialized. The reentrancy guard is required throughout the contract because</span>
 103 |     | <span class='neutral'>    /// we use balance checks to determine the payment status of interactions such as mint, swap and flash.</span>
 104 |     | <span class='neutral'>    modifier lock() {</span>
 105 | *   | <span class='executed'>        require(slot0.unlocked, &#39;LOK&#39;);</span>
 106 |     | <span class='unexecuted'>        slot0.unlocked = false;</span>
 107 |     | <span class='neutral'>        _;</span>
 108 | *   | <span class='executed'>        slot0.unlocked = true;</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /// @dev Prevents calling a function from anyone except the address returned by IUniswapV3Factory#owner()</span>
 112 |     | <span class='neutral'>    modifier onlyFactoryOwner() {</span>
 113 |     | <span class='unexecuted'>        require(msg.sender == IUniswapV3Factory(factory).owner());</span>
 114 |     | <span class='neutral'>        _;</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 | *   | <span class='executed'>    constructor() {</span>
 118 | *   | <span class='executed'>        int24 _tickSpacing;</span>
 119 | *   | <span class='executed'>        (factory, token0, token1, fee, _tickSpacing) = IUniswapV3PoolDeployer(msg.sender).parameters();</span>
 120 |     | <span class='unexecuted'>        tickSpacing = _tickSpacing;</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>        maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(_tickSpacing);</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    /// @dev Common checks for valid tick inputs.</span>
 126 | *   | <span class='executed'>    function checkTicks(int24 tickLower, int24 tickUpper) private pure {</span>
 127 | *   | <span class='executed'>        require(tickLower &lt; tickUpper, &#39;TLU&#39;);</span>
 128 | *   | <span class='executed'>        require(tickLower &gt;= TickMath.MIN_TICK, &#39;TLM&#39;);</span>
 129 | *   | <span class='executed'>        require(tickUpper &lt;= TickMath.MAX_TICK, &#39;TUM&#39;);</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    /// @dev Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.</span>
 133 | *   | <span class='executed'>    function _blockTimestamp() internal view virtual returns (uint32) {</span>
 134 |     | <span class='unexecuted'>        return uint32(block.timestamp); // truncation is desired</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    /// @dev Get the pool&#39;s balance of token0</span>
 138 |     | <span class='neutral'>    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize</span>
 139 |     | <span class='neutral'>    /// check</span>
 140 | *   | <span class='executed'>    function balance0() private view returns (uint256) {</span>
 141 | *   | <span class='executed'>        (bool success, bytes memory data) = token0.staticcall(</span>
 142 | *   | <span class='executed'>            abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this))</span>
 143 |     | <span class='neutral'>        );</span>
 144 | *   | <span class='executed'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 145 | *   | <span class='executed'>        return abi.decode(data, (uint256));</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    /// @dev Get the pool&#39;s balance of token1</span>
 149 |     | <span class='neutral'>    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize</span>
 150 |     | <span class='neutral'>    /// check</span>
 151 | *   | <span class='executed'>    function balance1() private view returns (uint256) {</span>
 152 | *   | <span class='executed'>        (bool success, bytes memory data) = token1.staticcall(</span>
 153 | *   | <span class='executed'>            abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this))</span>
 154 |     | <span class='neutral'>        );</span>
 155 |     | <span class='neutral'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 156 |     | <span class='neutral'>        return abi.decode(data, (uint256));</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolDerivedState</span>
 160 |     | <span class='unexecuted'>    function snapshotCumulativesInside(</span>
 161 |     | <span class='neutral'>        int24 tickLower,</span>
 162 |     | <span class='neutral'>        int24 tickUpper</span>
 163 |     | <span class='neutral'>    )</span>
 164 |     | <span class='neutral'>        external</span>
 165 |     | <span class='neutral'>        view</span>
 166 |     | <span class='neutral'>        override</span>
 167 |     | <span class='neutral'>        noDelegateCall</span>
 168 |     | <span class='unexecuted'>        returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside)</span>
 169 |     | <span class='neutral'>    {</span>
 170 |     | <span class='unexecuted'>        checkTicks(tickLower, tickUpper);</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='unexecuted'>        int56 tickCumulativeLower;</span>
 173 |     | <span class='neutral'>        int56 tickCumulativeUpper;</span>
 174 |     | <span class='neutral'>        uint160 secondsPerLiquidityOutsideLowerX128;</span>
 175 |     | <span class='neutral'>        uint160 secondsPerLiquidityOutsideUpperX128;</span>
 176 |     | <span class='neutral'>        uint32 secondsOutsideLower;</span>
 177 |     | <span class='neutral'>        uint32 secondsOutsideUpper;</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>        {</span>
 180 |     | <span class='unexecuted'>            Tick.Info storage lower = ticks[tickLower];</span>
 181 |     | <span class='unexecuted'>            Tick.Info storage upper = ticks[tickUpper];</span>
 182 |     | <span class='neutral'>            bool initializedLower;</span>
 183 |     | <span class='neutral'>            (tickCumulativeLower, secondsPerLiquidityOutsideLowerX128, secondsOutsideLower, initializedLower) = (</span>
 184 |     | <span class='unexecuted'>                lower.tickCumulativeOutside,</span>
 185 |     | <span class='unexecuted'>                lower.secondsPerLiquidityOutsideX128,</span>
 186 |     | <span class='unexecuted'>                lower.secondsOutside,</span>
 187 |     | <span class='unexecuted'>                lower.initialized</span>
 188 |     | <span class='neutral'>            );</span>
 189 |     | <span class='unexecuted'>            require(initializedLower);</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>            bool initializedUpper;</span>
 192 |     | <span class='neutral'>            (tickCumulativeUpper, secondsPerLiquidityOutsideUpperX128, secondsOutsideUpper, initializedUpper) = (</span>
 193 |     | <span class='unexecuted'>                upper.tickCumulativeOutside,</span>
 194 |     | <span class='unexecuted'>                upper.secondsPerLiquidityOutsideX128,</span>
 195 |     | <span class='unexecuted'>                upper.secondsOutside,</span>
 196 |     | <span class='unexecuted'>                upper.initialized</span>
 197 |     | <span class='neutral'>            );</span>
 198 |     | <span class='unexecuted'>            require(initializedUpper);</span>
 199 |     | <span class='neutral'>        }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='unexecuted'>        Slot0 memory _slot0 = slot0;</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='unexecuted'>        if (_slot0.tick &lt; tickLower) {</span>
 204 |     | <span class='unexecuted'>            return (</span>
 205 |     | <span class='unexecuted'>                tickCumulativeLower - tickCumulativeUpper,</span>
 206 |     | <span class='unexecuted'>                secondsPerLiquidityOutsideLowerX128 - secondsPerLiquidityOutsideUpperX128,</span>
 207 |     | <span class='unexecuted'>                secondsOutsideLower - secondsOutsideUpper</span>
 208 |     | <span class='neutral'>            );</span>
 209 |     | <span class='unexecuted'>        } else if (_slot0.tick &lt; tickUpper) {</span>
 210 |     | <span class='unexecuted'>            uint32 time = _blockTimestamp();</span>
 211 |     | <span class='unexecuted'>            (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) = observations.observeSingle(</span>
 212 |     | <span class='neutral'>                time,</span>
 213 |     | <span class='neutral'>                0,</span>
 214 |     | <span class='unexecuted'>                _slot0.tick,</span>
 215 |     | <span class='unexecuted'>                _slot0.observationIndex,</span>
 216 |     | <span class='unexecuted'>                liquidity,</span>
 217 |     | <span class='unexecuted'>                _slot0.observationCardinality</span>
 218 |     | <span class='neutral'>            );</span>
 219 |     | <span class='unexecuted'>            return (</span>
 220 |     | <span class='unexecuted'>                tickCumulative - tickCumulativeLower - tickCumulativeUpper,</span>
 221 |     | <span class='unexecuted'>                secondsPerLiquidityCumulativeX128 -</span>
 222 |     | <span class='neutral'>                    secondsPerLiquidityOutsideLowerX128 -</span>
 223 |     | <span class='neutral'>                    secondsPerLiquidityOutsideUpperX128,</span>
 224 |     | <span class='unexecuted'>                time - secondsOutsideLower - secondsOutsideUpper</span>
 225 |     | <span class='neutral'>            );</span>
 226 |     | <span class='neutral'>        } else {</span>
 227 |     | <span class='neutral'>            return (</span>
 228 |     | <span class='unexecuted'>                tickCumulativeUpper - tickCumulativeLower,</span>
 229 |     | <span class='unexecuted'>                secondsPerLiquidityOutsideUpperX128 - secondsPerLiquidityOutsideLowerX128,</span>
 230 |     | <span class='unexecuted'>                secondsOutsideUpper - secondsOutsideLower</span>
 231 |     | <span class='neutral'>            );</span>
 232 |     | <span class='neutral'>        }</span>
 233 |     | <span class='neutral'>    }</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolDerivedState</span>
 236 |     | <span class='unexecuted'>    function observe(</span>
 237 |     | <span class='neutral'>        uint32[] calldata secondsAgos</span>
 238 |     | <span class='neutral'>    )</span>
 239 |     | <span class='neutral'>        external</span>
 240 |     | <span class='neutral'>        view</span>
 241 |     | <span class='neutral'>        override</span>
 242 |     | <span class='neutral'>        noDelegateCall</span>
 243 |     | <span class='unexecuted'>        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s)</span>
 244 |     | <span class='neutral'>    {</span>
 245 |     | <span class='unexecuted'>        return</span>
 246 |     | <span class='unexecuted'>            observations.observe(</span>
 247 |     | <span class='unexecuted'>                _blockTimestamp(),</span>
 248 |     | <span class='unexecuted'>                secondsAgos,</span>
 249 |     | <span class='unexecuted'>                slot0.tick,</span>
 250 |     | <span class='unexecuted'>                slot0.observationIndex,</span>
 251 |     | <span class='unexecuted'>                liquidity,</span>
 252 |     | <span class='unexecuted'>                slot0.observationCardinality</span>
 253 |     | <span class='neutral'>            );</span>
 254 |     | <span class='neutral'>    }</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolActions</span>
 257 |     | <span class='unexecuted'>    function increaseObservationCardinalityNext(</span>
 258 |     | <span class='neutral'>        uint16 observationCardinalityNext</span>
 259 |     | <span class='neutral'>    ) external override lock noDelegateCall {</span>
 260 |     | <span class='unexecuted'>        uint16 observationCardinalityNextOld = slot0.observationCardinalityNext; // for the event</span>
 261 |     | <span class='unexecuted'>        uint16 observationCardinalityNextNew = observations.grow(</span>
 262 |     | <span class='neutral'>            observationCardinalityNextOld,</span>
 263 |     | <span class='unexecuted'>            observationCardinalityNext</span>
 264 |     | <span class='neutral'>        );</span>
 265 |     | <span class='unexecuted'>        slot0.observationCardinalityNext = observationCardinalityNextNew;</span>
 266 |     | <span class='unexecuted'>        if (observationCardinalityNextOld != observationCardinalityNextNew)</span>
 267 |     | <span class='unexecuted'>            emit IncreaseObservationCardinalityNext(observationCardinalityNextOld, observationCardinalityNextNew);</span>
 268 |     | <span class='neutral'>    }</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolActions</span>
 271 |     | <span class='neutral'>    /// @dev not locked because it initializes unlocked</span>
 272 | *   | <span class='executed'>    function initialize(uint160 sqrtPriceX96) external override {</span>
 273 | *   | <span class='executed'>        require(slot0.sqrtPriceX96 == 0, &#39;AI&#39;);</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='unexecuted'>        int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='unexecuted'>        (uint16 cardinality, uint16 cardinalityNext) = observations.initialize(_blockTimestamp());</span>
 278 |     | <span class='neutral'></span>
 279 | *   | <span class='executed'>        slot0 = Slot0({</span>
 280 |     | <span class='neutral'>            sqrtPriceX96: sqrtPriceX96,</span>
 281 |     | <span class='neutral'>            tick: tick,</span>
 282 |     | <span class='neutral'>            observationIndex: 0,</span>
 283 |     | <span class='neutral'>            observationCardinality: cardinality,</span>
 284 |     | <span class='neutral'>            observationCardinalityNext: cardinalityNext,</span>
 285 |     | <span class='neutral'>            feeProtocol: 0,</span>
 286 |     | <span class='neutral'>            unlocked: true</span>
 287 |     | <span class='neutral'>        });</span>
 288 |     | <span class='neutral'></span>
 289 | *   | <span class='executed'>        emit Initialize(sqrtPriceX96, tick);</span>
 290 |     | <span class='neutral'>    }</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>    struct ModifyPositionParams {</span>
 293 |     | <span class='neutral'>        // the address that owns the position</span>
 294 |     | <span class='neutral'>        address owner;</span>
 295 |     | <span class='neutral'>        // the lower and upper tick of the position</span>
 296 |     | <span class='neutral'>        int24 tickLower;</span>
 297 |     | <span class='neutral'>        int24 tickUpper;</span>
 298 |     | <span class='neutral'>        // any change in liquidity</span>
 299 |     | <span class='neutral'>        int128 liquidityDelta;</span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>    /// @dev Effect some changes to a position</span>
 303 |     | <span class='neutral'>    /// @param params the position details and the change to the position&#39;s liquidity to effect</span>
 304 |     | <span class='neutral'>    /// @return position a storage pointer referencing the position with the given owner and tick range</span>
 305 |     | <span class='neutral'>    /// @return amount0 the amount of token0 owed to the pool, negative if the pool should pay the recipient</span>
 306 |     | <span class='neutral'>    /// @return amount1 the amount of token1 owed to the pool, negative if the pool should pay the recipient</span>
 307 | *   | <span class='executed'>    function _modifyPosition(</span>
 308 |     | <span class='neutral'>        ModifyPositionParams memory params</span>
 309 |     | <span class='unexecuted'>    ) private noDelegateCall returns (Position.Info storage position, int256 amount0, int256 amount1) {</span>
 310 | *   | <span class='executed'>        checkTicks(params.tickLower, params.tickUpper);</span>
 311 |     | <span class='neutral'></span>
 312 | *   | <span class='executed'>        Slot0 memory _slot0 = slot0; // SLOAD for gas optimization</span>
 313 |     | <span class='neutral'></span>
 314 | *   | <span class='executed'>        position = _updatePosition(</span>
 315 | *   | <span class='executed'>            params.owner,</span>
 316 | *   | <span class='executed'>            params.tickLower,</span>
 317 | *   | <span class='executed'>            params.tickUpper,</span>
 318 | *   | <span class='executed'>            params.liquidityDelta,</span>
 319 |     | <span class='neutral'>            _slot0.tick</span>
 320 |     | <span class='neutral'>        );</span>
 321 |     | <span class='neutral'></span>
 322 | *   | <span class='executed'>        if (params.liquidityDelta != 0) {</span>
 323 | *   | <span class='executed'>            if (_slot0.tick &lt; params.tickLower) {</span>
 324 |     | <span class='neutral'>                // current tick is below the passed range; liquidity can only become in range by crossing from left to</span>
 325 |     | <span class='neutral'>                // right, when we&#39;ll need _more_ token0 (it&#39;s becoming more valuable) so user must provide it</span>
 326 | *   | <span class='executed'>                amount0 = SqrtPriceMath.getAmount0Delta(</span>
 327 | *   | <span class='executed'>                    TickMath.getSqrtRatioAtTick(params.tickLower),</span>
 328 | *   | <span class='executed'>                    TickMath.getSqrtRatioAtTick(params.tickUpper),</span>
 329 | *   | <span class='executed'>                    params.liquidityDelta</span>
 330 |     | <span class='neutral'>                );</span>
 331 | *   | <span class='executed'>            } else if (_slot0.tick &lt; params.tickUpper) {</span>
 332 |     | <span class='neutral'>                // current tick is inside the passed range</span>
 333 | *   | <span class='executed'>                uint128 liquidityBefore = liquidity; // SLOAD for gas optimization</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='neutral'>                // write an oracle entry</span>
 336 | *   | <span class='executed'>                (slot0.observationIndex, slot0.observationCardinality) = observations.write(</span>
 337 | *   | <span class='executed'>                    _slot0.observationIndex,</span>
 338 | *   | <span class='executed'>                    _blockTimestamp(),</span>
 339 | *   | <span class='executed'>                    _slot0.tick,</span>
 340 | *   | <span class='executed'>                    liquidityBefore,</span>
 341 | *   | <span class='executed'>                    _slot0.observationCardinality,</span>
 342 | *   | <span class='executed'>                    _slot0.observationCardinalityNext</span>
 343 |     | <span class='neutral'>                );</span>
 344 |     | <span class='neutral'></span>
 345 | *   | <span class='executed'>                amount0 = SqrtPriceMath.getAmount0Delta(</span>
 346 | *   | <span class='executed'>                    _slot0.sqrtPriceX96,</span>
 347 | *   | <span class='executed'>                    TickMath.getSqrtRatioAtTick(params.tickUpper),</span>
 348 | *   | <span class='executed'>                    params.liquidityDelta</span>
 349 |     | <span class='neutral'>                );</span>
 350 | *   | <span class='executed'>                amount1 = SqrtPriceMath.getAmount1Delta(</span>
 351 | *   | <span class='executed'>                    TickMath.getSqrtRatioAtTick(params.tickLower),</span>
 352 | *   | <span class='executed'>                    _slot0.sqrtPriceX96,</span>
 353 | *   | <span class='executed'>                    params.liquidityDelta</span>
 354 |     | <span class='neutral'>                );</span>
 355 |     | <span class='neutral'></span>
 356 | *   | <span class='executed'>                liquidity = LiquidityMath.addDelta(liquidityBefore, params.liquidityDelta);</span>
 357 |     | <span class='neutral'>            } else {</span>
 358 |     | <span class='neutral'>                // current tick is above the passed range; liquidity can only become in range by crossing from right to</span>
 359 |     | <span class='neutral'>                // left, when we&#39;ll need _more_ token1 (it&#39;s becoming more valuable) so user must provide it</span>
 360 | *   | <span class='executed'>                amount1 = SqrtPriceMath.getAmount1Delta(</span>
 361 | *   | <span class='executed'>                    TickMath.getSqrtRatioAtTick(params.tickLower),</span>
 362 | *   | <span class='executed'>                    TickMath.getSqrtRatioAtTick(params.tickUpper),</span>
 363 | *   | <span class='executed'>                    params.liquidityDelta</span>
 364 |     | <span class='neutral'>                );</span>
 365 |     | <span class='neutral'>            }</span>
 366 |     | <span class='neutral'>        }</span>
 367 |     | <span class='neutral'>    }</span>
 368 |     | <span class='neutral'></span>
 369 |     | <span class='neutral'>    /// @dev Gets and updates a position with the given liquidity delta</span>
 370 |     | <span class='neutral'>    /// @param owner the owner of the position</span>
 371 |     | <span class='neutral'>    /// @param tickLower the lower tick of the position&#39;s tick range</span>
 372 |     | <span class='neutral'>    /// @param tickUpper the upper tick of the position&#39;s tick range</span>
 373 |     | <span class='neutral'>    /// @param tick the current tick, passed to avoid sloads</span>
 374 | *   | <span class='executed'>    function _updatePosition(</span>
 375 |     | <span class='neutral'>        address owner,</span>
 376 |     | <span class='neutral'>        int24 tickLower,</span>
 377 |     | <span class='neutral'>        int24 tickUpper,</span>
 378 |     | <span class='neutral'>        int128 liquidityDelta,</span>
 379 |     | <span class='neutral'>        int24 tick</span>
 380 |     | <span class='unexecuted'>    ) private returns (Position.Info storage position) {</span>
 381 |     | <span class='unexecuted'>        position = positions.get(owner, tickLower, tickUpper);</span>
 382 |     | <span class='neutral'></span>
 383 |     | <span class='unexecuted'>        uint256 _feeGrowthGlobal0X128 = feeGrowthGlobal0X128; // SLOAD for gas optimization</span>
 384 |     | <span class='unexecuted'>        uint256 _feeGrowthGlobal1X128 = feeGrowthGlobal1X128; // SLOAD for gas optimization</span>
 385 |     | <span class='neutral'></span>
 386 |     | <span class='neutral'>        // if we need to update the ticks, do it</span>
 387 |     | <span class='neutral'>        bool flippedLower;</span>
 388 |     | <span class='neutral'>        bool flippedUpper;</span>
 389 | *   | <span class='executed'>        if (liquidityDelta != 0) {</span>
 390 | *   | <span class='executed'>            uint32 time = _blockTimestamp();</span>
 391 | *   | <span class='executed'>            (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) = observations.observeSingle(</span>
 392 |     | <span class='neutral'>                time,</span>
 393 |     | <span class='neutral'>                0,</span>
 394 | *   | <span class='executed'>                slot0.tick,</span>
 395 | *   | <span class='executed'>                slot0.observationIndex,</span>
 396 | *   | <span class='executed'>                liquidity,</span>
 397 | *   | <span class='executed'>                slot0.observationCardinality</span>
 398 |     | <span class='neutral'>            );</span>
 399 |     | <span class='neutral'></span>
 400 | *   | <span class='executed'>            flippedLower = ticks.update(</span>
 401 | *   | <span class='executed'>                tickLower,</span>
 402 | *   | <span class='executed'>                tick,</span>
 403 | *   | <span class='executed'>                liquidityDelta,</span>
 404 | *   | <span class='executed'>                _feeGrowthGlobal0X128,</span>
 405 | *   | <span class='executed'>                _feeGrowthGlobal1X128,</span>
 406 |     | <span class='neutral'>                secondsPerLiquidityCumulativeX128,</span>
 407 |     | <span class='neutral'>                tickCumulative,</span>
 408 | *   | <span class='executed'>                time,</span>
 409 | *   | <span class='executed'>                false,</span>
 410 | *   | <span class='executed'>                maxLiquidityPerTick</span>
 411 |     | <span class='neutral'>            );</span>
 412 | *   | <span class='executed'>            flippedUpper = ticks.update(</span>
 413 | *   | <span class='executed'>                tickUpper,</span>
 414 | *   | <span class='executed'>                tick,</span>
 415 | *   | <span class='executed'>                liquidityDelta,</span>
 416 | *   | <span class='executed'>                _feeGrowthGlobal0X128,</span>
 417 | *   | <span class='executed'>                _feeGrowthGlobal1X128,</span>
 418 | *   | <span class='executed'>                secondsPerLiquidityCumulativeX128,</span>
 419 | *   | <span class='executed'>                tickCumulative,</span>
 420 | *   | <span class='executed'>                time,</span>
 421 | *   | <span class='executed'>                true,</span>
 422 | *   | <span class='executed'>                maxLiquidityPerTick</span>
 423 |     | <span class='neutral'>            );</span>
 424 |     | <span class='neutral'></span>
 425 | *   | <span class='executed'>            if (flippedLower) {</span>
 426 | *   | <span class='executed'>                tickBitmap.flipTick(tickLower, tickSpacing);</span>
 427 |     | <span class='neutral'>            }</span>
 428 | *   | <span class='executed'>            if (flippedUpper) {</span>
 429 | *   | <span class='executed'>                tickBitmap.flipTick(tickUpper, tickSpacing);</span>
 430 |     | <span class='neutral'>            }</span>
 431 |     | <span class='neutral'>        }</span>
 432 |     | <span class='neutral'></span>
 433 | *   | <span class='executed'>        (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) = ticks.getFeeGrowthInside(</span>
 434 | *   | <span class='executed'>            tickLower,</span>
 435 | *   | <span class='executed'>            tickUpper,</span>
 436 | *   | <span class='executed'>            tick,</span>
 437 | *   | <span class='executed'>            _feeGrowthGlobal0X128,</span>
 438 | *   | <span class='executed'>            _feeGrowthGlobal1X128</span>
 439 |     | <span class='neutral'>        );</span>
 440 |     | <span class='neutral'></span>
 441 | *   | <span class='executed'>        position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);</span>
 442 |     | <span class='neutral'></span>
 443 |     | <span class='neutral'>        // clear any tick data that is no longer needed</span>
 444 | *   | <span class='executed'>        if (liquidityDelta &lt; 0) {</span>
 445 | *   | <span class='executed'>            if (flippedLower) {</span>
 446 | *   | <span class='executed'>                ticks.clear(tickLower);</span>
 447 |     | <span class='neutral'>            }</span>
 448 | *   | <span class='executed'>            if (flippedUpper) {</span>
 449 | *   | <span class='executed'>                ticks.clear(tickUpper);</span>
 450 |     | <span class='neutral'>            }</span>
 451 |     | <span class='neutral'>        }</span>
 452 |     | <span class='neutral'>    }</span>
 453 |     | <span class='neutral'></span>
 454 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolActions</span>
 455 |     | <span class='neutral'>    /// @dev noDelegateCall is applied indirectly via _modifyPosition</span>
 456 | *   | <span class='executed'>    function mint(</span>
 457 |     | <span class='neutral'>        address recipient,</span>
 458 |     | <span class='neutral'>        int24 tickLower,</span>
 459 |     | <span class='neutral'>        int24 tickUpper,</span>
 460 |     | <span class='neutral'>        uint128 amount,</span>
 461 |     | <span class='neutral'>        bytes calldata data</span>
 462 | *   | <span class='executed'>    ) external override lock returns (uint256 amount0, uint256 amount1) {</span>
 463 |     | <span class='unexecuted'>        require(amount &gt; 0);</span>
 464 | *   | <span class='executed'>        (, int256 amount0Int, int256 amount1Int) = _modifyPosition(</span>
 465 | *   | <span class='executed'>            ModifyPositionParams({</span>
 466 | *   | <span class='executed'>                owner: recipient,</span>
 467 | *   | <span class='executed'>                tickLower: tickLower,</span>
 468 | *   | <span class='executed'>                tickUpper: tickUpper,</span>
 469 | *   | <span class='executed'>                liquidityDelta: int256(amount).toInt128()</span>
 470 |     | <span class='neutral'>            })</span>
 471 |     | <span class='neutral'>        );</span>
 472 |     | <span class='neutral'></span>
 473 | *   | <span class='executed'>        amount0 = uint256(amount0Int);</span>
 474 | *   | <span class='executed'>        amount1 = uint256(amount1Int);</span>
 475 |     | <span class='neutral'></span>
 476 | *   | <span class='executed'>        uint256 balance0Before;</span>
 477 | *   | <span class='executed'>        uint256 balance1Before;</span>
 478 | *   | <span class='executed'>        if (amount0 &gt; 0) balance0Before = balance0();</span>
 479 | *   | <span class='executed'>        if (amount1 &gt; 0) balance1Before = balance1();</span>
 480 | *   | <span class='executed'>        IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(amount0, amount1, data);</span>
 481 | *   | <span class='executed'>        if (amount0 &gt; 0) require(balance0Before.add(amount0) &lt;= balance0(), &#39;M0&#39;);</span>
 482 | *   | <span class='executed'>        if (amount1 &gt; 0) require(balance1Before.add(amount1) &lt;= balance1(), &#39;M1&#39;);</span>
 483 |     | <span class='neutral'></span>
 484 | *   | <span class='executed'>        emit Mint(msg.sender, recipient, tickLower, tickUpper, amount, amount0, amount1);</span>
 485 |     | <span class='neutral'>    }</span>
 486 |     | <span class='neutral'></span>
 487 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolActions</span>
 488 |     | <span class='unexecuted'>    function collect(</span>
 489 |     | <span class='neutral'>        address recipient,</span>
 490 |     | <span class='neutral'>        int24 tickLower,</span>
 491 |     | <span class='neutral'>        int24 tickUpper,</span>
 492 |     | <span class='neutral'>        uint128 amount0Requested,</span>
 493 |     | <span class='neutral'>        uint128 amount1Requested</span>
 494 |     | <span class='unexecuted'>    ) external override lock returns (uint128 amount0, uint128 amount1) {</span>
 495 |     | <span class='neutral'>        // we don&#39;t need to checkTicks here, because invalid positions will never have non-zero tokensOwed{0,1}</span>
 496 |     | <span class='unexecuted'>        Position.Info storage position = positions.get(msg.sender, tickLower, tickUpper);</span>
 497 |     | <span class='neutral'></span>
 498 |     | <span class='unexecuted'>        amount0 = amount0Requested &gt; position.tokensOwed0 ? position.tokensOwed0 : amount0Requested;</span>
 499 |     | <span class='unexecuted'>        amount1 = amount1Requested &gt; position.tokensOwed1 ? position.tokensOwed1 : amount1Requested;</span>
 500 |     | <span class='neutral'></span>
 501 |     | <span class='unexecuted'>        if (amount0 &gt; 0) {</span>
 502 |     | <span class='unexecuted'>            position.tokensOwed0 -= amount0;</span>
 503 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(token0, recipient, amount0);</span>
 504 |     | <span class='neutral'>        }</span>
 505 |     | <span class='unexecuted'>        if (amount1 &gt; 0) {</span>
 506 |     | <span class='unexecuted'>            position.tokensOwed1 -= amount1;</span>
 507 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(token1, recipient, amount1);</span>
 508 |     | <span class='neutral'>        }</span>
 509 |     | <span class='neutral'></span>
 510 |     | <span class='unexecuted'>        emit Collect(msg.sender, recipient, tickLower, tickUpper, amount0, amount1);</span>
 511 |     | <span class='neutral'>    }</span>
 512 |     | <span class='neutral'></span>
 513 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolActions</span>
 514 |     | <span class='neutral'>    /// @dev noDelegateCall is applied indirectly via _modifyPosition</span>
 515 |     | <span class='unexecuted'>    function burn(</span>
 516 |     | <span class='neutral'>        int24 tickLower,</span>
 517 |     | <span class='neutral'>        int24 tickUpper,</span>
 518 |     | <span class='neutral'>        uint128 amount</span>
 519 |     | <span class='unexecuted'>    ) external override lock returns (uint256 amount0, uint256 amount1) {</span>
 520 |     | <span class='unexecuted'>        (Position.Info storage position, int256 amount0Int, int256 amount1Int) = _modifyPosition(</span>
 521 |     | <span class='unexecuted'>            ModifyPositionParams({</span>
 522 |     | <span class='unexecuted'>                owner: msg.sender,</span>
 523 |     | <span class='neutral'>                tickLower: tickLower,</span>
 524 |     | <span class='neutral'>                tickUpper: tickUpper,</span>
 525 |     | <span class='unexecuted'>                liquidityDelta: -int256(amount).toInt128()</span>
 526 |     | <span class='neutral'>            })</span>
 527 |     | <span class='neutral'>        );</span>
 528 |     | <span class='neutral'></span>
 529 |     | <span class='unexecuted'>        amount0 = uint256(-amount0Int);</span>
 530 |     | <span class='unexecuted'>        amount1 = uint256(-amount1Int);</span>
 531 |     | <span class='neutral'></span>
 532 |     | <span class='unexecuted'>        if (amount0 &gt; 0 || amount1 &gt; 0) {</span>
 533 |     | <span class='unexecuted'>            (position.tokensOwed0, position.tokensOwed1) = (</span>
 534 |     | <span class='unexecuted'>                position.tokensOwed0 + uint128(amount0),</span>
 535 |     | <span class='unexecuted'>                position.tokensOwed1 + uint128(amount1)</span>
 536 |     | <span class='neutral'>            );</span>
 537 |     | <span class='neutral'>        }</span>
 538 |     | <span class='neutral'></span>
 539 |     | <span class='unexecuted'>        emit Burn(msg.sender, tickLower, tickUpper, amount, amount0, amount1);</span>
 540 |     | <span class='neutral'>    }</span>
 541 |     | <span class='neutral'></span>
 542 |     | <span class='neutral'>    struct SwapCache {</span>
 543 |     | <span class='neutral'>        // the protocol fee for the input token</span>
 544 |     | <span class='neutral'>        uint8 feeProtocol;</span>
 545 |     | <span class='neutral'>        // liquidity at the beginning of the swap</span>
 546 |     | <span class='neutral'>        uint128 liquidityStart;</span>
 547 |     | <span class='neutral'>        // the timestamp of the current block</span>
 548 |     | <span class='neutral'>        uint32 blockTimestamp;</span>
 549 |     | <span class='neutral'>        // the current value of the tick accumulator, computed only if we cross an initialized tick</span>
 550 |     | <span class='neutral'>        int56 tickCumulative;</span>
 551 |     | <span class='neutral'>        // the current value of seconds per liquidity accumulator, computed only if we cross an initialized tick</span>
 552 |     | <span class='neutral'>        uint160 secondsPerLiquidityCumulativeX128;</span>
 553 |     | <span class='neutral'>        // whether we&#39;ve computed and cached the above two accumulators</span>
 554 |     | <span class='neutral'>        bool computedLatestObservation;</span>
 555 |     | <span class='neutral'>    }</span>
 556 |     | <span class='neutral'></span>
 557 |     | <span class='neutral'>    // the top level state of the swap, the results of which are recorded in storage at the end</span>
 558 |     | <span class='neutral'>    struct SwapState {</span>
 559 |     | <span class='neutral'>        // the amount remaining to be swapped in/out of the input/output asset</span>
 560 |     | <span class='neutral'>        int256 amountSpecifiedRemaining;</span>
 561 |     | <span class='neutral'>        // the amount already swapped out/in of the output/input asset</span>
 562 |     | <span class='neutral'>        int256 amountCalculated;</span>
 563 |     | <span class='neutral'>        // current sqrt(price)</span>
 564 |     | <span class='neutral'>        uint160 sqrtPriceX96;</span>
 565 |     | <span class='neutral'>        // the tick associated with the current price</span>
 566 |     | <span class='neutral'>        int24 tick;</span>
 567 |     | <span class='neutral'>        // the global fee growth of the input token</span>
 568 |     | <span class='neutral'>        uint256 feeGrowthGlobalX128;</span>
 569 |     | <span class='neutral'>        // amount of input token paid as protocol fee</span>
 570 |     | <span class='neutral'>        uint128 protocolFee;</span>
 571 |     | <span class='neutral'>        // the current liquidity in range</span>
 572 |     | <span class='neutral'>        uint128 liquidity;</span>
 573 |     | <span class='neutral'>    }</span>
 574 |     | <span class='neutral'></span>
 575 |     | <span class='neutral'>    struct StepComputations {</span>
 576 |     | <span class='neutral'>        // the price at the beginning of the step</span>
 577 |     | <span class='neutral'>        uint160 sqrtPriceStartX96;</span>
 578 |     | <span class='neutral'>        // the next tick to swap to from the current tick in the swap direction</span>
 579 |     | <span class='neutral'>        int24 tickNext;</span>
 580 |     | <span class='neutral'>        // whether tickNext is initialized or not</span>
 581 |     | <span class='neutral'>        bool initialized;</span>
 582 |     | <span class='neutral'>        // sqrt(price) for the next tick (1/0)</span>
 583 |     | <span class='neutral'>        uint160 sqrtPriceNextX96;</span>
 584 |     | <span class='neutral'>        // how much is being swapped in in this step</span>
 585 |     | <span class='neutral'>        uint256 amountIn;</span>
 586 |     | <span class='neutral'>        // how much is being swapped out</span>
 587 |     | <span class='neutral'>        uint256 amountOut;</span>
 588 |     | <span class='neutral'>        // how much fee is being paid in</span>
 589 |     | <span class='neutral'>        uint256 feeAmount;</span>
 590 |     | <span class='neutral'>    }</span>
 591 |     | <span class='neutral'></span>
 592 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolActions</span>
 593 | *   | <span class='executed'>    function swap(</span>
 594 |     | <span class='neutral'>        address recipient,</span>
 595 |     | <span class='neutral'>        bool zeroForOne,</span>
 596 |     | <span class='neutral'>        int256 amountSpecified,</span>
 597 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96,</span>
 598 |     | <span class='neutral'>        bytes calldata data</span>
 599 |     | <span class='unexecuted'>    ) external override noDelegateCall returns (int256 amount0, int256 amount1) {</span>
 600 | *   | <span class='executed'>        require(amountSpecified != 0, &#39;AS&#39;);</span>
 601 |     | <span class='neutral'></span>
 602 | *   | <span class='executed'>        Slot0 memory slot0Start = slot0;</span>
 603 |     | <span class='neutral'></span>
 604 | *   | <span class='executed'>        require(slot0Start.unlocked, &#39;LOK&#39;);</span>
 605 | *   | <span class='executed'>        require(</span>
 606 | *   | <span class='executed'>            zeroForOne</span>
 607 | *   | <span class='executed'>                ? sqrtPriceLimitX96 &lt; slot0Start.sqrtPriceX96 &amp;&amp; sqrtPriceLimitX96 &gt; TickMath.MIN_SQRT_RATIO</span>
 608 | *   | <span class='executed'>                : sqrtPriceLimitX96 &gt; slot0Start.sqrtPriceX96 &amp;&amp; sqrtPriceLimitX96 &lt; TickMath.MAX_SQRT_RATIO,</span>
 609 |     | <span class='neutral'>            &#39;SPL&#39;</span>
 610 |     | <span class='neutral'>        );</span>
 611 |     | <span class='neutral'></span>
 612 | *   | <span class='executed'>        slot0.unlocked = false;</span>
 613 |     | <span class='neutral'></span>
 614 | *   | <span class='executed'>        SwapCache memory cache = SwapCache({</span>
 615 | *   | <span class='executed'>            liquidityStart: liquidity,</span>
 616 | *   | <span class='executed'>            blockTimestamp: _blockTimestamp(),</span>
 617 | *   | <span class='executed'>            feeProtocol: zeroForOne ? (slot0Start.feeProtocol % 16) : (slot0Start.feeProtocol &gt;&gt; 4),</span>
 618 |     | <span class='neutral'>            secondsPerLiquidityCumulativeX128: 0,</span>
 619 | *   | <span class='executed'>            tickCumulative: 0,</span>
 620 |     | <span class='neutral'>            computedLatestObservation: false</span>
 621 |     | <span class='neutral'>        });</span>
 622 |     | <span class='neutral'></span>
 623 | *   | <span class='executed'>        bool exactInput = amountSpecified &gt; 0;</span>
 624 |     | <span class='neutral'></span>
 625 | *   | <span class='executed'>        SwapState memory state = SwapState({</span>
 626 |     | <span class='neutral'>            amountSpecifiedRemaining: amountSpecified,</span>
 627 |     | <span class='neutral'>            amountCalculated: 0,</span>
 628 | *   | <span class='executed'>            sqrtPriceX96: slot0Start.sqrtPriceX96,</span>
 629 | *   | <span class='executed'>            tick: slot0Start.tick,</span>
 630 | *   | <span class='executed'>            feeGrowthGlobalX128: zeroForOne ? feeGrowthGlobal0X128 : feeGrowthGlobal1X128,</span>
 631 | *   | <span class='executed'>            protocolFee: 0,</span>
 632 | *   | <span class='executed'>            liquidity: cache.liquidityStart</span>
 633 |     | <span class='neutral'>        });</span>
 634 |     | <span class='neutral'></span>
 635 |     | <span class='neutral'>        // continue swapping as long as we haven&#39;t used the entire input/output and haven&#39;t reached the price limit</span>
 636 | *   | <span class='executed'>        while (state.amountSpecifiedRemaining != 0 &amp;&amp; state.sqrtPriceX96 != sqrtPriceLimitX96) {</span>
 637 | *   | <span class='executed'>            StepComputations memory step;</span>
 638 |     | <span class='neutral'></span>
 639 | *   | <span class='executed'>            step.sqrtPriceStartX96 = state.sqrtPriceX96;</span>
 640 |     | <span class='neutral'></span>
 641 | *   | <span class='executed'>            (step.tickNext, step.initialized) = tickBitmap.nextInitializedTickWithinOneWord(</span>
 642 | *   | <span class='executed'>                state.tick,</span>
 643 | *   | <span class='executed'>                tickSpacing,</span>
 644 | *   | <span class='executed'>                zeroForOne</span>
 645 |     | <span class='neutral'>            );</span>
 646 |     | <span class='neutral'></span>
 647 |     | <span class='neutral'>            // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds</span>
 648 | *   | <span class='executed'>            if (step.tickNext &lt; TickMath.MIN_TICK) {</span>
 649 | *   | <span class='executed'>                step.tickNext = TickMath.MIN_TICK;</span>
 650 | *   | <span class='executed'>            } else if (step.tickNext &gt; TickMath.MAX_TICK) {</span>
 651 | *   | <span class='executed'>                step.tickNext = TickMath.MAX_TICK;</span>
 652 |     | <span class='neutral'>            }</span>
 653 |     | <span class='neutral'></span>
 654 |     | <span class='neutral'>            // get the price for the next tick</span>
 655 | *   | <span class='executed'>            step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);</span>
 656 |     | <span class='neutral'></span>
 657 |     | <span class='neutral'>            // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted</span>
 658 | *   | <span class='executed'>            (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(</span>
 659 | *   | <span class='executed'>                state.sqrtPriceX96,</span>
 660 | *   | <span class='executed'>                (zeroForOne ? step.sqrtPriceNextX96 &lt; sqrtPriceLimitX96 : step.sqrtPriceNextX96 &gt; sqrtPriceLimitX96)</span>
 661 | *   | <span class='executed'>                    ? sqrtPriceLimitX96</span>
 662 | *   | <span class='executed'>                    : step.sqrtPriceNextX96,</span>
 663 | *   | <span class='executed'>                state.liquidity,</span>
 664 | *   | <span class='executed'>                state.amountSpecifiedRemaining,</span>
 665 | *   | <span class='executed'>                fee</span>
 666 |     | <span class='neutral'>            );</span>
 667 |     | <span class='neutral'></span>
 668 | *   | <span class='executed'>            if (exactInput) {</span>
 669 | *   | <span class='executed'>                state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();</span>
 670 | *   | <span class='executed'>                state.amountCalculated = state.amountCalculated.sub(step.amountOut.toInt256());</span>
 671 |     | <span class='neutral'>            } else {</span>
 672 | *   | <span class='executed'>                state.amountSpecifiedRemaining += step.amountOut.toInt256();</span>
 673 | *   | <span class='executed'>                state.amountCalculated = state.amountCalculated.add((step.amountIn + step.feeAmount).toInt256());</span>
 674 |     | <span class='neutral'>            }</span>
 675 |     | <span class='neutral'></span>
 676 |     | <span class='neutral'>            // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee</span>
 677 | *   | <span class='executed'>            if (cache.feeProtocol &gt; 0) {</span>
 678 | *   | <span class='executed'>                uint256 delta = step.feeAmount / cache.feeProtocol;</span>
 679 | *   | <span class='executed'>                step.feeAmount -= delta;</span>
 680 |     | <span class='unexecuted'>                state.protocolFee += uint128(delta);</span>
 681 |     | <span class='neutral'>            }</span>
 682 |     | <span class='neutral'></span>
 683 |     | <span class='neutral'>            // update global fee tracker</span>
 684 | *   | <span class='executed'>            if (state.liquidity &gt; 0)</span>
 685 | *   | <span class='executed'>                state.feeGrowthGlobalX128 += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);</span>
 686 |     | <span class='neutral'></span>
 687 |     | <span class='neutral'>            // shift tick if we reached the next price</span>
 688 | *   | <span class='executed'>            if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {</span>
 689 |     | <span class='neutral'>                // if the tick is initialized, run the tick transition</span>
 690 | *   | <span class='executed'>                if (step.initialized) {</span>
 691 |     | <span class='neutral'>                    // check for the placeholder value, which we replace with the actual value the first time the swap</span>
 692 |     | <span class='neutral'>                    // crosses an initialized tick</span>
 693 | *   | <span class='executed'>                    if (!cache.computedLatestObservation) {</span>
 694 | *   | <span class='executed'>                        (cache.tickCumulative, cache.secondsPerLiquidityCumulativeX128) = observations.observeSingle(</span>
 695 | *   | <span class='executed'>                            cache.blockTimestamp,</span>
 696 | *   | <span class='executed'>                            0,</span>
 697 | *   | <span class='executed'>                            slot0Start.tick,</span>
 698 | *   | <span class='executed'>                            slot0Start.observationIndex,</span>
 699 | *   | <span class='executed'>                            cache.liquidityStart,</span>
 700 | *   | <span class='executed'>                            slot0Start.observationCardinality</span>
 701 |     | <span class='neutral'>                        );</span>
 702 | *   | <span class='executed'>                        cache.computedLatestObservation = true;</span>
 703 |     | <span class='neutral'>                    }</span>
 704 | *   | <span class='executed'>                    int128 liquidityNet = ticks.cross(</span>
 705 | *   | <span class='executed'>                        step.tickNext,</span>
 706 | *   | <span class='executed'>                        (zeroForOne ? state.feeGrowthGlobalX128 : feeGrowthGlobal0X128),</span>
 707 | *   | <span class='executed'>                        (zeroForOne ? feeGrowthGlobal1X128 : state.feeGrowthGlobalX128),</span>
 708 | *   | <span class='executed'>                        cache.secondsPerLiquidityCumulativeX128,</span>
 709 | *   | <span class='executed'>                        cache.tickCumulative,</span>
 710 | *   | <span class='executed'>                        cache.blockTimestamp</span>
 711 |     | <span class='neutral'>                    );</span>
 712 |     | <span class='neutral'>                    // if we&#39;re moving leftward, we interpret liquidityNet as the opposite sign</span>
 713 |     | <span class='neutral'>                    // safe because liquidityNet cannot be type(int128).min</span>
 714 | *   | <span class='executed'>                    if (zeroForOne) liquidityNet = -liquidityNet;</span>
 715 |     | <span class='neutral'></span>
 716 | *   | <span class='executed'>                    state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);</span>
 717 |     | <span class='neutral'>                }</span>
 718 |     | <span class='neutral'></span>
 719 | *   | <span class='executed'>                state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;</span>
 720 | *   | <span class='executed'>            } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {</span>
 721 |     | <span class='neutral'>                // recompute unless we&#39;re on a lower tick boundary (i.e. already transitioned ticks), and haven&#39;t moved</span>
 722 | *   | <span class='executed'>                state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);</span>
 723 |     | <span class='neutral'>                // MUTATION</span>
 724 | *   | <span class='executed'>                state.liquidity = 0;</span>
 725 |     | <span class='neutral'>            }</span>
 726 |     | <span class='neutral'>        }</span>
 727 |     | <span class='neutral'></span>
 728 |     | <span class='neutral'>        // update tick and write an oracle entry if the tick change</span>
 729 | *   | <span class='executed'>        if (state.tick != slot0Start.tick) {</span>
 730 | *   | <span class='executed'>            (uint16 observationIndex, uint16 observationCardinality) = observations.write(</span>
 731 | *   | <span class='executed'>                slot0Start.observationIndex,</span>
 732 | *   | <span class='executed'>                cache.blockTimestamp,</span>
 733 | *   | <span class='executed'>                slot0Start.tick,</span>
 734 | *   | <span class='executed'>                cache.liquidityStart,</span>
 735 | *   | <span class='executed'>                slot0Start.observationCardinality,</span>
 736 | *   | <span class='executed'>                slot0Start.observationCardinalityNext</span>
 737 |     | <span class='neutral'>            );</span>
 738 | *   | <span class='executed'>            (slot0.sqrtPriceX96, slot0.tick, slot0.observationIndex, slot0.observationCardinality) = (</span>
 739 | *   | <span class='executed'>                state.sqrtPriceX96,</span>
 740 | *   | <span class='executed'>                state.tick,</span>
 741 |     | <span class='neutral'>                observationIndex,</span>
 742 |     | <span class='neutral'>                observationCardinality</span>
 743 |     | <span class='neutral'>            );</span>
 744 |     | <span class='neutral'>        } else {</span>
 745 |     | <span class='neutral'>            // otherwise just update the price</span>
 746 | *   | <span class='executed'>            slot0.sqrtPriceX96 = state.sqrtPriceX96;</span>
 747 |     | <span class='neutral'>        }</span>
 748 |     | <span class='neutral'></span>
 749 |     | <span class='neutral'>        // update liquidity if it changed</span>
 750 | *   | <span class='executed'>        if (cache.liquidityStart != state.liquidity) liquidity = state.liquidity;</span>
 751 |     | <span class='neutral'></span>
 752 |     | <span class='neutral'>        // update fee growth global and, if necessary, protocol fees</span>
 753 |     | <span class='neutral'>        // overflow is acceptable, protocol has to withdraw before it hits type(uint128).max fees</span>
 754 | *   | <span class='executed'>        if (zeroForOne) {</span>
 755 | *   | <span class='executed'>            feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;</span>
 756 | *   | <span class='executed'>            if (state.protocolFee &gt; 0) protocolFees.token0 += state.protocolFee;</span>
 757 |     | <span class='neutral'>        } else {</span>
 758 |     | <span class='unexecuted'>            feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;</span>
 759 | *   | <span class='executed'>            if (state.protocolFee &gt; 0) protocolFees.token1 += state.protocolFee;</span>
 760 |     | <span class='neutral'>        }</span>
 761 |     | <span class='neutral'></span>
 762 | *   | <span class='executed'>        (amount0, amount1) = zeroForOne == exactInput</span>
 763 | *   | <span class='executed'>            ? (amountSpecified - state.amountSpecifiedRemaining, state.amountCalculated)</span>
 764 |     | <span class='unexecuted'>            : (state.amountCalculated, amountSpecified - state.amountSpecifiedRemaining);</span>
 765 |     | <span class='neutral'></span>
 766 |     | <span class='neutral'>        // do the transfers and collect payment</span>
 767 | *   | <span class='executed'>        if (zeroForOne) {</span>
 768 | *   | <span class='executed'>            if (amount1 &lt; 0) TransferHelper.safeTransfer(token1, recipient, uint256(-amount1));</span>
 769 |     | <span class='neutral'></span>
 770 | *   | <span class='executed'>            uint256 balance0Before = balance0();</span>
 771 | *   | <span class='executed'>            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);</span>
 772 | *   | <span class='executed'>            require(balance0Before.add(uint256(amount0)) &lt;= balance0(), &#39;IIA&#39;);</span>
 773 |     | <span class='neutral'>        } else {</span>
 774 |     | <span class='unexecuted'>            if (amount0 &lt; 0) TransferHelper.safeTransfer(token0, recipient, uint256(-amount0));</span>
 775 |     | <span class='neutral'></span>
 776 |     | <span class='unexecuted'>            uint256 balance1Before = balance1();</span>
 777 | *   | <span class='executed'>            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);</span>
 778 |     | <span class='unexecuted'>            require(balance1Before.add(uint256(amount1)) &lt;= balance1(), &#39;IIA&#39;);</span>
 779 |     | <span class='neutral'>        }</span>
 780 |     | <span class='neutral'></span>
 781 | *   | <span class='executed'>        emit Swap(msg.sender, recipient, amount0, amount1, state.sqrtPriceX96, state.liquidity, state.tick);</span>
 782 | *   | <span class='executed'>        slot0.unlocked = true;</span>
 783 |     | <span class='neutral'>    }</span>
 784 |     | <span class='neutral'></span>
 785 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolActions</span>
 786 | *   | <span class='executed'>    function flash(</span>
 787 |     | <span class='neutral'>        address recipient,</span>
 788 |     | <span class='neutral'>        uint256 amount0,</span>
 789 |     | <span class='neutral'>        uint256 amount1,</span>
 790 |     | <span class='neutral'>        bytes calldata data</span>
 791 |     | <span class='neutral'>    ) external override lock noDelegateCall {</span>
 792 |     | <span class='unexecuted'>        uint128 _liquidity = liquidity;</span>
 793 |     | <span class='unexecuted'>        require(_liquidity &gt; 0, &#39;L&#39;);</span>
 794 |     | <span class='neutral'></span>
 795 |     | <span class='unexecuted'>        uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e6);</span>
 796 |     | <span class='unexecuted'>        uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e6);</span>
 797 |     | <span class='unexecuted'>        uint256 balance0Before = balance0();</span>
 798 |     | <span class='unexecuted'>        uint256 balance1Before = balance1();</span>
 799 |     | <span class='neutral'></span>
 800 |     | <span class='unexecuted'>        if (amount0 &gt; 0) TransferHelper.safeTransfer(token0, recipient, amount0);</span>
 801 |     | <span class='unexecuted'>        if (amount1 &gt; 0) TransferHelper.safeTransfer(token1, recipient, amount1);</span>
 802 |     | <span class='neutral'></span>
 803 |     | <span class='unexecuted'>        IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback(fee0, fee1, data);</span>
 804 |     | <span class='neutral'></span>
 805 |     | <span class='unexecuted'>        uint256 balance0After = balance0();</span>
 806 |     | <span class='unexecuted'>        uint256 balance1After = balance1();</span>
 807 |     | <span class='neutral'></span>
 808 |     | <span class='unexecuted'>        require(balance0Before.add(fee0) &lt;= balance0After, &#39;F0&#39;);</span>
 809 |     | <span class='unexecuted'>        require(balance1Before.add(fee1) &lt;= balance1After, &#39;F1&#39;);</span>
 810 |     | <span class='neutral'></span>
 811 |     | <span class='neutral'>        // sub is safe because we know balanceAfter is gt balanceBefore by at least fee</span>
 812 |     | <span class='unexecuted'>        uint256 paid0 = balance0After - balance0Before;</span>
 813 |     | <span class='unexecuted'>        uint256 paid1 = balance1After - balance1Before;</span>
 814 |     | <span class='neutral'></span>
 815 |     | <span class='unexecuted'>        if (paid0 &gt; 0) {</span>
 816 |     | <span class='unexecuted'>            uint8 feeProtocol0 = slot0.feeProtocol % 16;</span>
 817 |     | <span class='unexecuted'>            uint256 fees0 = feeProtocol0 == 0 ? 0 : paid0 / feeProtocol0;</span>
 818 |     | <span class='unexecuted'>            if (uint128(fees0) &gt; 0) protocolFees.token0 += uint128(fees0);</span>
 819 |     | <span class='unexecuted'>            feeGrowthGlobal0X128 += FullMath.mulDiv(paid0 - fees0, FixedPoint128.Q128, _liquidity);</span>
 820 |     | <span class='neutral'>        }</span>
 821 |     | <span class='unexecuted'>        if (paid1 &gt; 0) {</span>
 822 |     | <span class='unexecuted'>            uint8 feeProtocol1 = slot0.feeProtocol &gt;&gt; 4;</span>
 823 |     | <span class='unexecuted'>            uint256 fees1 = feeProtocol1 == 0 ? 0 : paid1 / feeProtocol1;</span>
 824 |     | <span class='unexecuted'>            if (uint128(fees1) &gt; 0) protocolFees.token1 += uint128(fees1);</span>
 825 |     | <span class='unexecuted'>            feeGrowthGlobal1X128 += FullMath.mulDiv(paid1 - fees1, FixedPoint128.Q128, _liquidity);</span>
 826 |     | <span class='neutral'>        }</span>
 827 |     | <span class='neutral'></span>
 828 |     | <span class='unexecuted'>        emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);</span>
 829 |     | <span class='neutral'>    }</span>
 830 |     | <span class='neutral'></span>
 831 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolOwnerActions</span>
 832 |     | <span class='unexecuted'>    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external override lock onlyFactoryOwner {</span>
 833 |     | <span class='unexecuted'>        require(</span>
 834 |     | <span class='unexecuted'>            (feeProtocol0 == 0 || (feeProtocol0 &gt;= 4 &amp;&amp; feeProtocol0 &lt;= 10)) &amp;&amp;</span>
 835 |     | <span class='unexecuted'>                (feeProtocol1 == 0 || (feeProtocol1 &gt;= 4 &amp;&amp; feeProtocol1 &lt;= 10))</span>
 836 |     | <span class='neutral'>        );</span>
 837 |     | <span class='unexecuted'>        uint8 feeProtocolOld = slot0.feeProtocol;</span>
 838 |     | <span class='unexecuted'>        slot0.feeProtocol = feeProtocol0 + (feeProtocol1 &lt;&lt; 4);</span>
 839 |     | <span class='unexecuted'>        emit SetFeeProtocol(feeProtocolOld % 16, feeProtocolOld &gt;&gt; 4, feeProtocol0, feeProtocol1);</span>
 840 |     | <span class='neutral'>    }</span>
 841 |     | <span class='neutral'></span>
 842 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolOwnerActions</span>
 843 |     | <span class='unexecuted'>    function collectProtocol(</span>
 844 |     | <span class='neutral'>        address recipient,</span>
 845 |     | <span class='neutral'>        uint128 amount0Requested,</span>
 846 |     | <span class='neutral'>        uint128 amount1Requested</span>
 847 |     | <span class='unexecuted'>    ) external override lock onlyFactoryOwner returns (uint128 amount0, uint128 amount1) {</span>
 848 |     | <span class='unexecuted'>        amount0 = amount0Requested &gt; protocolFees.token0 ? protocolFees.token0 : amount0Requested;</span>
 849 |     | <span class='unexecuted'>        amount1 = amount1Requested &gt; protocolFees.token1 ? protocolFees.token1 : amount1Requested;</span>
 850 |     | <span class='neutral'></span>
 851 |     | <span class='unexecuted'>        if (amount0 &gt; 0) {</span>
 852 |     | <span class='unexecuted'>            if (amount0 == protocolFees.token0) amount0--; // ensure that the slot is not cleared, for gas savings</span>
 853 |     | <span class='unexecuted'>            protocolFees.token0 -= amount0;</span>
 854 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(token0, recipient, amount0);</span>
 855 |     | <span class='neutral'>        }</span>
 856 |     | <span class='unexecuted'>        if (amount1 &gt; 0) {</span>
 857 |     | <span class='unexecuted'>            if (amount1 == protocolFees.token1) amount1--; // ensure that the slot is not cleared, for gas savings</span>
 858 |     | <span class='unexecuted'>            protocolFees.token1 -= amount1;</span>
 859 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(token1, recipient, amount1);</span>
 860 |     | <span class='neutral'>        }</span>
 861 |     | <span class='neutral'></span>
 862 |     | <span class='unexecuted'>        emit CollectProtocol(msg.sender, recipient, amount0, amount1);</span>
 863 |     | <span class='neutral'>    }</span>
 864 |     | <span class='neutral'>}</span>
 865 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/UniswapV3PoolDeployer.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity =0.7.6;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./interfaces/IUniswapV3PoolDeployer.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &#39;./UniswapV3Pool.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>contract UniswapV3PoolDeployer is IUniswapV3PoolDeployer {</span>
  9 |     | <span class='neutral'>    struct Parameters {</span>
 10 |     | <span class='neutral'>        address factory;</span>
 11 |     | <span class='neutral'>        address token0;</span>
 12 |     | <span class='neutral'>        address token1;</span>
 13 |     | <span class='neutral'>        uint24 fee;</span>
 14 |     | <span class='neutral'>        int24 tickSpacing;</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolDeployer</span>
 18 | *   | <span class='executed'>    Parameters public override parameters;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    /// @dev Deploys a pool with the given parameters by transiently setting the parameters storage slot and then</span>
 21 |     | <span class='neutral'>    /// clearing it after deploying the pool.</span>
 22 |     | <span class='neutral'>    /// @param factory The contract address of the Uniswap V3 factory</span>
 23 |     | <span class='neutral'>    /// @param token0 The first token of the pool by address sort order</span>
 24 |     | <span class='neutral'>    /// @param token1 The second token of the pool by address sort order</span>
 25 |     | <span class='neutral'>    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip</span>
 26 |     | <span class='neutral'>    /// @param tickSpacing The spacing between usable ticks</span>
 27 | *   | <span class='executed'>    function deploy(</span>
 28 |     | <span class='neutral'>        address factory,</span>
 29 |     | <span class='neutral'>        address token0,</span>
 30 |     | <span class='neutral'>        address token1,</span>
 31 |     | <span class='neutral'>        uint24 fee,</span>
 32 |     | <span class='neutral'>        int24 tickSpacing</span>
 33 |     | <span class='neutral'>    ) internal returns (address pool) {</span>
 34 | *   | <span class='executed'>        parameters = Parameters({factory: factory, token0: token0, token1: token1, fee: fee, tickSpacing: tickSpacing});</span>
 35 | *   | <span class='executed'>        pool = address(new UniswapV3Pool{salt: keccak256(abi.encode(token0, token1, fee))}());</span>
 36 | *   | <span class='executed'>        delete parameters;</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'>}</span>
 39 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/IERC20Minimal.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Minimal ERC20 interface for Uniswap</span>
  5 |     | <span class='neutral'>/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3</span>
  6 |     | <span class='neutral'>interface IERC20Minimal {</span>
  7 |     | <span class='neutral'>    /// @notice Returns the balance of a token</span>
  8 |     | <span class='neutral'>    /// @param account The account for which to look up the number of tokens it has, i.e. its balance</span>
  9 |     | <span class='neutral'>    /// @return The number of tokens held by the account</span>
 10 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /// @notice Transfers the amount of token from the `msg.sender` to the recipient</span>
 13 |     | <span class='neutral'>    /// @param recipient The account that will receive the amount transferred</span>
 14 |     | <span class='neutral'>    /// @param amount The number of tokens to send from the sender to the recipient</span>
 15 |     | <span class='neutral'>    /// @return Returns true for a successful transfer, false for an unsuccessful transfer</span>
 16 |     | <span class='neutral'>    function transfer(address recipient, uint256 amount) external returns (bool);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /// @notice Returns the current allowance given to a spender by an owner</span>
 19 |     | <span class='neutral'>    /// @param owner The account of the token owner</span>
 20 |     | <span class='neutral'>    /// @param spender The account of the token spender</span>
 21 |     | <span class='neutral'>    /// @return The current allowance granted by `owner` to `spender`</span>
 22 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`</span>
 25 |     | <span class='neutral'>    /// @param spender The account which will be allowed to spend a given amount of the owners tokens</span>
 26 |     | <span class='neutral'>    /// @param amount The amount of tokens allowed to be used by `spender`</span>
 27 |     | <span class='neutral'>    /// @return Returns true for a successful approval, false for unsuccessful</span>
 28 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`</span>
 31 |     | <span class='neutral'>    /// @param sender The account from which the transfer will be initiated</span>
 32 |     | <span class='neutral'>    /// @param recipient The recipient of the transfer</span>
 33 |     | <span class='neutral'>    /// @param amount The amount of the transfer</span>
 34 |     | <span class='neutral'>    /// @return Returns true for a successful transfer, false for unsuccessful</span>
 35 |     | <span class='neutral'>    function transferFrom(</span>
 36 |     | <span class='neutral'>        address sender,</span>
 37 |     | <span class='neutral'>        address recipient,</span>
 38 |     | <span class='neutral'>        uint256 amount</span>
 39 |     | <span class='neutral'>    ) external returns (bool);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.</span>
 42 |     | <span class='neutral'>    /// @param from The account from which the tokens were sent, i.e. the balance decreased</span>
 43 |     | <span class='neutral'>    /// @param to The account to which the tokens were sent, i.e. the balance increased</span>
 44 |     | <span class='neutral'>    /// @param value The amount of tokens that were transferred</span>
 45 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    /// @notice Event emitted when the approval amount for the spender of a given owner&#39;s tokens changes.</span>
 48 |     | <span class='neutral'>    /// @param owner The account that approved spending of its tokens</span>
 49 |     | <span class='neutral'>    /// @param spender The account for which the spending allowance was modified</span>
 50 |     | <span class='neutral'>    /// @param value The new allowance from the owner to the spender</span>
 51 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 52 |     | <span class='neutral'>}</span>
 53 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/IUniswapV3Factory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title The interface for the Uniswap V3 Factory</span>
  5 |     | <span class='neutral'>/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees</span>
  6 |     | <span class='neutral'>interface IUniswapV3Factory {</span>
  7 |     | <span class='neutral'>    /// @notice Emitted when the owner of the factory is changed</span>
  8 |     | <span class='neutral'>    /// @param oldOwner The owner before the owner was changed</span>
  9 |     | <span class='neutral'>    /// @param newOwner The owner after the owner was changed</span>
 10 |     | <span class='neutral'>    event OwnerChanged(address indexed oldOwner, address indexed newOwner);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /// @notice Emitted when a pool is created</span>
 13 |     | <span class='neutral'>    /// @param token0 The first token of the pool by address sort order</span>
 14 |     | <span class='neutral'>    /// @param token1 The second token of the pool by address sort order</span>
 15 |     | <span class='neutral'>    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip</span>
 16 |     | <span class='neutral'>    /// @param tickSpacing The minimum number of ticks between initialized ticks</span>
 17 |     | <span class='neutral'>    /// @param pool The address of the created pool</span>
 18 |     | <span class='neutral'>    event PoolCreated(</span>
 19 |     | <span class='neutral'>        address indexed token0,</span>
 20 |     | <span class='neutral'>        address indexed token1,</span>
 21 |     | <span class='neutral'>        uint24 indexed fee,</span>
 22 |     | <span class='neutral'>        int24 tickSpacing,</span>
 23 |     | <span class='neutral'>        address pool</span>
 24 |     | <span class='neutral'>    );</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory</span>
 27 |     | <span class='neutral'>    /// @param fee The enabled fee, denominated in hundredths of a bip</span>
 28 |     | <span class='neutral'>    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee</span>
 29 |     | <span class='neutral'>    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /// @notice Returns the current owner of the factory</span>
 32 |     | <span class='neutral'>    /// @dev Can be changed by the current owner via setOwner</span>
 33 |     | <span class='neutral'>    /// @return The address of the factory owner</span>
 34 |     | <span class='neutral'>    function owner() external view returns (address);</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled</span>
 37 |     | <span class='neutral'>    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context</span>
 38 |     | <span class='neutral'>    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee</span>
 39 |     | <span class='neutral'>    /// @return The tick spacing</span>
 40 |     | <span class='neutral'>    function feeAmountTickSpacing(uint24 fee) external view returns (int24);</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist</span>
 43 |     | <span class='neutral'>    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order</span>
 44 |     | <span class='neutral'>    /// @param tokenA The contract address of either token0 or token1</span>
 45 |     | <span class='neutral'>    /// @param tokenB The contract address of the other token</span>
 46 |     | <span class='neutral'>    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip</span>
 47 |     | <span class='neutral'>    /// @return pool The pool address</span>
 48 |     | <span class='neutral'>    function getPool(</span>
 49 |     | <span class='neutral'>        address tokenA,</span>
 50 |     | <span class='neutral'>        address tokenB,</span>
 51 |     | <span class='neutral'>        uint24 fee</span>
 52 |     | <span class='neutral'>    ) external view returns (address pool);</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    /// @notice Creates a pool for the given two tokens and fee</span>
 55 |     | <span class='neutral'>    /// @param tokenA One of the two tokens in the desired pool</span>
 56 |     | <span class='neutral'>    /// @param tokenB The other of the two tokens in the desired pool</span>
 57 |     | <span class='neutral'>    /// @param fee The desired fee for the pool</span>
 58 |     | <span class='neutral'>    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved</span>
 59 |     | <span class='neutral'>    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments</span>
 60 |     | <span class='neutral'>    /// are invalid.</span>
 61 |     | <span class='neutral'>    /// @return pool The address of the newly created pool</span>
 62 |     | <span class='neutral'>    function createPool(</span>
 63 |     | <span class='neutral'>        address tokenA,</span>
 64 |     | <span class='neutral'>        address tokenB,</span>
 65 |     | <span class='neutral'>        uint24 fee</span>
 66 |     | <span class='neutral'>    ) external returns (address pool);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    /// @notice Updates the owner of the factory</span>
 69 |     | <span class='neutral'>    /// @dev Must be called by the current owner</span>
 70 |     | <span class='neutral'>    /// @param _owner The new owner of the factory</span>
 71 |     | <span class='neutral'>    function setOwner(address _owner) external;</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='neutral'>    /// @notice Enables a fee amount with the given tickSpacing</span>
 74 |     | <span class='neutral'>    /// @dev Fee amounts may never be removed once enabled</span>
 75 |     | <span class='neutral'>    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)</span>
 76 |     | <span class='neutral'>    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount</span>
 77 |     | <span class='neutral'>    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;</span>
 78 |     | <span class='neutral'>}</span>
 79 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/IUniswapV3Pool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./pool/IUniswapV3PoolImmutables.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;./pool/IUniswapV3PoolState.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;./pool/IUniswapV3PoolDerivedState.sol&#39;;</span>
  7 |     | <span class='neutral'>import &#39;./pool/IUniswapV3PoolActions.sol&#39;;</span>
  8 |     | <span class='neutral'>import &#39;./pool/IUniswapV3PoolOwnerActions.sol&#39;;</span>
  9 |     | <span class='neutral'>import &#39;./pool/IUniswapV3PoolEvents.sol&#39;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>/// @title The interface for a Uniswap V3 Pool</span>
 12 |     | <span class='neutral'>/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform</span>
 13 |     | <span class='neutral'>/// to the ERC20 specification</span>
 14 |     | <span class='neutral'>/// @dev The pool interface is broken up into many smaller pieces</span>
 15 |     | <span class='neutral'>interface IUniswapV3Pool is</span>
 16 |     | <span class='neutral'>    IUniswapV3PoolImmutables,</span>
 17 |     | <span class='neutral'>    IUniswapV3PoolState,</span>
 18 |     | <span class='neutral'>    IUniswapV3PoolDerivedState,</span>
 19 |     | <span class='neutral'>    IUniswapV3PoolActions,</span>
 20 |     | <span class='neutral'>    IUniswapV3PoolOwnerActions,</span>
 21 |     | <span class='neutral'>    IUniswapV3PoolEvents</span>
 22 |     | <span class='neutral'>{</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/IUniswapV3PoolDeployer.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title An interface for a contract that is capable of deploying Uniswap V3 Pools</span>
  5 |     | <span class='neutral'>/// @notice A contract that constructs a pool must implement this to pass arguments to the pool</span>
  6 |     | <span class='neutral'>/// @dev This is used to avoid having constructor arguments in the pool contract, which results in the init code hash</span>
  7 |     | <span class='neutral'>/// of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain</span>
  8 |     | <span class='neutral'>interface IUniswapV3PoolDeployer {</span>
  9 |     | <span class='neutral'>    /// @notice Get the parameters to be used in constructing the pool, set transiently during pool creation.</span>
 10 |     | <span class='neutral'>    /// @dev Called by the pool constructor to fetch the parameters of the pool</span>
 11 |     | <span class='neutral'>    /// Returns factory The factory address</span>
 12 |     | <span class='neutral'>    /// Returns token0 The first token of the pool by address sort order</span>
 13 |     | <span class='neutral'>    /// Returns token1 The second token of the pool by address sort order</span>
 14 |     | <span class='neutral'>    /// Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip</span>
 15 |     | <span class='neutral'>    /// Returns tickSpacing The minimum number of ticks between initialized ticks</span>
 16 |     | <span class='neutral'>    function parameters()</span>
 17 |     | <span class='neutral'>        external</span>
 18 |     | <span class='neutral'>        view</span>
 19 |     | <span class='neutral'>        returns (</span>
 20 |     | <span class='neutral'>            address factory,</span>
 21 |     | <span class='neutral'>            address token0,</span>
 22 |     | <span class='neutral'>            address token1,</span>
 23 |     | <span class='neutral'>            uint24 fee,</span>
 24 |     | <span class='neutral'>            int24 tickSpacing</span>
 25 |     | <span class='neutral'>        );</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/callback/IUniswapV3FlashCallback.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Callback for IUniswapV3PoolActions#flash</span>
  5 |     | <span class='neutral'>/// @notice Any contract that calls IUniswapV3PoolActions#flash must implement this interface</span>
  6 |     | <span class='neutral'>interface IUniswapV3FlashCallback {</span>
  7 |     | <span class='neutral'>    /// @notice Called to `msg.sender` after transferring to the recipient from IUniswapV3Pool#flash.</span>
  8 |     | <span class='neutral'>    /// @dev In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts.</span>
  9 |     | <span class='neutral'>    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.</span>
 10 |     | <span class='neutral'>    /// @param fee0 The fee amount in token0 due to the pool by the end of the flash</span>
 11 |     | <span class='neutral'>    /// @param fee1 The fee amount in token1 due to the pool by the end of the flash</span>
 12 |     | <span class='neutral'>    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#flash call</span>
 13 |     | <span class='neutral'>    function uniswapV3FlashCallback(</span>
 14 |     | <span class='neutral'>        uint256 fee0,</span>
 15 |     | <span class='neutral'>        uint256 fee1,</span>
 16 |     | <span class='neutral'>        bytes calldata data</span>
 17 |     | <span class='neutral'>    ) external;</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Callback for IUniswapV3PoolActions#mint</span>
  5 |     | <span class='neutral'>/// @notice Any contract that calls IUniswapV3PoolActions#mint must implement this interface</span>
  6 |     | <span class='neutral'>interface IUniswapV3MintCallback {</span>
  7 |     | <span class='neutral'>    /// @notice Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.</span>
  8 |     | <span class='neutral'>    /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.</span>
  9 |     | <span class='neutral'>    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.</span>
 10 |     | <span class='neutral'>    /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity</span>
 11 |     | <span class='neutral'>    /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity</span>
 12 |     | <span class='neutral'>    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call</span>
 13 |     | <span class='neutral'>    function uniswapV3MintCallback(</span>
 14 |     | <span class='neutral'>        uint256 amount0Owed,</span>
 15 |     | <span class='neutral'>        uint256 amount1Owed,</span>
 16 |     | <span class='neutral'>        bytes calldata data</span>
 17 |     | <span class='neutral'>    ) external;</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Callback for IUniswapV3PoolActions#swap</span>
  5 |     | <span class='neutral'>/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface</span>
  6 |     | <span class='neutral'>interface IUniswapV3SwapCallback {</span>
  7 |     | <span class='neutral'>    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.</span>
  8 |     | <span class='neutral'>    /// @dev In the implementation you must pay the pool tokens owed for the swap.</span>
  9 |     | <span class='neutral'>    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.</span>
 10 |     | <span class='neutral'>    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.</span>
 11 |     | <span class='neutral'>    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by</span>
 12 |     | <span class='neutral'>    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.</span>
 13 |     | <span class='neutral'>    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by</span>
 14 |     | <span class='neutral'>    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.</span>
 15 |     | <span class='neutral'>    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call</span>
 16 |     | <span class='neutral'>    function uniswapV3SwapCallback(</span>
 17 |     | <span class='neutral'>        int256 amount0Delta,</span>
 18 |     | <span class='neutral'>        int256 amount1Delta,</span>
 19 |     | <span class='neutral'>        bytes calldata data</span>
 20 |     | <span class='neutral'>    ) external;</span>
 21 |     | <span class='neutral'>}</span>
 22 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Permissionless pool actions</span>
   5 |     | <span class='neutral'>/// @notice Contains pool methods that can be called by anyone</span>
   6 |     | <span class='neutral'>interface IUniswapV3PoolActions {</span>
   7 |     | <span class='neutral'>    /// @notice Sets the initial price for the pool</span>
   8 |     | <span class='neutral'>    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value</span>
   9 |     | <span class='neutral'>    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96</span>
  10 |     | <span class='neutral'>    function initialize(uint160 sqrtPriceX96) external;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position</span>
  13 |     | <span class='neutral'>    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback</span>
  14 |     | <span class='neutral'>    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends</span>
  15 |     | <span class='neutral'>    /// on tickLower, tickUpper, the amount of liquidity, and the current price.</span>
  16 |     | <span class='neutral'>    /// @param recipient The address for which the liquidity will be created</span>
  17 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position in which to add liquidity</span>
  18 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position in which to add liquidity</span>
  19 |     | <span class='neutral'>    /// @param amount The amount of liquidity to mint</span>
  20 |     | <span class='neutral'>    /// @param data Any data that should be passed through to the callback</span>
  21 |     | <span class='neutral'>    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback</span>
  22 |     | <span class='neutral'>    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback</span>
  23 |     | <span class='neutral'>    function mint(</span>
  24 |     | <span class='neutral'>        address recipient,</span>
  25 |     | <span class='neutral'>        int24 tickLower,</span>
  26 |     | <span class='neutral'>        int24 tickUpper,</span>
  27 |     | <span class='neutral'>        uint128 amount,</span>
  28 |     | <span class='neutral'>        bytes calldata data</span>
  29 |     | <span class='neutral'>    ) external returns (uint256 amount0, uint256 amount1);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /// @notice Collects tokens owed to a position</span>
  32 |     | <span class='neutral'>    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.</span>
  33 |     | <span class='neutral'>    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or</span>
  34 |     | <span class='neutral'>    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the</span>
  35 |     | <span class='neutral'>    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.</span>
  36 |     | <span class='neutral'>    /// @param recipient The address which should receive the fees collected</span>
  37 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position for which to collect fees</span>
  38 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position for which to collect fees</span>
  39 |     | <span class='neutral'>    /// @param amount0Requested How much token0 should be withdrawn from the fees owed</span>
  40 |     | <span class='neutral'>    /// @param amount1Requested How much token1 should be withdrawn from the fees owed</span>
  41 |     | <span class='neutral'>    /// @return amount0 The amount of fees collected in token0</span>
  42 |     | <span class='neutral'>    /// @return amount1 The amount of fees collected in token1</span>
  43 |     | <span class='neutral'>    function collect(</span>
  44 |     | <span class='neutral'>        address recipient,</span>
  45 |     | <span class='neutral'>        int24 tickLower,</span>
  46 |     | <span class='neutral'>        int24 tickUpper,</span>
  47 |     | <span class='neutral'>        uint128 amount0Requested,</span>
  48 |     | <span class='neutral'>        uint128 amount1Requested</span>
  49 |     | <span class='neutral'>    ) external returns (uint128 amount0, uint128 amount1);</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position</span>
  52 |     | <span class='neutral'>    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0</span>
  53 |     | <span class='neutral'>    /// @dev Fees must be collected separately via a call to #collect</span>
  54 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position for which to burn liquidity</span>
  55 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position for which to burn liquidity</span>
  56 |     | <span class='neutral'>    /// @param amount How much liquidity to burn</span>
  57 |     | <span class='neutral'>    /// @return amount0 The amount of token0 sent to the recipient</span>
  58 |     | <span class='neutral'>    /// @return amount1 The amount of token1 sent to the recipient</span>
  59 |     | <span class='neutral'>    function burn(</span>
  60 |     | <span class='neutral'>        int24 tickLower,</span>
  61 |     | <span class='neutral'>        int24 tickUpper,</span>
  62 |     | <span class='neutral'>        uint128 amount</span>
  63 |     | <span class='neutral'>    ) external returns (uint256 amount0, uint256 amount1);</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /// @notice Swap token0 for token1, or token1 for token0</span>
  66 |     | <span class='neutral'>    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback</span>
  67 |     | <span class='neutral'>    /// @param recipient The address to receive the output of the swap</span>
  68 |     | <span class='neutral'>    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0</span>
  69 |     | <span class='neutral'>    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)</span>
  70 |     | <span class='neutral'>    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this</span>
  71 |     | <span class='neutral'>    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap</span>
  72 |     | <span class='neutral'>    /// @param data Any data to be passed through to the callback</span>
  73 |     | <span class='neutral'>    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive</span>
  74 |     | <span class='neutral'>    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive</span>
  75 |     | <span class='neutral'>    function swap(</span>
  76 |     | <span class='neutral'>        address recipient,</span>
  77 |     | <span class='neutral'>        bool zeroForOne,</span>
  78 |     | <span class='neutral'>        int256 amountSpecified,</span>
  79 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96,</span>
  80 |     | <span class='neutral'>        bytes calldata data</span>
  81 |     | <span class='neutral'>    ) external returns (int256 amount0, int256 amount1);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback</span>
  84 |     | <span class='neutral'>    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback</span>
  85 |     | <span class='neutral'>    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling</span>
  86 |     | <span class='neutral'>    /// with 0 amount{0,1} and sending the donation amount(s) from the callback</span>
  87 |     | <span class='neutral'>    /// @param recipient The address which will receive the token0 and token1 amounts</span>
  88 |     | <span class='neutral'>    /// @param amount0 The amount of token0 to send</span>
  89 |     | <span class='neutral'>    /// @param amount1 The amount of token1 to send</span>
  90 |     | <span class='neutral'>    /// @param data Any data to be passed through to the callback</span>
  91 |     | <span class='neutral'>    function flash(</span>
  92 |     | <span class='neutral'>        address recipient,</span>
  93 |     | <span class='neutral'>        uint256 amount0,</span>
  94 |     | <span class='neutral'>        uint256 amount1,</span>
  95 |     | <span class='neutral'>        bytes calldata data</span>
  96 |     | <span class='neutral'>    ) external;</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /// @notice Increase the maximum number of price and liquidity observations that this pool will store</span>
  99 |     | <span class='neutral'>    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to</span>
 100 |     | <span class='neutral'>    /// the input observationCardinalityNext.</span>
 101 |     | <span class='neutral'>    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store</span>
 102 |     | <span class='neutral'>    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;</span>
 103 |     | <span class='neutral'>}</span>
 104 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Pool state that is not stored</span>
  5 |     | <span class='neutral'>/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the</span>
  6 |     | <span class='neutral'>/// blockchain. The functions here may have variable gas costs.</span>
  7 |     | <span class='neutral'>interface IUniswapV3PoolDerivedState {</span>
  8 |     | <span class='neutral'>    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp</span>
  9 |     | <span class='neutral'>    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing</span>
 10 |     | <span class='neutral'>    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,</span>
 11 |     | <span class='neutral'>    /// you must call it with secondsAgos = [3600, 0].</span>
 12 |     | <span class='neutral'>    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in</span>
 13 |     | <span class='neutral'>    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.</span>
 14 |     | <span class='neutral'>    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned</span>
 15 |     | <span class='neutral'>    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp</span>
 16 |     | <span class='neutral'>    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block</span>
 17 |     | <span class='neutral'>    /// timestamp</span>
 18 |     | <span class='neutral'>    function observe(uint32[] calldata secondsAgos)</span>
 19 |     | <span class='neutral'>        external</span>
 20 |     | <span class='neutral'>        view</span>
 21 |     | <span class='neutral'>        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range</span>
 24 |     | <span class='neutral'>    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.</span>
 25 |     | <span class='neutral'>    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first</span>
 26 |     | <span class='neutral'>    /// snapshot is taken and the second snapshot is taken.</span>
 27 |     | <span class='neutral'>    /// @param tickLower The lower tick of the range</span>
 28 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the range</span>
 29 |     | <span class='neutral'>    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range</span>
 30 |     | <span class='neutral'>    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range</span>
 31 |     | <span class='neutral'>    /// @return secondsInside The snapshot of seconds per liquidity for the range</span>
 32 |     | <span class='neutral'>    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)</span>
 33 |     | <span class='neutral'>        external</span>
 34 |     | <span class='neutral'>        view</span>
 35 |     | <span class='neutral'>        returns (</span>
 36 |     | <span class='neutral'>            int56 tickCumulativeInside,</span>
 37 |     | <span class='neutral'>            uint160 secondsPerLiquidityInsideX128,</span>
 38 |     | <span class='neutral'>            uint32 secondsInside</span>
 39 |     | <span class='neutral'>        );</span>
 40 |     | <span class='neutral'>}</span>
 41 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Events emitted by a pool</span>
   5 |     | <span class='neutral'>/// @notice Contains all events emitted by the pool</span>
   6 |     | <span class='neutral'>interface IUniswapV3PoolEvents {</span>
   7 |     | <span class='neutral'>    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool</span>
   8 |     | <span class='neutral'>    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize</span>
   9 |     | <span class='neutral'>    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96</span>
  10 |     | <span class='neutral'>    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool</span>
  11 |     | <span class='neutral'>    event Initialize(uint160 sqrtPriceX96, int24 tick);</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    /// @notice Emitted when liquidity is minted for a given position</span>
  14 |     | <span class='neutral'>    /// @param sender The address that minted the liquidity</span>
  15 |     | <span class='neutral'>    /// @param owner The owner of the position and recipient of any minted liquidity</span>
  16 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position</span>
  17 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position</span>
  18 |     | <span class='neutral'>    /// @param amount The amount of liquidity minted to the position range</span>
  19 |     | <span class='neutral'>    /// @param amount0 How much token0 was required for the minted liquidity</span>
  20 |     | <span class='neutral'>    /// @param amount1 How much token1 was required for the minted liquidity</span>
  21 |     | <span class='neutral'>    event Mint(</span>
  22 |     | <span class='neutral'>        address sender,</span>
  23 |     | <span class='neutral'>        address indexed owner,</span>
  24 |     | <span class='neutral'>        int24 indexed tickLower,</span>
  25 |     | <span class='neutral'>        int24 indexed tickUpper,</span>
  26 |     | <span class='neutral'>        uint128 amount,</span>
  27 |     | <span class='neutral'>        uint256 amount0,</span>
  28 |     | <span class='neutral'>        uint256 amount1</span>
  29 |     | <span class='neutral'>    );</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /// @notice Emitted when fees are collected by the owner of a position</span>
  32 |     | <span class='neutral'>    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees</span>
  33 |     | <span class='neutral'>    /// @param owner The owner of the position for which fees are collected</span>
  34 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position</span>
  35 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position</span>
  36 |     | <span class='neutral'>    /// @param amount0 The amount of token0 fees collected</span>
  37 |     | <span class='neutral'>    /// @param amount1 The amount of token1 fees collected</span>
  38 |     | <span class='neutral'>    event Collect(</span>
  39 |     | <span class='neutral'>        address indexed owner,</span>
  40 |     | <span class='neutral'>        address recipient,</span>
  41 |     | <span class='neutral'>        int24 indexed tickLower,</span>
  42 |     | <span class='neutral'>        int24 indexed tickUpper,</span>
  43 |     | <span class='neutral'>        uint128 amount0,</span>
  44 |     | <span class='neutral'>        uint128 amount1</span>
  45 |     | <span class='neutral'>    );</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /// @notice Emitted when a position&#39;s liquidity is removed</span>
  48 |     | <span class='neutral'>    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect</span>
  49 |     | <span class='neutral'>    /// @param owner The owner of the position for which liquidity is removed</span>
  50 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position</span>
  51 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position</span>
  52 |     | <span class='neutral'>    /// @param amount The amount of liquidity to remove</span>
  53 |     | <span class='neutral'>    /// @param amount0 The amount of token0 withdrawn</span>
  54 |     | <span class='neutral'>    /// @param amount1 The amount of token1 withdrawn</span>
  55 |     | <span class='neutral'>    event Burn(</span>
  56 |     | <span class='neutral'>        address indexed owner,</span>
  57 |     | <span class='neutral'>        int24 indexed tickLower,</span>
  58 |     | <span class='neutral'>        int24 indexed tickUpper,</span>
  59 |     | <span class='neutral'>        uint128 amount,</span>
  60 |     | <span class='neutral'>        uint256 amount0,</span>
  61 |     | <span class='neutral'>        uint256 amount1</span>
  62 |     | <span class='neutral'>    );</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /// @notice Emitted by the pool for any swaps between token0 and token1</span>
  65 |     | <span class='neutral'>    /// @param sender The address that initiated the swap call, and that received the callback</span>
  66 |     | <span class='neutral'>    /// @param recipient The address that received the output of the swap</span>
  67 |     | <span class='neutral'>    /// @param amount0 The delta of the token0 balance of the pool</span>
  68 |     | <span class='neutral'>    /// @param amount1 The delta of the token1 balance of the pool</span>
  69 |     | <span class='neutral'>    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96</span>
  70 |     | <span class='neutral'>    /// @param liquidity The liquidity of the pool after the swap</span>
  71 |     | <span class='neutral'>    /// @param tick The log base 1.0001 of price of the pool after the swap</span>
  72 |     | <span class='neutral'>    event Swap(</span>
  73 |     | <span class='neutral'>        address indexed sender,</span>
  74 |     | <span class='neutral'>        address indexed recipient,</span>
  75 |     | <span class='neutral'>        int256 amount0,</span>
  76 |     | <span class='neutral'>        int256 amount1,</span>
  77 |     | <span class='neutral'>        uint160 sqrtPriceX96,</span>
  78 |     | <span class='neutral'>        uint128 liquidity,</span>
  79 |     | <span class='neutral'>        int24 tick</span>
  80 |     | <span class='neutral'>    );</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    /// @notice Emitted by the pool for any flashes of token0/token1</span>
  83 |     | <span class='neutral'>    /// @param sender The address that initiated the swap call, and that received the callback</span>
  84 |     | <span class='neutral'>    /// @param recipient The address that received the tokens from flash</span>
  85 |     | <span class='neutral'>    /// @param amount0 The amount of token0 that was flashed</span>
  86 |     | <span class='neutral'>    /// @param amount1 The amount of token1 that was flashed</span>
  87 |     | <span class='neutral'>    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee</span>
  88 |     | <span class='neutral'>    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee</span>
  89 |     | <span class='neutral'>    event Flash(</span>
  90 |     | <span class='neutral'>        address indexed sender,</span>
  91 |     | <span class='neutral'>        address indexed recipient,</span>
  92 |     | <span class='neutral'>        uint256 amount0,</span>
  93 |     | <span class='neutral'>        uint256 amount1,</span>
  94 |     | <span class='neutral'>        uint256 paid0,</span>
  95 |     | <span class='neutral'>        uint256 paid1</span>
  96 |     | <span class='neutral'>    );</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /// @notice Emitted by the pool for increases to the number of observations that can be stored</span>
  99 |     | <span class='neutral'>    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index</span>
 100 |     | <span class='neutral'>    /// just before a mint/swap/burn.</span>
 101 |     | <span class='neutral'>    /// @param observationCardinalityNextOld The previous value of the next observation cardinality</span>
 102 |     | <span class='neutral'>    /// @param observationCardinalityNextNew The updated value of the next observation cardinality</span>
 103 |     | <span class='neutral'>    event IncreaseObservationCardinalityNext(</span>
 104 |     | <span class='neutral'>        uint16 observationCardinalityNextOld,</span>
 105 |     | <span class='neutral'>        uint16 observationCardinalityNextNew</span>
 106 |     | <span class='neutral'>    );</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /// @notice Emitted when the protocol fee is changed by the pool</span>
 109 |     | <span class='neutral'>    /// @param feeProtocol0Old The previous value of the token0 protocol fee</span>
 110 |     | <span class='neutral'>    /// @param feeProtocol1Old The previous value of the token1 protocol fee</span>
 111 |     | <span class='neutral'>    /// @param feeProtocol0New The updated value of the token0 protocol fee</span>
 112 |     | <span class='neutral'>    /// @param feeProtocol1New The updated value of the token1 protocol fee</span>
 113 |     | <span class='neutral'>    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner</span>
 116 |     | <span class='neutral'>    /// @param sender The address that collects the protocol fees</span>
 117 |     | <span class='neutral'>    /// @param recipient The address that receives the collected protocol fees</span>
 118 |     | <span class='neutral'>    /// @param amount0 The amount of token0 protocol fees that is withdrawn</span>
 119 |     | <span class='neutral'>    /// @param amount0 The amount of token1 protocol fees that is withdrawn</span>
 120 |     | <span class='neutral'>    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);</span>
 121 |     | <span class='neutral'>}</span>
 122 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Pool state that never changes</span>
  5 |     | <span class='neutral'>/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values</span>
  6 |     | <span class='neutral'>interface IUniswapV3PoolImmutables {</span>
  7 |     | <span class='neutral'>    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface</span>
  8 |     | <span class='neutral'>    /// @return The contract address</span>
  9 |     | <span class='neutral'>    function factory() external view returns (address);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    /// @notice The first of the two tokens of the pool, sorted by address</span>
 12 |     | <span class='neutral'>    /// @return The token contract address</span>
 13 |     | <span class='neutral'>    function token0() external view returns (address);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    /// @notice The second of the two tokens of the pool, sorted by address</span>
 16 |     | <span class='neutral'>    /// @return The token contract address</span>
 17 |     | <span class='neutral'>    function token1() external view returns (address);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /// @notice The pool&#39;s fee in hundredths of a bip, i.e. 1e-6</span>
 20 |     | <span class='neutral'>    /// @return The fee</span>
 21 |     | <span class='neutral'>    function fee() external view returns (uint24);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /// @notice The pool tick spacing</span>
 24 |     | <span class='neutral'>    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive</span>
 25 |     | <span class='neutral'>    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...</span>
 26 |     | <span class='neutral'>    /// This value is an int24 to avoid casting even though it is always positive.</span>
 27 |     | <span class='neutral'>    /// @return The tick spacing</span>
 28 |     | <span class='neutral'>    function tickSpacing() external view returns (int24);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    /// @notice The maximum amount of position liquidity that can use any tick in the range</span>
 31 |     | <span class='neutral'>    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and</span>
 32 |     | <span class='neutral'>    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool</span>
 33 |     | <span class='neutral'>    /// @return The max amount of liquidity per tick</span>
 34 |     | <span class='neutral'>    function maxLiquidityPerTick() external view returns (uint128);</span>
 35 |     | <span class='neutral'>}</span>
 36 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Permissioned pool actions</span>
  5 |     | <span class='neutral'>/// @notice Contains pool methods that may only be called by the factory owner</span>
  6 |     | <span class='neutral'>interface IUniswapV3PoolOwnerActions {</span>
  7 |     | <span class='neutral'>    /// @notice Set the denominator of the protocol&#39;s % share of the fees</span>
  8 |     | <span class='neutral'>    /// @param feeProtocol0 new protocol fee for token0 of the pool</span>
  9 |     | <span class='neutral'>    /// @param feeProtocol1 new protocol fee for token1 of the pool</span>
 10 |     | <span class='neutral'>    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /// @notice Collect the protocol fee accrued to the pool</span>
 13 |     | <span class='neutral'>    /// @param recipient The address to which collected protocol fees should be sent</span>
 14 |     | <span class='neutral'>    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1</span>
 15 |     | <span class='neutral'>    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0</span>
 16 |     | <span class='neutral'>    /// @return amount0 The protocol fee collected in token0</span>
 17 |     | <span class='neutral'>    /// @return amount1 The protocol fee collected in token1</span>
 18 |     | <span class='neutral'>    function collectProtocol(</span>
 19 |     | <span class='neutral'>        address recipient,</span>
 20 |     | <span class='neutral'>        uint128 amount0Requested,</span>
 21 |     | <span class='neutral'>        uint128 amount1Requested</span>
 22 |     | <span class='neutral'>    ) external returns (uint128 amount0, uint128 amount1);</span>
 23 |     | <span class='neutral'>}</span>
 24 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Pool state that can change</span>
   5 |     | <span class='neutral'>/// @notice These methods compose the pool&#39;s state, and can change with any frequency including multiple times</span>
   6 |     | <span class='neutral'>/// per transaction</span>
   7 |     | <span class='neutral'>interface IUniswapV3PoolState {</span>
   8 |     | <span class='neutral'>    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas</span>
   9 |     | <span class='neutral'>    /// when accessed externally.</span>
  10 |     | <span class='neutral'>    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value</span>
  11 |     | <span class='neutral'>    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.</span>
  12 |     | <span class='neutral'>    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick</span>
  13 |     | <span class='neutral'>    /// boundary.</span>
  14 |     | <span class='neutral'>    /// observationIndex The index of the last oracle observation that was written,</span>
  15 |     | <span class='neutral'>    /// observationCardinality The current maximum number of observations stored in the pool,</span>
  16 |     | <span class='neutral'>    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.</span>
  17 |     | <span class='neutral'>    /// feeProtocol The protocol fee for both tokens of the pool.</span>
  18 |     | <span class='neutral'>    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0</span>
  19 |     | <span class='neutral'>    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.</span>
  20 |     | <span class='neutral'>    /// unlocked Whether the pool is currently locked to reentrancy</span>
  21 |     | <span class='neutral'>    function slot0()</span>
  22 |     | <span class='neutral'>        external</span>
  23 |     | <span class='neutral'>        view</span>
  24 |     | <span class='neutral'>        returns (</span>
  25 |     | <span class='neutral'>            uint160 sqrtPriceX96,</span>
  26 |     | <span class='neutral'>            int24 tick,</span>
  27 |     | <span class='neutral'>            uint16 observationIndex,</span>
  28 |     | <span class='neutral'>            uint16 observationCardinality,</span>
  29 |     | <span class='neutral'>            uint16 observationCardinalityNext,</span>
  30 |     | <span class='neutral'>            uint8 feeProtocol,</span>
  31 |     | <span class='neutral'>            bool unlocked</span>
  32 |     | <span class='neutral'>        );</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool</span>
  35 |     | <span class='neutral'>    /// @dev This value can overflow the uint256</span>
  36 |     | <span class='neutral'>    function feeGrowthGlobal0X128() external view returns (uint256);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool</span>
  39 |     | <span class='neutral'>    /// @dev This value can overflow the uint256</span>
  40 |     | <span class='neutral'>    function feeGrowthGlobal1X128() external view returns (uint256);</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /// @notice The amounts of token0 and token1 that are owed to the protocol</span>
  43 |     | <span class='neutral'>    /// @dev Protocol fees will never exceed uint128 max in either token</span>
  44 |     | <span class='neutral'>    function protocolFees() external view returns (uint128 token0, uint128 token1);</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    /// @notice The currently in range liquidity available to the pool</span>
  47 |     | <span class='neutral'>    /// @dev This value has no relationship to the total liquidity across all ticks</span>
  48 |     | <span class='neutral'>    function liquidity() external view returns (uint128);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /// @notice Look up information about a specific tick in the pool</span>
  51 |     | <span class='neutral'>    /// @param tick The tick to look up</span>
  52 |     | <span class='neutral'>    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or</span>
  53 |     | <span class='neutral'>    /// tick upper,</span>
  54 |     | <span class='neutral'>    /// liquidityNet how much liquidity changes when the pool price crosses the tick,</span>
  55 |     | <span class='neutral'>    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,</span>
  56 |     | <span class='neutral'>    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,</span>
  57 |     | <span class='neutral'>    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick</span>
  58 |     | <span class='neutral'>    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,</span>
  59 |     | <span class='neutral'>    /// secondsOutside the seconds spent on the other side of the tick from the current tick,</span>
  60 |     | <span class='neutral'>    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.</span>
  61 |     | <span class='neutral'>    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.</span>
  62 |     | <span class='neutral'>    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for</span>
  63 |     | <span class='neutral'>    /// a specific position.</span>
  64 |     | <span class='neutral'>    function ticks(int24 tick)</span>
  65 |     | <span class='neutral'>        external</span>
  66 |     | <span class='neutral'>        view</span>
  67 |     | <span class='neutral'>        returns (</span>
  68 |     | <span class='neutral'>            uint128 liquidityGross,</span>
  69 |     | <span class='neutral'>            int128 liquidityNet,</span>
  70 |     | <span class='neutral'>            uint256 feeGrowthOutside0X128,</span>
  71 |     | <span class='neutral'>            uint256 feeGrowthOutside1X128,</span>
  72 |     | <span class='neutral'>            int56 tickCumulativeOutside,</span>
  73 |     | <span class='neutral'>            uint160 secondsPerLiquidityOutsideX128,</span>
  74 |     | <span class='neutral'>            uint32 secondsOutside,</span>
  75 |     | <span class='neutral'>            bool initialized</span>
  76 |     | <span class='neutral'>        );</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information</span>
  79 |     | <span class='neutral'>    function tickBitmap(int16 wordPosition) external view returns (uint256);</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    /// @notice Returns the information about a position by the position&#39;s key</span>
  82 |     | <span class='neutral'>    /// @param key The position&#39;s key is a hash of a preimage composed by the owner, tickLower and tickUpper</span>
  83 |     | <span class='neutral'>    /// @return _liquidity The amount of liquidity in the position,</span>
  84 |     | <span class='neutral'>    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,</span>
  85 |     | <span class='neutral'>    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,</span>
  86 |     | <span class='neutral'>    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,</span>
  87 |     | <span class='neutral'>    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke</span>
  88 |     | <span class='neutral'>    function positions(bytes32 key)</span>
  89 |     | <span class='neutral'>        external</span>
  90 |     | <span class='neutral'>        view</span>
  91 |     | <span class='neutral'>        returns (</span>
  92 |     | <span class='neutral'>            uint128 _liquidity,</span>
  93 |     | <span class='neutral'>            uint256 feeGrowthInside0LastX128,</span>
  94 |     | <span class='neutral'>            uint256 feeGrowthInside1LastX128,</span>
  95 |     | <span class='neutral'>            uint128 tokensOwed0,</span>
  96 |     | <span class='neutral'>            uint128 tokensOwed1</span>
  97 |     | <span class='neutral'>        );</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /// @notice Returns data about a specific observation index</span>
 100 |     | <span class='neutral'>    /// @param index The element of the observations array to fetch</span>
 101 |     | <span class='neutral'>    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time</span>
 102 |     | <span class='neutral'>    /// ago, rather than at a specific index in the array.</span>
 103 |     | <span class='neutral'>    /// @return blockTimestamp The timestamp of the observation,</span>
 104 |     | <span class='neutral'>    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,</span>
 105 |     | <span class='neutral'>    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,</span>
 106 |     | <span class='neutral'>    /// Returns initialized whether the observation has been initialized and the values are safe to use</span>
 107 |     | <span class='neutral'>    function observations(uint256 index)</span>
 108 |     | <span class='neutral'>        external</span>
 109 |     | <span class='neutral'>        view</span>
 110 |     | <span class='neutral'>        returns (</span>
 111 |     | <span class='neutral'>            uint32 blockTimestamp,</span>
 112 |     | <span class='neutral'>            int56 tickCumulative,</span>
 113 |     | <span class='neutral'>            uint160 secondsPerLiquidityCumulativeX128,</span>
 114 |     | <span class='neutral'>            bool initialized</span>
 115 |     | <span class='neutral'>        );</span>
 116 |     | <span class='neutral'>}</span>
 117 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/BitMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title BitMath</span>
  5 |     | <span class='neutral'>/// @dev This library provides functionality for computing bit properties of an unsigned integer</span>
  6 |     | <span class='unexecuted'>library BitMath {</span>
  7 |     | <span class='neutral'>    /// @notice Returns the index of the most significant bit of the number,</span>
  8 |     | <span class='neutral'>    ///     where the least significant bit is at index 0 and the most significant bit is at index 255</span>
  9 |     | <span class='neutral'>    /// @dev The function satisfies the property:</span>
 10 |     | <span class='neutral'>    ///     x &gt;= 2**mostSignificantBit(x) and x &lt; 2**(mostSignificantBit(x)+1)</span>
 11 |     | <span class='neutral'>    /// @param x the value for which to compute the most significant bit, must be greater than 0</span>
 12 |     | <span class='neutral'>    /// @return r the index of the most significant bit</span>
 13 | *   | <span class='executed'>    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {</span>
 14 | *   | <span class='executed'>        require(x &gt; 0);</span>
 15 |     | <span class='neutral'></span>
 16 | *   | <span class='executed'>        if (x &gt;= 0x100000000000000000000000000000000) {</span>
 17 | *   | <span class='executed'>            x &gt;&gt;= 128;</span>
 18 | *   | <span class='executed'>            r += 128;</span>
 19 |     | <span class='neutral'>        }</span>
 20 | *   | <span class='executed'>        if (x &gt;= 0x10000000000000000) {</span>
 21 | *   | <span class='executed'>            x &gt;&gt;= 64;</span>
 22 | *   | <span class='executed'>            r += 64;</span>
 23 |     | <span class='neutral'>        }</span>
 24 | *   | <span class='executed'>        if (x &gt;= 0x100000000) {</span>
 25 | *   | <span class='executed'>            x &gt;&gt;= 32;</span>
 26 | *   | <span class='executed'>            r += 32;</span>
 27 |     | <span class='neutral'>        }</span>
 28 | *   | <span class='executed'>        if (x &gt;= 0x10000) {</span>
 29 | *   | <span class='executed'>            x &gt;&gt;= 16;</span>
 30 | *   | <span class='executed'>            r += 16;</span>
 31 |     | <span class='neutral'>        }</span>
 32 | *   | <span class='executed'>        if (x &gt;= 0x100) {</span>
 33 | *   | <span class='executed'>            x &gt;&gt;= 8;</span>
 34 | *   | <span class='executed'>            r += 8;</span>
 35 |     | <span class='neutral'>        }</span>
 36 | *   | <span class='executed'>        if (x &gt;= 0x10) {</span>
 37 | *   | <span class='executed'>            x &gt;&gt;= 4;</span>
 38 | *   | <span class='executed'>            r += 4;</span>
 39 |     | <span class='neutral'>        }</span>
 40 | *   | <span class='executed'>        if (x &gt;= 0x4) {</span>
 41 | *   | <span class='executed'>            x &gt;&gt;= 2;</span>
 42 | *   | <span class='executed'>            r += 2;</span>
 43 |     | <span class='neutral'>        }</span>
 44 | *   | <span class='executed'>        if (x &gt;= 0x2) r += 1;</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    /// @notice Returns the index of the least significant bit of the number,</span>
 48 |     | <span class='neutral'>    ///     where the least significant bit is at index 0 and the most significant bit is at index 255</span>
 49 |     | <span class='neutral'>    /// @dev The function satisfies the property:</span>
 50 |     | <span class='neutral'>    ///     (x &amp; 2**leastSignificantBit(x)) != 0 and (x &amp; (2**(leastSignificantBit(x)) - 1)) == 0)</span>
 51 |     | <span class='neutral'>    /// @param x the value for which to compute the least significant bit, must be greater than 0</span>
 52 |     | <span class='neutral'>    /// @return r the index of the least significant bit</span>
 53 | *   | <span class='executed'>    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {</span>
 54 | *   | <span class='executed'>        require(x &gt; 0);</span>
 55 |     | <span class='neutral'></span>
 56 | *   | <span class='executed'>        r = 255;</span>
 57 | *   | <span class='executed'>        if (x &amp; type(uint128).max &gt; 0) {</span>
 58 | *   | <span class='executed'>            r -= 128;</span>
 59 |     | <span class='neutral'>        } else {</span>
 60 | *   | <span class='executed'>            x &gt;&gt;= 128;</span>
 61 |     | <span class='neutral'>        }</span>
 62 |     | <span class='unexecuted'>        if (x &amp; type(uint64).max &gt; 0) {</span>
 63 |     | <span class='unexecuted'>            r -= 64;</span>
 64 |     | <span class='neutral'>        } else {</span>
 65 |     | <span class='unexecuted'>            x &gt;&gt;= 64;</span>
 66 |     | <span class='neutral'>        }</span>
 67 |     | <span class='unexecuted'>        if (x &amp; type(uint32).max &gt; 0) {</span>
 68 |     | <span class='unexecuted'>            r -= 32;</span>
 69 |     | <span class='neutral'>        } else {</span>
 70 |     | <span class='unexecuted'>            x &gt;&gt;= 32;</span>
 71 |     | <span class='neutral'>        }</span>
 72 |     | <span class='unexecuted'>        if (x &amp; type(uint16).max &gt; 0) {</span>
 73 |     | <span class='unexecuted'>            r -= 16;</span>
 74 |     | <span class='neutral'>        } else {</span>
 75 |     | <span class='unexecuted'>            x &gt;&gt;= 16;</span>
 76 |     | <span class='neutral'>        }</span>
 77 |     | <span class='unexecuted'>        if (x &amp; type(uint8).max &gt; 0) {</span>
 78 |     | <span class='unexecuted'>            r -= 8;</span>
 79 |     | <span class='neutral'>        } else {</span>
 80 |     | <span class='unexecuted'>            x &gt;&gt;= 8;</span>
 81 |     | <span class='neutral'>        }</span>
 82 |     | <span class='unexecuted'>        if (x &amp; 0xf &gt; 0) {</span>
 83 |     | <span class='unexecuted'>            r -= 4;</span>
 84 |     | <span class='neutral'>        } else {</span>
 85 |     | <span class='unexecuted'>            x &gt;&gt;= 4;</span>
 86 |     | <span class='neutral'>        }</span>
 87 |     | <span class='unexecuted'>        if (x &amp; 0x3 &gt; 0) {</span>
 88 |     | <span class='unexecuted'>            r -= 2;</span>
 89 |     | <span class='neutral'>        } else {</span>
 90 |     | <span class='unexecuted'>            x &gt;&gt;= 2;</span>
 91 |     | <span class='neutral'>        }</span>
 92 |     | <span class='unexecuted'>        if (x &amp; 0x1 &gt; 0) r -= 1;</span>
 93 |     | <span class='neutral'>    }</span>
 94 |     | <span class='neutral'>}</span>
 95 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/FixedPoint128.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.4.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title FixedPoint128</span>
  5 |     | <span class='neutral'>/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)</span>
  6 |     | <span class='unexecuted'>library FixedPoint128 {</span>
  7 |     | <span class='neutral'>    uint256 internal constant Q128 = 0x100000000000000000000000000000000;</span>
  8 |     | <span class='neutral'>}</span>
  9 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/FixedPoint96.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.4.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title FixedPoint96</span>
  5 |     | <span class='neutral'>/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)</span>
  6 |     | <span class='neutral'>/// @dev Used in SqrtPriceMath.sol</span>
  7 |     | <span class='unexecuted'>library FixedPoint96 {</span>
  8 | *   | <span class='executed'>    uint8 internal constant RESOLUTION = 96;</span>
  9 |     | <span class='neutral'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
 10 |     | <span class='neutral'>}</span>
 11 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/FullMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.4.0 &lt;0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Contains 512-bit math functions</span>
   5 |     | <span class='neutral'>/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision</span>
   6 |     | <span class='neutral'>/// @dev Handles &quot;phantom overflow&quot; i.e., allows multiplication and division where an intermediate value overflows 256 bits</span>
   7 |     | <span class='unexecuted'>library FullMath {</span>
   8 |     | <span class='neutral'>    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0</span>
   9 |     | <span class='neutral'>    /// @param a The multiplicand</span>
  10 |     | <span class='neutral'>    /// @param b The multiplier</span>
  11 |     | <span class='neutral'>    /// @param denominator The divisor</span>
  12 |     | <span class='neutral'>    /// @return result The 256-bit result</span>
  13 |     | <span class='neutral'>    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv</span>
  14 | *   | <span class='executed'>    function mulDiv(</span>
  15 |     | <span class='neutral'>        uint256 a,</span>
  16 |     | <span class='neutral'>        uint256 b,</span>
  17 |     | <span class='neutral'>        uint256 denominator</span>
  18 | *   | <span class='executed'>    ) internal pure returns (uint256 result) {</span>
  19 |     | <span class='neutral'>        // 512-bit multiply [prod1 prod0] = a * b</span>
  20 |     | <span class='neutral'>        // Compute the product mod 2**256 and mod 2**256 - 1</span>
  21 |     | <span class='neutral'>        // then use the Chinese Remainder Theorem to reconstruct</span>
  22 |     | <span class='neutral'>        // the 512 bit result. The result is stored in two 256</span>
  23 |     | <span class='neutral'>        // variables such that product = prod1 * 2**256 + prod0</span>
  24 |     | <span class='neutral'>        uint256 prod0; // Least significant 256 bits of the product</span>
  25 |     | <span class='neutral'>        uint256 prod1; // Most significant 256 bits of the product</span>
  26 |     | <span class='neutral'>        assembly {</span>
  27 | *   | <span class='executed'>            let mm := mulmod(a, b, not(0))</span>
  28 | *   | <span class='executed'>            prod0 := mul(a, b)</span>
  29 | *   | <span class='executed'>            prod1 := sub(sub(mm, prod0), lt(mm, prod0))</span>
  30 |     | <span class='neutral'>        }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>        // Handle non-overflow cases, 256 by 256 division</span>
  33 | *   | <span class='executed'>        if (prod1 == 0) {</span>
  34 | *   | <span class='executed'>            require(denominator &gt; 0);</span>
  35 |     | <span class='neutral'>            assembly {</span>
  36 | *   | <span class='executed'>                result := div(prod0, denominator)</span>
  37 |     | <span class='neutral'>            }</span>
  38 | *   | <span class='executed'>            return result;</span>
  39 |     | <span class='neutral'>        }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>        // Make sure the result is less than 2**256.</span>
  42 |     | <span class='neutral'>        // Also prevents denominator == 0</span>
  43 | *   | <span class='executed'>        require(denominator &gt; prod1);</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>        ///////////////////////////////////////////////</span>
  46 |     | <span class='neutral'>        // 512 by 256 division.</span>
  47 |     | <span class='neutral'>        ///////////////////////////////////////////////</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>        // Make division exact by subtracting the remainder from [prod1 prod0]</span>
  50 |     | <span class='neutral'>        // Compute remainder using mulmod</span>
  51 | *   | <span class='executed'>        uint256 remainder;</span>
  52 |     | <span class='neutral'>        assembly {</span>
  53 | *   | <span class='executed'>            remainder := mulmod(a, b, denominator)</span>
  54 |     | <span class='neutral'>        }</span>
  55 |     | <span class='neutral'>        // Subtract 256 bit number from 512 bit number</span>
  56 |     | <span class='neutral'>        assembly {</span>
  57 | *   | <span class='executed'>            prod1 := sub(prod1, gt(remainder, prod0))</span>
  58 | *   | <span class='executed'>            prod0 := sub(prod0, remainder)</span>
  59 |     | <span class='neutral'>        }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>        // Factor powers of two out of denominator</span>
  62 |     | <span class='neutral'>        // Compute largest power of two divisor of denominator.</span>
  63 |     | <span class='neutral'>        // Always &gt;= 1.</span>
  64 | *   | <span class='executed'>        uint256 twos = -denominator &amp; denominator;</span>
  65 |     | <span class='neutral'>        // Divide denominator by power of two</span>
  66 |     | <span class='neutral'>        assembly {</span>
  67 | *   | <span class='executed'>            denominator := div(denominator, twos)</span>
  68 |     | <span class='neutral'>        }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>        // Divide [prod1 prod0] by the factors of two</span>
  71 |     | <span class='neutral'>        assembly {</span>
  72 | *   | <span class='executed'>            prod0 := div(prod0, twos)</span>
  73 |     | <span class='neutral'>        }</span>
  74 |     | <span class='neutral'>        // Shift in bits from prod1 into prod0. For this we need</span>
  75 |     | <span class='neutral'>        // to flip `twos` such that it is 2**256 / twos.</span>
  76 |     | <span class='neutral'>        // If twos is zero, then it becomes one</span>
  77 |     | <span class='neutral'>        assembly {</span>
  78 | *   | <span class='executed'>            twos := add(div(sub(0, twos), twos), 1)</span>
  79 |     | <span class='neutral'>        }</span>
  80 | *   | <span class='executed'>        prod0 |= prod1 * twos;</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>        // Invert denominator mod 2**256</span>
  83 |     | <span class='neutral'>        // Now that denominator is an odd number, it has an inverse</span>
  84 |     | <span class='neutral'>        // modulo 2**256 such that denominator * inv = 1 mod 2**256.</span>
  85 |     | <span class='neutral'>        // Compute the inverse by starting with a seed that is correct</span>
  86 |     | <span class='neutral'>        // correct for four bits. That is, denominator * inv = 1 mod 2**4</span>
  87 | *   | <span class='executed'>        uint256 inv = (3 * denominator) ^ 2;</span>
  88 |     | <span class='neutral'>        // Now use Newton-Raphson iteration to improve the precision.</span>
  89 |     | <span class='neutral'>        // Thanks to Hensel&#39;s lifting lemma, this also works in modular</span>
  90 |     | <span class='neutral'>        // arithmetic, doubling the correct bits in each step.</span>
  91 | *   | <span class='executed'>        inv *= 2 - denominator * inv; // inverse mod 2**8</span>
  92 | *   | <span class='executed'>        inv *= 2 - denominator * inv; // inverse mod 2**16</span>
  93 | *   | <span class='executed'>        inv *= 2 - denominator * inv; // inverse mod 2**32</span>
  94 | *   | <span class='executed'>        inv *= 2 - denominator * inv; // inverse mod 2**64</span>
  95 | *   | <span class='executed'>        inv *= 2 - denominator * inv; // inverse mod 2**128</span>
  96 | *   | <span class='executed'>        inv *= 2 - denominator * inv; // inverse mod 2**256</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>        // Because the division is now exact we can divide by multiplying</span>
  99 |     | <span class='neutral'>        // with the modular inverse of denominator. This will give us the</span>
 100 |     | <span class='neutral'>        // correct result modulo 2**256. Since the precoditions guarantee</span>
 101 |     | <span class='neutral'>        // that the outcome is less than 2**256, this is the final result.</span>
 102 |     | <span class='neutral'>        // We don&#39;t need to compute the high bits of the result and prod1</span>
 103 |     | <span class='neutral'>        // is no longer required.</span>
 104 | *   | <span class='executed'>        result = prod0 * inv;</span>
 105 |     | <span class='neutral'>        return result;</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0</span>
 109 |     | <span class='neutral'>    /// @param a The multiplicand</span>
 110 |     | <span class='neutral'>    /// @param b The multiplier</span>
 111 |     | <span class='neutral'>    /// @param denominator The divisor</span>
 112 |     | <span class='neutral'>    /// @return result The 256-bit result</span>
 113 | *   | <span class='executed'>    function mulDivRoundingUp(</span>
 114 |     | <span class='neutral'>        uint256 a,</span>
 115 |     | <span class='neutral'>        uint256 b,</span>
 116 |     | <span class='neutral'>        uint256 denominator</span>
 117 | *   | <span class='executed'>    ) internal pure returns (uint256 result) {</span>
 118 | *   | <span class='executed'>        result = mulDiv(a, b, denominator);</span>
 119 | *   | <span class='executed'>        if (mulmod(a, b, denominator) &gt; 0) {</span>
 120 | *   | <span class='executed'>            require(result &lt; type(uint256).max);</span>
 121 | *   | <span class='executed'>            result++;</span>
 122 |     | <span class='neutral'>        }</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'>}</span>
 125 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/LiquidityMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Math library for liquidity</span>
  5 |     | <span class='unexecuted'>library LiquidityMath {</span>
  6 |     | <span class='neutral'>    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows</span>
  7 |     | <span class='neutral'>    /// @param x The liquidity before change</span>
  8 |     | <span class='neutral'>    /// @param y The delta by which liquidity should be changed</span>
  9 |     | <span class='neutral'>    /// @return z The liquidity delta</span>
 10 | *   | <span class='executed'>    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {</span>
 11 | *   | <span class='executed'>        if (y &lt; 0) {</span>
 12 | *   | <span class='executed'>            require((z = x - uint128(-y)) &lt; x, &#39;LS&#39;);</span>
 13 |     | <span class='neutral'>        } else {</span>
 14 | *   | <span class='executed'>            require((z = x + uint128(y)) &gt;= x, &#39;LA&#39;);</span>
 15 |     | <span class='neutral'>        }</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/LowGasSafeMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.7.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Optimized overflow and underflow safe math operations</span>
  5 |     | <span class='neutral'>/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost</span>
  6 |     | <span class='unexecuted'>library LowGasSafeMath {</span>
  7 |     | <span class='neutral'>    /// @notice Returns x + y, reverts if sum overflows uint256</span>
  8 |     | <span class='neutral'>    /// @param x The augend</span>
  9 |     | <span class='neutral'>    /// @param y The addend</span>
 10 |     | <span class='neutral'>    /// @return z The sum of x and y</span>
 11 | *   | <span class='executed'>    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 12 | *   | <span class='executed'>        require((z = x + y) &gt;= x);</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    /// @notice Returns x - y, reverts if underflows</span>
 16 |     | <span class='neutral'>    /// @param x The minuend</span>
 17 |     | <span class='neutral'>    /// @param y The subtrahend</span>
 18 |     | <span class='neutral'>    /// @return z The difference of x and y</span>
 19 |     | <span class='neutral'>    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 20 |     | <span class='neutral'>        require((z = x - y) &lt;= x);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /// @notice Returns x * y, reverts if overflows</span>
 24 |     | <span class='neutral'>    /// @param x The multiplicand</span>
 25 |     | <span class='neutral'>    /// @param y The multiplier</span>
 26 |     | <span class='neutral'>    /// @return z The product of x and y</span>
 27 |     | <span class='neutral'>    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 28 |     | <span class='neutral'>        require(x == 0 || (z = x * y) / x == y);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /// @notice Returns x + y, reverts if overflows or underflows</span>
 32 |     | <span class='neutral'>    /// @param x The augend</span>
 33 |     | <span class='neutral'>    /// @param y The addend</span>
 34 |     | <span class='neutral'>    /// @return z The sum of x and y</span>
 35 | *   | <span class='executed'>    function add(int256 x, int256 y) internal pure returns (int256 z) {</span>
 36 | *   | <span class='executed'>        require((z = x + y) &gt;= x == (y &gt;= 0));</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    /// @notice Returns x - y, reverts if overflows or underflows</span>
 40 |     | <span class='neutral'>    /// @param x The minuend</span>
 41 |     | <span class='neutral'>    /// @param y The subtrahend</span>
 42 |     | <span class='neutral'>    /// @return z The difference of x and y</span>
 43 | *   | <span class='executed'>    function sub(int256 x, int256 y) internal pure returns (int256 z) {</span>
 44 | *   | <span class='executed'>        require((z = x - y) &lt;= x == (y &gt;= 0));</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'>}</span>
 47 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/Oracle.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0 &lt;0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Oracle</span>
   5 |     | <span class='neutral'>/// @notice Provides price and liquidity data useful for a wide variety of system designs</span>
   6 |     | <span class='neutral'>/// @dev Instances of stored oracle data, &quot;observations&quot;, are collected in the oracle array</span>
   7 |     | <span class='neutral'>/// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the</span>
   8 |     | <span class='neutral'>/// maximum length of the oracle array. New slots will be added when the array is fully populated.</span>
   9 |     | <span class='neutral'>/// Observations are overwritten when the full length of the oracle array is populated.</span>
  10 |     | <span class='neutral'>/// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()</span>
  11 |     | <span class='unexecuted'>library Oracle {</span>
  12 |     | <span class='neutral'>    struct Observation {</span>
  13 |     | <span class='neutral'>        // the block timestamp of the observation</span>
  14 |     | <span class='neutral'>        uint32 blockTimestamp;</span>
  15 |     | <span class='neutral'>        // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized</span>
  16 |     | <span class='neutral'>        int56 tickCumulative;</span>
  17 |     | <span class='neutral'>        // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized</span>
  18 |     | <span class='neutral'>        uint160 secondsPerLiquidityCumulativeX128;</span>
  19 |     | <span class='neutral'>        // whether or not the observation is initialized</span>
  20 |     | <span class='neutral'>        bool initialized;</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /// @notice Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values</span>
  24 |     | <span class='neutral'>    /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows</span>
  25 |     | <span class='neutral'>    /// @param last The specified observation to be transformed</span>
  26 |     | <span class='neutral'>    /// @param blockTimestamp The timestamp of the new observation</span>
  27 |     | <span class='neutral'>    /// @param tick The active tick at the time of the new observation</span>
  28 |     | <span class='neutral'>    /// @param liquidity The total in-range liquidity at the time of the new observation</span>
  29 |     | <span class='neutral'>    /// @return Observation The newly populated observation</span>
  30 | *   | <span class='executed'>    function transform(</span>
  31 |     | <span class='neutral'>        Observation memory last,</span>
  32 |     | <span class='neutral'>        uint32 blockTimestamp,</span>
  33 |     | <span class='neutral'>        int24 tick,</span>
  34 |     | <span class='neutral'>        uint128 liquidity</span>
  35 | *   | <span class='executed'>    ) private pure returns (Observation memory) {</span>
  36 | *   | <span class='executed'>        uint32 delta = blockTimestamp - last.blockTimestamp;</span>
  37 | *   | <span class='executed'>        return</span>
  38 | *   | <span class='executed'>            Observation({</span>
  39 | *   | <span class='executed'>                blockTimestamp: blockTimestamp,</span>
  40 | *   | <span class='executed'>                tickCumulative: last.tickCumulative + int56(tick) * delta,</span>
  41 | *   | <span class='executed'>                secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +</span>
  42 | *   | <span class='executed'>                    ((uint160(delta) &lt;&lt; 128) / (liquidity &gt; 0 ? liquidity : 1)),</span>
  43 | *   | <span class='executed'>                initialized: true</span>
  44 |     | <span class='neutral'>            });</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array</span>
  48 |     | <span class='neutral'>    /// @param self The stored oracle array</span>
  49 |     | <span class='neutral'>    /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32</span>
  50 |     | <span class='neutral'>    /// @return cardinality The number of populated elements in the oracle array</span>
  51 |     | <span class='neutral'>    /// @return cardinalityNext The new length of the oracle array, independent of population</span>
  52 | *   | <span class='executed'>    function initialize(Observation[65535] storage self, uint32 time)</span>
  53 |     | <span class='neutral'>        internal</span>
  54 |     | <span class='neutral'>        returns (uint16 cardinality, uint16 cardinalityNext)</span>
  55 |     | <span class='neutral'>    {</span>
  56 | *   | <span class='executed'>        self[0] = Observation({</span>
  57 |     | <span class='neutral'>            blockTimestamp: time,</span>
  58 |     | <span class='neutral'>            tickCumulative: 0,</span>
  59 |     | <span class='neutral'>            secondsPerLiquidityCumulativeX128: 0,</span>
  60 | *   | <span class='executed'>            initialized: true</span>
  61 |     | <span class='neutral'>        });</span>
  62 |     | <span class='neutral'>        return (1, 1);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /// @notice Writes an oracle observation to the array</span>
  66 |     | <span class='neutral'>    /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.</span>
  67 |     | <span class='neutral'>    /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality</span>
  68 |     | <span class='neutral'>    /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.</span>
  69 |     | <span class='neutral'>    /// @param self The stored oracle array</span>
  70 |     | <span class='neutral'>    /// @param index The index of the observation that was most recently written to the observations array</span>
  71 |     | <span class='neutral'>    /// @param blockTimestamp The timestamp of the new observation</span>
  72 |     | <span class='neutral'>    /// @param tick The active tick at the time of the new observation</span>
  73 |     | <span class='neutral'>    /// @param liquidity The total in-range liquidity at the time of the new observation</span>
  74 |     | <span class='neutral'>    /// @param cardinality The number of populated elements in the oracle array</span>
  75 |     | <span class='neutral'>    /// @param cardinalityNext The new length of the oracle array, independent of population</span>
  76 |     | <span class='neutral'>    /// @return indexUpdated The new index of the most recently written element in the oracle array</span>
  77 |     | <span class='neutral'>    /// @return cardinalityUpdated The new cardinality of the oracle array</span>
  78 | *   | <span class='executed'>    function write(</span>
  79 |     | <span class='neutral'>        Observation[65535] storage self,</span>
  80 |     | <span class='neutral'>        uint16 index,</span>
  81 |     | <span class='neutral'>        uint32 blockTimestamp,</span>
  82 |     | <span class='neutral'>        int24 tick,</span>
  83 |     | <span class='neutral'>        uint128 liquidity,</span>
  84 |     | <span class='neutral'>        uint16 cardinality,</span>
  85 |     | <span class='neutral'>        uint16 cardinalityNext</span>
  86 | *   | <span class='executed'>    ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {</span>
  87 | *   | <span class='executed'>        Observation memory last = self[index];</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>        // early return if we&#39;ve already written an observation this block</span>
  90 | *   | <span class='executed'>        if (last.blockTimestamp == blockTimestamp) return (index, cardinality);</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>        // if the conditions are right, we can bump the cardinality</span>
  93 | *   | <span class='executed'>        if (cardinalityNext &gt; cardinality &amp;&amp; index == (cardinality - 1)) {</span>
  94 | *   | <span class='executed'>            cardinalityUpdated = cardinalityNext;</span>
  95 |     | <span class='neutral'>        } else {</span>
  96 | *   | <span class='executed'>            cardinalityUpdated = cardinality;</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'></span>
  99 | *   | <span class='executed'>        indexUpdated = (index + 1) % cardinalityUpdated;</span>
 100 | *   | <span class='executed'>        self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /// @notice Prepares the oracle array to store up to `next` observations</span>
 104 |     | <span class='neutral'>    /// @param self The stored oracle array</span>
 105 |     | <span class='neutral'>    /// @param current The current next cardinality of the oracle array</span>
 106 |     | <span class='neutral'>    /// @param next The proposed next cardinality which will be populated in the oracle array</span>
 107 |     | <span class='neutral'>    /// @return next The next cardinality which will be populated in the oracle array</span>
 108 | *   | <span class='executed'>    function grow(</span>
 109 |     | <span class='neutral'>        Observation[65535] storage self,</span>
 110 |     | <span class='neutral'>        uint16 current,</span>
 111 |     | <span class='neutral'>        uint16 next</span>
 112 | *   | <span class='executed'>    ) internal returns (uint16) {</span>
 113 | *   | <span class='executed'>        require(current &gt; 0, &#39;I&#39;);</span>
 114 |     | <span class='neutral'>        // no-op if the passed next value isn&#39;t greater than the current next value</span>
 115 |     | <span class='unexecuted'>        if (next &lt;= current) return current;</span>
 116 |     | <span class='neutral'>        // store in each slot to prevent fresh SSTOREs in swaps</span>
 117 |     | <span class='neutral'>        // this data will not be used because the initialized boolean is still false</span>
 118 |     | <span class='unexecuted'>        for (uint16 i = current; i &lt; next; i++) self[i].blockTimestamp = 1;</span>
 119 |     | <span class='unexecuted'>        return next;</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /// @notice comparator for 32-bit timestamps</span>
 123 |     | <span class='neutral'>    /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time</span>
 124 |     | <span class='neutral'>    /// @param time A timestamp truncated to 32 bits</span>
 125 |     | <span class='neutral'>    /// @param a A comparison timestamp from which to determine the relative position of `time`</span>
 126 |     | <span class='neutral'>    /// @param b From which to determine the relative position of `time`</span>
 127 |     | <span class='neutral'>    /// @return bool Whether `a` is chronologically &lt;= `b`</span>
 128 |     | <span class='unexecuted'>    function lte(</span>
 129 |     | <span class='neutral'>        uint32 time,</span>
 130 |     | <span class='neutral'>        uint32 a,</span>
 131 |     | <span class='neutral'>        uint32 b</span>
 132 |     | <span class='unexecuted'>    ) private pure returns (bool) {</span>
 133 |     | <span class='neutral'>        // if there hasn&#39;t been overflow, no need to adjust</span>
 134 |     | <span class='unexecuted'>        if (a &lt;= time &amp;&amp; b &lt;= time) return a &lt;= b;</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='unexecuted'>        uint256 aAdjusted = a &gt; time ? a : a + 2**32;</span>
 137 |     | <span class='unexecuted'>        uint256 bAdjusted = b &gt; time ? b : b + 2**32;</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>        return aAdjusted &lt;= bAdjusted;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.</span>
 143 |     | <span class='neutral'>    /// The result may be the same observation, or adjacent observations.</span>
 144 |     | <span class='neutral'>    /// @dev The answer must be contained in the array, used when the target is located within the stored observation</span>
 145 |     | <span class='neutral'>    /// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation</span>
 146 |     | <span class='neutral'>    /// @param self The stored oracle array</span>
 147 |     | <span class='neutral'>    /// @param time The current block.timestamp</span>
 148 |     | <span class='neutral'>    /// @param target The timestamp at which the reserved observation should be for</span>
 149 |     | <span class='neutral'>    /// @param index The index of the observation that was most recently written to the observations array</span>
 150 |     | <span class='neutral'>    /// @param cardinality The number of populated elements in the oracle array</span>
 151 |     | <span class='neutral'>    /// @return beforeOrAt The observation recorded before, or at, the target</span>
 152 |     | <span class='neutral'>    /// @return atOrAfter The observation recorded at, or after, the target</span>
 153 |     | <span class='unexecuted'>    function binarySearch(</span>
 154 |     | <span class='neutral'>        Observation[65535] storage self,</span>
 155 |     | <span class='neutral'>        uint32 time,</span>
 156 |     | <span class='neutral'>        uint32 target,</span>
 157 |     | <span class='neutral'>        uint16 index,</span>
 158 |     | <span class='neutral'>        uint16 cardinality</span>
 159 |     | <span class='unexecuted'>    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {</span>
 160 |     | <span class='unexecuted'>        uint256 l = (index + 1) % cardinality; // oldest observation</span>
 161 |     | <span class='unexecuted'>        uint256 r = l + cardinality - 1; // newest observation</span>
 162 |     | <span class='unexecuted'>        uint256 i;</span>
 163 |     | <span class='unexecuted'>        while (true) {</span>
 164 |     | <span class='unexecuted'>            i = (l + r) / 2;</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='unexecuted'>            beforeOrAt = self[i % cardinality];</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>            // we&#39;ve landed on an uninitialized tick, keep searching higher (more recently)</span>
 169 |     | <span class='unexecuted'>            if (!beforeOrAt.initialized) {</span>
 170 |     | <span class='unexecuted'>                l = i + 1;</span>
 171 |     | <span class='unexecuted'>                continue;</span>
 172 |     | <span class='neutral'>            }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='unexecuted'>            atOrAfter = self[(i + 1) % cardinality];</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='unexecuted'>            bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>            // check if we&#39;ve found the answer!</span>
 179 |     | <span class='unexecuted'>            if (targetAtOrAfter &amp;&amp; lte(time, target, atOrAfter.blockTimestamp)) break;</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='unexecuted'>            if (!targetAtOrAfter) r = i - 1;</span>
 182 |     | <span class='unexecuted'>            else l = i + 1;</span>
 183 |     | <span class='neutral'>        }</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    /// @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied</span>
 187 |     | <span class='neutral'>    /// @dev Assumes there is at least 1 initialized observation.</span>
 188 |     | <span class='neutral'>    /// Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.</span>
 189 |     | <span class='neutral'>    /// @param self The stored oracle array</span>
 190 |     | <span class='neutral'>    /// @param time The current block.timestamp</span>
 191 |     | <span class='neutral'>    /// @param target The timestamp at which the reserved observation should be for</span>
 192 |     | <span class='neutral'>    /// @param tick The active tick at the time of the returned or simulated observation</span>
 193 |     | <span class='neutral'>    /// @param index The index of the observation that was most recently written to the observations array</span>
 194 |     | <span class='neutral'>    /// @param liquidity The total pool liquidity at the time of the call</span>
 195 |     | <span class='neutral'>    /// @param cardinality The number of populated elements in the oracle array</span>
 196 |     | <span class='neutral'>    /// @return beforeOrAt The observation which occurred at, or before, the given timestamp</span>
 197 |     | <span class='neutral'>    /// @return atOrAfter The observation which occurred at, or after, the given timestamp</span>
 198 | *   | <span class='executed'>    function getSurroundingObservations(</span>
 199 |     | <span class='neutral'>        Observation[65535] storage self,</span>
 200 |     | <span class='neutral'>        uint32 time,</span>
 201 |     | <span class='neutral'>        uint32 target,</span>
 202 |     | <span class='neutral'>        int24 tick,</span>
 203 |     | <span class='neutral'>        uint16 index,</span>
 204 |     | <span class='neutral'>        uint128 liquidity,</span>
 205 |     | <span class='neutral'>        uint16 cardinality</span>
 206 | *   | <span class='executed'>    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {</span>
 207 |     | <span class='neutral'>        // optimistically set before to the newest observation</span>
 208 | *   | <span class='executed'>        beforeOrAt = self[index];</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>        // if the target is chronologically at or after the newest observation, we can early return</span>
 211 |     | <span class='unexecuted'>        if (lte(time, beforeOrAt.blockTimestamp, target)) {</span>
 212 |     | <span class='unexecuted'>            if (beforeOrAt.blockTimestamp == target) {</span>
 213 |     | <span class='neutral'>                // if newest observation equals target, we&#39;re in the same block, so we can ignore atOrAfter</span>
 214 |     | <span class='unexecuted'>                return (beforeOrAt, atOrAfter);</span>
 215 |     | <span class='neutral'>            } else {</span>
 216 |     | <span class='neutral'>                // otherwise, we need to transform</span>
 217 |     | <span class='unexecuted'>                return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));</span>
 218 |     | <span class='neutral'>            }</span>
 219 |     | <span class='neutral'>        }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>        // now, set before to the oldest observation</span>
 222 |     | <span class='unexecuted'>        beforeOrAt = self[(index + 1) % cardinality];</span>
 223 |     | <span class='unexecuted'>        if (!beforeOrAt.initialized) beforeOrAt = self[0];</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='neutral'>        // ensure that the target is chronologically at or after the oldest observation</span>
 226 |     | <span class='unexecuted'>        require(lte(time, beforeOrAt.blockTimestamp, target), &#39;OLD&#39;);</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>        // if we&#39;ve reached this point, we have to binary search</span>
 229 |     | <span class='unexecuted'>        return binarySearch(self, time, target, index, cardinality);</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='neutral'>    /// @dev Reverts if an observation at or before the desired observation timestamp does not exist.</span>
 233 |     | <span class='neutral'>    /// 0 may be passed as `secondsAgo&#39; to return the current cumulative values.</span>
 234 |     | <span class='neutral'>    /// If called with a timestamp falling between two observations, returns the counterfactual accumulator values</span>
 235 |     | <span class='neutral'>    /// at exactly the timestamp between the two observations.</span>
 236 |     | <span class='neutral'>    /// @param self The stored oracle array</span>
 237 |     | <span class='neutral'>    /// @param time The current block timestamp</span>
 238 |     | <span class='neutral'>    /// @param secondsAgo The amount of time to look back, in seconds, at which point to return an observation</span>
 239 |     | <span class='neutral'>    /// @param tick The current tick</span>
 240 |     | <span class='neutral'>    /// @param index The index of the observation that was most recently written to the observations array</span>
 241 |     | <span class='neutral'>    /// @param liquidity The current in-range pool liquidity</span>
 242 |     | <span class='neutral'>    /// @param cardinality The number of populated elements in the oracle array</span>
 243 |     | <span class='neutral'>    /// @return tickCumulative The tick * time elapsed since the pool was first initialized, as of `secondsAgo`</span>
 244 |     | <span class='neutral'>    /// @return secondsPerLiquidityCumulativeX128 The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`</span>
 245 | *   | <span class='executed'>    function observeSingle(</span>
 246 |     | <span class='neutral'>        Observation[65535] storage self,</span>
 247 |     | <span class='neutral'>        uint32 time,</span>
 248 |     | <span class='neutral'>        uint32 secondsAgo,</span>
 249 |     | <span class='neutral'>        int24 tick,</span>
 250 |     | <span class='neutral'>        uint16 index,</span>
 251 |     | <span class='neutral'>        uint128 liquidity,</span>
 252 |     | <span class='neutral'>        uint16 cardinality</span>
 253 | *   | <span class='executed'>    ) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) {</span>
 254 | *   | <span class='executed'>        if (secondsAgo == 0) {</span>
 255 | *   | <span class='executed'>            Observation memory last = self[index];</span>
 256 | *   | <span class='executed'>            if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);</span>
 257 | *   | <span class='executed'>            return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);</span>
 258 |     | <span class='neutral'>        }</span>
 259 |     | <span class='neutral'></span>
 260 | *   | <span class='executed'>        uint32 target = time - secondsAgo;</span>
 261 |     | <span class='neutral'></span>
 262 | *   | <span class='executed'>        (Observation memory beforeOrAt, Observation memory atOrAfter) =</span>
 263 | *   | <span class='executed'>            getSurroundingObservations(self, time, target, tick, index, liquidity, cardinality);</span>
 264 |     | <span class='neutral'></span>
 265 | *   | <span class='executed'>        if (target == beforeOrAt.blockTimestamp) {</span>
 266 |     | <span class='neutral'>            // we&#39;re at the left boundary</span>
 267 |     | <span class='unexecuted'>            return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);</span>
 268 |     | <span class='unexecuted'>        } else if (target == atOrAfter.blockTimestamp) {</span>
 269 |     | <span class='neutral'>            // we&#39;re at the right boundary</span>
 270 |     | <span class='unexecuted'>            return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);</span>
 271 |     | <span class='neutral'>        } else {</span>
 272 |     | <span class='neutral'>            // we&#39;re in the middle</span>
 273 |     | <span class='unexecuted'>            uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;</span>
 274 |     | <span class='unexecuted'>            uint32 targetDelta = target - beforeOrAt.blockTimestamp;</span>
 275 |     | <span class='unexecuted'>            return (</span>
 276 |     | <span class='unexecuted'>                beforeOrAt.tickCumulative +</span>
 277 |     | <span class='unexecuted'>                    ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / observationTimeDelta) *</span>
 278 |     | <span class='neutral'>                    targetDelta,</span>
 279 |     | <span class='unexecuted'>                beforeOrAt.secondsPerLiquidityCumulativeX128 +</span>
 280 |     | <span class='neutral'>                    uint160(</span>
 281 |     | <span class='unexecuted'>                        (uint256(</span>
 282 |     | <span class='unexecuted'>                            atOrAfter.secondsPerLiquidityCumulativeX128 - beforeOrAt.secondsPerLiquidityCumulativeX128</span>
 283 |     | <span class='unexecuted'>                        ) * targetDelta) / observationTimeDelta</span>
 284 |     | <span class='neutral'>                    )</span>
 285 |     | <span class='neutral'>            );</span>
 286 |     | <span class='neutral'>        }</span>
 287 |     | <span class='neutral'>    }</span>
 288 |     | <span class='neutral'></span>
 289 |     | <span class='neutral'>    /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`</span>
 290 |     | <span class='neutral'>    /// @dev Reverts if `secondsAgos` &gt; oldest observation</span>
 291 |     | <span class='neutral'>    /// @param self The stored oracle array</span>
 292 |     | <span class='neutral'>    /// @param time The current block.timestamp</span>
 293 |     | <span class='neutral'>    /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation</span>
 294 |     | <span class='neutral'>    /// @param tick The current tick</span>
 295 |     | <span class='neutral'>    /// @param index The index of the observation that was most recently written to the observations array</span>
 296 |     | <span class='neutral'>    /// @param liquidity The current in-range pool liquidity</span>
 297 |     | <span class='neutral'>    /// @param cardinality The number of populated elements in the oracle array</span>
 298 |     | <span class='neutral'>    /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`</span>
 299 |     | <span class='neutral'>    /// @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`</span>
 300 | *   | <span class='executed'>    function observe(</span>
 301 |     | <span class='neutral'>        Observation[65535] storage self,</span>
 302 |     | <span class='neutral'>        uint32 time,</span>
 303 |     | <span class='neutral'>        uint32[] memory secondsAgos,</span>
 304 |     | <span class='neutral'>        int24 tick,</span>
 305 |     | <span class='neutral'>        uint16 index,</span>
 306 |     | <span class='neutral'>        uint128 liquidity,</span>
 307 |     | <span class='neutral'>        uint16 cardinality</span>
 308 | *   | <span class='executed'>    ) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {</span>
 309 | *   | <span class='executed'>        require(cardinality &gt; 0, &#39;I&#39;);</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='unexecuted'>        tickCumulatives = new int56[](secondsAgos.length);</span>
 312 |     | <span class='unexecuted'>        secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);</span>
 313 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; secondsAgos.length; i++) {</span>
 314 |     | <span class='unexecuted'>            (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(</span>
 315 |     | <span class='unexecuted'>                self,</span>
 316 |     | <span class='unexecuted'>                time,</span>
 317 |     | <span class='unexecuted'>                secondsAgos[i],</span>
 318 |     | <span class='unexecuted'>                tick,</span>
 319 |     | <span class='unexecuted'>                index,</span>
 320 |     | <span class='unexecuted'>                liquidity,</span>
 321 |     | <span class='unexecuted'>                cardinality</span>
 322 |     | <span class='neutral'>            );</span>
 323 |     | <span class='neutral'>        }</span>
 324 |     | <span class='neutral'>    }</span>
 325 |     | <span class='neutral'>}</span>
 326 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/Position.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0 &lt;0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./FullMath.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;./FixedPoint128.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;./LiquidityMath.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/// @title Position</span>
  9 |     | <span class='neutral'>/// @notice Positions represent an owner address&#39; liquidity between a lower and upper tick boundary</span>
 10 |     | <span class='neutral'>/// @dev Positions store additional state for tracking fees owed to the position</span>
 11 |     | <span class='unexecuted'>library Position {</span>
 12 |     | <span class='neutral'>    // info stored for each user&#39;s position</span>
 13 |     | <span class='neutral'>    struct Info {</span>
 14 |     | <span class='neutral'>        // the amount of liquidity owned by this position</span>
 15 |     | <span class='neutral'>        uint128 liquidity;</span>
 16 |     | <span class='neutral'>        // fee growth per unit of liquidity as of the last update to liquidity or fees owed</span>
 17 |     | <span class='neutral'>        uint256 feeGrowthInside0LastX128;</span>
 18 |     | <span class='neutral'>        uint256 feeGrowthInside1LastX128;</span>
 19 |     | <span class='neutral'>        // the fees owed to the position owner in token0/token1</span>
 20 |     | <span class='neutral'>        uint128 tokensOwed0;</span>
 21 |     | <span class='neutral'>        uint128 tokensOwed1;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /// @notice Returns the Info struct of a position, given an owner and position boundaries</span>
 25 |     | <span class='neutral'>    /// @param self The mapping containing all user positions</span>
 26 |     | <span class='neutral'>    /// @param owner The address of the position owner</span>
 27 |     | <span class='neutral'>    /// @param tickLower The lower tick boundary of the position</span>
 28 |     | <span class='neutral'>    /// @param tickUpper The upper tick boundary of the position</span>
 29 |     | <span class='neutral'>    /// @return position The position info struct of the given owners&#39; position</span>
 30 | *   | <span class='executed'>    function get(</span>
 31 |     | <span class='neutral'>        mapping(bytes32 =&gt; Info) storage self,</span>
 32 |     | <span class='neutral'>        address owner,</span>
 33 |     | <span class='neutral'>        int24 tickLower,</span>
 34 |     | <span class='neutral'>        int24 tickUpper</span>
 35 |     | <span class='neutral'>    ) internal view returns (Position.Info storage position) {</span>
 36 | *   | <span class='executed'>        position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    /// @notice Credits accumulated fees to a user&#39;s position</span>
 40 |     | <span class='neutral'>    /// @param self The individual position to update</span>
 41 |     | <span class='neutral'>    /// @param liquidityDelta The change in pool liquidity as a result of the position update</span>
 42 |     | <span class='neutral'>    /// @param feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position&#39;s tick boundaries</span>
 43 |     | <span class='neutral'>    /// @param feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position&#39;s tick boundaries</span>
 44 | *   | <span class='executed'>    function update(</span>
 45 |     | <span class='neutral'>        Info storage self,</span>
 46 |     | <span class='neutral'>        int128 liquidityDelta,</span>
 47 |     | <span class='neutral'>        uint256 feeGrowthInside0X128,</span>
 48 |     | <span class='neutral'>        uint256 feeGrowthInside1X128</span>
 49 |     | <span class='neutral'>    ) internal {</span>
 50 | *   | <span class='executed'>        Info memory _self = self;</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>        uint128 liquidityNext;</span>
 53 | *   | <span class='executed'>        if (liquidityDelta == 0) {</span>
 54 | *   | <span class='executed'>            require(_self.liquidity &gt; 0, &#39;NP&#39;); // disallow pokes for 0 liquidity positions</span>
 55 | *   | <span class='executed'>            liquidityNext = _self.liquidity;</span>
 56 |     | <span class='neutral'>        } else {</span>
 57 |     | <span class='unexecuted'>            liquidityNext = LiquidityMath.addDelta(_self.liquidity, liquidityDelta);</span>
 58 |     | <span class='neutral'>        }</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>        // calculate accumulated fees</span>
 61 |     | <span class='unexecuted'>        uint128 tokensOwed0 =</span>
 62 |     | <span class='neutral'>            uint128(</span>
 63 |     | <span class='unexecuted'>                FullMath.mulDiv(</span>
 64 |     | <span class='unexecuted'>                    feeGrowthInside0X128 - _self.feeGrowthInside0LastX128,</span>
 65 |     | <span class='unexecuted'>                    _self.liquidity,</span>
 66 |     | <span class='neutral'>                    FixedPoint128.Q128</span>
 67 |     | <span class='neutral'>                )</span>
 68 |     | <span class='neutral'>            );</span>
 69 | *   | <span class='executed'>        uint128 tokensOwed1 =</span>
 70 |     | <span class='neutral'>            uint128(</span>
 71 | *   | <span class='executed'>                FullMath.mulDiv(</span>
 72 | *   | <span class='executed'>                    feeGrowthInside1X128 - _self.feeGrowthInside1LastX128,</span>
 73 |     | <span class='unexecuted'>                    _self.liquidity,</span>
 74 |     | <span class='neutral'>                    FixedPoint128.Q128</span>
 75 |     | <span class='neutral'>                )</span>
 76 |     | <span class='neutral'>            );</span>
 77 |     | <span class='neutral'></span>
 78 |     | <span class='neutral'>        // update the position</span>
 79 | *   | <span class='executed'>        if (liquidityDelta != 0) self.liquidity = liquidityNext;</span>
 80 | *   | <span class='executed'>        self.feeGrowthInside0LastX128 = feeGrowthInside0X128;</span>
 81 | *   | <span class='executed'>        self.feeGrowthInside1LastX128 = feeGrowthInside1X128;</span>
 82 | *   | <span class='executed'>        if (tokensOwed0 &gt; 0 || tokensOwed1 &gt; 0) {</span>
 83 |     | <span class='neutral'>            // overflow is acceptable, have to withdraw before you hit type(uint128).max fees</span>
 84 | *   | <span class='executed'>            self.tokensOwed0 += tokensOwed0;</span>
 85 | *   | <span class='executed'>            self.tokensOwed1 += tokensOwed1;</span>
 86 |     | <span class='neutral'>        }</span>
 87 |     | <span class='neutral'>    }</span>
 88 |     | <span class='neutral'>}</span>
 89 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/SafeCast.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Safe casting methods</span>
  5 |     | <span class='neutral'>/// @notice Contains methods for safely casting between types</span>
  6 |     | <span class='unexecuted'>library SafeCast {</span>
  7 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint160, revert on overflow</span>
  8 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
  9 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint160</span>
 10 | *   | <span class='executed'>    function toUint160(uint256 y) internal pure returns (uint160 z) {</span>
 11 | *   | <span class='executed'>        require((z = uint160(y)) == y);</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    /// @notice Cast a int256 to a int128, revert on overflow or underflow</span>
 15 |     | <span class='neutral'>    /// @param y The int256 to be downcasted</span>
 16 |     | <span class='neutral'>    /// @return z The downcasted integer, now type int128</span>
 17 |     | <span class='unexecuted'>    function toInt128(int256 y) internal pure returns (int128 z) {</span>
 18 |     | <span class='unexecuted'>        require((z = int128(y)) == y);</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    /// @notice Cast a uint256 to a int256, revert on overflow</span>
 22 |     | <span class='neutral'>    /// @param y The uint256 to be casted</span>
 23 |     | <span class='neutral'>    /// @return z The casted integer, now type int256</span>
 24 | *   | <span class='executed'>    function toInt256(uint256 y) internal pure returns (int256 z) {</span>
 25 | *   | <span class='executed'>        require(y &lt; 2**255);</span>
 26 | *   | <span class='executed'>        z = int256(y);</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/SqrtPriceMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./LowGasSafeMath.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./SafeCast.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &#39;./FullMath.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./UnsafeMath.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./FixedPoint96.sol&#39;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/// @title Functions based on Q64.96 sqrt price and liquidity</span>
  12 |     | <span class='neutral'>/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas</span>
  13 |     | <span class='unexecuted'>library SqrtPriceMath {</span>
  14 |     | <span class='neutral'>    using LowGasSafeMath for uint256;</span>
  15 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /// @notice Gets the next sqrt price given a delta of token0</span>
  18 |     | <span class='neutral'>    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least</span>
  19 |     | <span class='neutral'>    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the</span>
  20 |     | <span class='neutral'>    /// price less in order to not send too much output.</span>
  21 |     | <span class='neutral'>    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),</span>
  22 |     | <span class='neutral'>    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).</span>
  23 |     | <span class='neutral'>    /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta</span>
  24 |     | <span class='neutral'>    /// @param liquidity The amount of usable liquidity</span>
  25 |     | <span class='neutral'>    /// @param amount How much of token0 to add or remove from virtual reserves</span>
  26 |     | <span class='neutral'>    /// @param add Whether to add or remove the amount of token0</span>
  27 |     | <span class='neutral'>    /// @return The price after adding or removing amount, depending on add</span>
  28 |     | <span class='unexecuted'>    function getNextSqrtPriceFromAmount0RoundingUp(</span>
  29 |     | <span class='neutral'>        uint160 sqrtPX96,</span>
  30 |     | <span class='neutral'>        uint128 liquidity,</span>
  31 |     | <span class='neutral'>        uint256 amount,</span>
  32 |     | <span class='neutral'>        bool add</span>
  33 | *   | <span class='executed'>    ) internal pure returns (uint160) {</span>
  34 |     | <span class='neutral'>        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price</span>
  35 | *   | <span class='executed'>        if (amount == 0) return sqrtPX96;</span>
  36 | *   | <span class='executed'>        uint256 numerator1 = uint256(liquidity) &lt;&lt; FixedPoint96.RESOLUTION;</span>
  37 |     | <span class='neutral'></span>
  38 | *   | <span class='executed'>        if (add) {</span>
  39 |     | <span class='neutral'>            uint256 product;</span>
  40 | *   | <span class='executed'>            if ((product = amount * sqrtPX96) / amount == sqrtPX96) {</span>
  41 | *   | <span class='executed'>                uint256 denominator = numerator1 + product;</span>
  42 | *   | <span class='executed'>                if (denominator &gt;= numerator1)</span>
  43 |     | <span class='neutral'>                    // always fits in 160 bits</span>
  44 | *   | <span class='executed'>                    return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));</span>
  45 |     | <span class='neutral'>            }</span>
  46 |     | <span class='neutral'></span>
  47 | *   | <span class='executed'>            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96).add(amount)));</span>
  48 |     | <span class='neutral'>        } else {</span>
  49 |     | <span class='neutral'>            uint256 product;</span>
  50 |     | <span class='neutral'>            // if the product overflows, we know the denominator underflows</span>
  51 |     | <span class='neutral'>            // in addition, we must check that the denominator does not underflow</span>
  52 | *   | <span class='executed'>            require((product = amount * sqrtPX96) / amount == sqrtPX96 &amp;&amp; numerator1 &gt; product);</span>
  53 |     | <span class='unexecuted'>            uint256 denominator = numerator1 - product;</span>
  54 |     | <span class='unexecuted'>            return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();</span>
  55 |     | <span class='neutral'>        }</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    /// @notice Gets the next sqrt price given a delta of token1</span>
  59 |     | <span class='neutral'>    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least</span>
  60 |     | <span class='neutral'>    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the</span>
  61 |     | <span class='neutral'>    /// price less in order to not send too much output.</span>
  62 |     | <span class='neutral'>    /// The formula we compute is within &lt;1 wei of the lossless version: sqrtPX96 +- amount / liquidity</span>
  63 |     | <span class='neutral'>    /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta</span>
  64 |     | <span class='neutral'>    /// @param liquidity The amount of usable liquidity</span>
  65 |     | <span class='neutral'>    /// @param amount How much of token1 to add, or remove, from virtual reserves</span>
  66 |     | <span class='neutral'>    /// @param add Whether to add, or remove, the amount of token1</span>
  67 |     | <span class='neutral'>    /// @return The price after adding or removing `amount`</span>
  68 |     | <span class='unexecuted'>    function getNextSqrtPriceFromAmount1RoundingDown(</span>
  69 |     | <span class='neutral'>        uint160 sqrtPX96,</span>
  70 |     | <span class='neutral'>        uint128 liquidity,</span>
  71 |     | <span class='neutral'>        uint256 amount,</span>
  72 |     | <span class='neutral'>        bool add</span>
  73 |     | <span class='unexecuted'>    ) internal pure returns (uint160) {</span>
  74 |     | <span class='neutral'>        // if we&#39;re adding (subtracting), rounding down requires rounding the quotient down (up)</span>
  75 |     | <span class='neutral'>        // in both cases, avoid a mulDiv for most inputs</span>
  76 |     | <span class='unexecuted'>        if (add) {</span>
  77 |     | <span class='unexecuted'>            uint256 quotient =</span>
  78 |     | <span class='neutral'>                (</span>
  79 | *   | <span class='executed'>                    amount &lt;= type(uint160).max</span>
  80 | *   | <span class='executed'>                        ? (amount &lt;&lt; FixedPoint96.RESOLUTION) / liquidity</span>
  81 | *   | <span class='executed'>                        : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)</span>
  82 |     | <span class='neutral'>                );</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>            return uint256(sqrtPX96).add(quotient).toUint160();</span>
  85 |     | <span class='neutral'>        } else {</span>
  86 |     | <span class='unexecuted'>            uint256 quotient =</span>
  87 |     | <span class='neutral'>                (</span>
  88 |     | <span class='unexecuted'>                    amount &lt;= type(uint160).max</span>
  89 |     | <span class='unexecuted'>                        ? UnsafeMath.divRoundingUp(amount &lt;&lt; FixedPoint96.RESOLUTION, liquidity)</span>
  90 |     | <span class='unexecuted'>                        : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)</span>
  91 |     | <span class='neutral'>                );</span>
  92 |     | <span class='neutral'></span>
  93 | *   | <span class='executed'>            require(sqrtPX96 &gt; quotient);</span>
  94 |     | <span class='neutral'>            // always fits 160 bits</span>
  95 |     | <span class='unexecuted'>            return uint160(sqrtPX96 - quotient);</span>
  96 |     | <span class='neutral'>        }</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /// @notice Gets the next sqrt price given an input amount of token0 or token1</span>
 100 |     | <span class='neutral'>    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds</span>
 101 |     | <span class='neutral'>    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount</span>
 102 |     | <span class='neutral'>    /// @param liquidity The amount of usable liquidity</span>
 103 |     | <span class='neutral'>    /// @param amountIn How much of token0, or token1, is being swapped in</span>
 104 |     | <span class='neutral'>    /// @param zeroForOne Whether the amount in is token0 or token1</span>
 105 |     | <span class='neutral'>    /// @return sqrtQX96 The price after adding the input amount to token0 or token1</span>
 106 |     | <span class='unexecuted'>    function getNextSqrtPriceFromInput(</span>
 107 |     | <span class='neutral'>        uint160 sqrtPX96,</span>
 108 |     | <span class='neutral'>        uint128 liquidity,</span>
 109 |     | <span class='neutral'>        uint256 amountIn,</span>
 110 |     | <span class='neutral'>        bool zeroForOne</span>
 111 |     | <span class='unexecuted'>    ) internal pure returns (uint160 sqrtQX96) {</span>
 112 | *   | <span class='executed'>        require(sqrtPX96 &gt; 0);</span>
 113 | *   | <span class='executed'>        require(liquidity &gt; 0);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>        // round to make sure that we don&#39;t pass the target price</span>
 116 |     | <span class='neutral'>        return</span>
 117 | *   | <span class='executed'>            zeroForOne</span>
 118 | *   | <span class='executed'>                ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)</span>
 119 | *   | <span class='executed'>                : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /// @notice Gets the next sqrt price given an output amount of token0 or token1</span>
 123 |     | <span class='neutral'>    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds</span>
 124 |     | <span class='neutral'>    /// @param sqrtPX96 The starting price before accounting for the output amount</span>
 125 |     | <span class='neutral'>    /// @param liquidity The amount of usable liquidity</span>
 126 |     | <span class='neutral'>    /// @param amountOut How much of token0, or token1, is being swapped out</span>
 127 |     | <span class='neutral'>    /// @param zeroForOne Whether the amount out is token0 or token1</span>
 128 |     | <span class='neutral'>    /// @return sqrtQX96 The price after removing the output amount of token0 or token1</span>
 129 | *   | <span class='executed'>    function getNextSqrtPriceFromOutput(</span>
 130 |     | <span class='neutral'>        uint160 sqrtPX96,</span>
 131 |     | <span class='neutral'>        uint128 liquidity,</span>
 132 |     | <span class='neutral'>        uint256 amountOut,</span>
 133 |     | <span class='neutral'>        bool zeroForOne</span>
 134 | *   | <span class='executed'>    ) internal pure returns (uint160 sqrtQX96) {</span>
 135 | *   | <span class='executed'>        require(sqrtPX96 &gt; 0);</span>
 136 | *   | <span class='executed'>        require(liquidity &gt; 0);</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>        // round to make sure that we pass the target price</span>
 139 |     | <span class='neutral'>        return</span>
 140 | *   | <span class='executed'>            zeroForOne</span>
 141 | *   | <span class='executed'>                ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)</span>
 142 | *   | <span class='executed'>                : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);</span>
 143 |     | <span class='neutral'>    }</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>    /// @notice Gets the amount0 delta between two prices</span>
 146 |     | <span class='neutral'>    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),</span>
 147 |     | <span class='neutral'>    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))</span>
 148 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price</span>
 149 |     | <span class='neutral'>    /// @param sqrtRatioBX96 Another sqrt price</span>
 150 |     | <span class='neutral'>    /// @param liquidity The amount of usable liquidity</span>
 151 |     | <span class='neutral'>    /// @param roundUp Whether to round the amount up or down</span>
 152 |     | <span class='neutral'>    /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices</span>
 153 | *   | <span class='executed'>    function getAmount0Delta(</span>
 154 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
 155 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
 156 |     | <span class='neutral'>        uint128 liquidity,</span>
 157 |     | <span class='neutral'>        bool roundUp</span>
 158 | *   | <span class='executed'>    ) internal pure returns (uint256 amount0) {</span>
 159 | *   | <span class='executed'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
 160 |     | <span class='neutral'></span>
 161 | *   | <span class='executed'>        uint256 numerator1 = uint256(liquidity) &lt;&lt; FixedPoint96.RESOLUTION;</span>
 162 | *   | <span class='executed'>        uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;</span>
 163 |     | <span class='neutral'></span>
 164 | *   | <span class='executed'>        require(sqrtRatioAX96 &gt; 0);</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='unexecuted'>        return</span>
 167 | *   | <span class='executed'>            roundUp</span>
 168 | *   | <span class='executed'>                ? UnsafeMath.divRoundingUp(</span>
 169 | *   | <span class='executed'>                    FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96),</span>
 170 |     | <span class='neutral'>                    sqrtRatioAX96</span>
 171 |     | <span class='neutral'>                )</span>
 172 | *   | <span class='executed'>                : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>    /// @notice Gets the amount1 delta between two prices</span>
 176 |     | <span class='neutral'>    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))</span>
 177 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price</span>
 178 |     | <span class='neutral'>    /// @param sqrtRatioBX96 Another sqrt price</span>
 179 |     | <span class='neutral'>    /// @param liquidity The amount of usable liquidity</span>
 180 |     | <span class='neutral'>    /// @param roundUp Whether to round the amount up, or down</span>
 181 |     | <span class='neutral'>    /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices</span>
 182 | *   | <span class='executed'>    function getAmount1Delta(</span>
 183 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
 184 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
 185 |     | <span class='neutral'>        uint128 liquidity,</span>
 186 |     | <span class='neutral'>        bool roundUp</span>
 187 |     | <span class='unexecuted'>    ) internal pure returns (uint256 amount1) {</span>
 188 |     | <span class='unexecuted'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
 189 |     | <span class='neutral'></span>
 190 | *   | <span class='executed'>        return</span>
 191 | *   | <span class='executed'>            roundUp</span>
 192 | *   | <span class='executed'>                ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)</span>
 193 | *   | <span class='executed'>                : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>    /// @notice Helper that gets signed token0 delta</span>
 197 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price</span>
 198 |     | <span class='neutral'>    /// @param sqrtRatioBX96 Another sqrt price</span>
 199 |     | <span class='neutral'>    /// @param liquidity The change in liquidity for which to compute the amount0 delta</span>
 200 |     | <span class='neutral'>    /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices</span>
 201 | *   | <span class='executed'>    function getAmount0Delta(</span>
 202 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
 203 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
 204 |     | <span class='neutral'>        int128 liquidity</span>
 205 | *   | <span class='executed'>    ) internal pure returns (int256 amount0) {</span>
 206 | *   | <span class='executed'>        return</span>
 207 | *   | <span class='executed'>            liquidity &lt; 0</span>
 208 | *   | <span class='executed'>                ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()</span>
 209 | *   | <span class='executed'>                : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    /// @notice Helper that gets signed token1 delta</span>
 213 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price</span>
 214 |     | <span class='neutral'>    /// @param sqrtRatioBX96 Another sqrt price</span>
 215 |     | <span class='neutral'>    /// @param liquidity The change in liquidity for which to compute the amount1 delta</span>
 216 |     | <span class='neutral'>    /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices</span>
 217 | *   | <span class='executed'>    function getAmount1Delta(</span>
 218 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
 219 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
 220 |     | <span class='neutral'>        int128 liquidity</span>
 221 | *   | <span class='executed'>    ) internal pure returns (int256 amount1) {</span>
 222 |     | <span class='neutral'>        return</span>
 223 | *   | <span class='executed'>            liquidity &lt; 0</span>
 224 | *   | <span class='executed'>                ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()</span>
 225 | *   | <span class='executed'>                : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'>}</span>
 228 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/SwapMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./FullMath.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./SqrtPriceMath.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/// @title Computes the result of a swap within ticks</span>
   8 |     | <span class='neutral'>/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.</span>
   9 |     | <span class='unexecuted'>library SwapMath {</span>
  10 |     | <span class='neutral'>    /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap</span>
  11 |     | <span class='neutral'>    /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap&#39;s `amountSpecified` is positive</span>
  12 |     | <span class='neutral'>    /// @param sqrtRatioCurrentX96 The current sqrt price of the pool</span>
  13 |     | <span class='neutral'>    /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred</span>
  14 |     | <span class='neutral'>    /// @param liquidity The usable liquidity</span>
  15 |     | <span class='neutral'>    /// @param amountRemaining How much input or output amount is remaining to be swapped in/out</span>
  16 |     | <span class='neutral'>    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip</span>
  17 |     | <span class='neutral'>    /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target</span>
  18 |     | <span class='neutral'>    /// @return amountIn The amount to be swapped in, of either token0 or token1, based on the direction of the swap</span>
  19 |     | <span class='neutral'>    /// @return amountOut The amount to be received, of either token0 or token1, based on the direction of the swap</span>
  20 |     | <span class='neutral'>    /// @return feeAmount The amount of input that will be taken as a fee</span>
  21 | *   | <span class='executed'>    function computeSwapStep(</span>
  22 |     | <span class='neutral'>        uint160 sqrtRatioCurrentX96,</span>
  23 |     | <span class='neutral'>        uint160 sqrtRatioTargetX96,</span>
  24 |     | <span class='neutral'>        uint128 liquidity,</span>
  25 |     | <span class='neutral'>        int256 amountRemaining,</span>
  26 |     | <span class='neutral'>        uint24 feePips</span>
  27 |     | <span class='neutral'>    )</span>
  28 |     | <span class='neutral'>        internal</span>
  29 |     | <span class='neutral'>        pure</span>
  30 |     | <span class='neutral'>        returns (</span>
  31 | *   | <span class='executed'>            uint160 sqrtRatioNextX96,</span>
  32 |     | <span class='neutral'>            uint256 amountIn,</span>
  33 |     | <span class='neutral'>            uint256 amountOut,</span>
  34 |     | <span class='neutral'>            uint256 feeAmount</span>
  35 |     | <span class='neutral'>        )</span>
  36 |     | <span class='neutral'>    {</span>
  37 | *   | <span class='executed'>        bool zeroForOne = sqrtRatioCurrentX96 &gt;= sqrtRatioTargetX96;</span>
  38 | *   | <span class='executed'>        bool exactIn = amountRemaining &gt;= 0;</span>
  39 |     | <span class='neutral'></span>
  40 | *   | <span class='executed'>        if (exactIn) {</span>
  41 | *   | <span class='executed'>            uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);</span>
  42 | *   | <span class='executed'>            amountIn = zeroForOne</span>
  43 | *   | <span class='executed'>                ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)</span>
  44 | *   | <span class='executed'>                : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);</span>
  45 | *   | <span class='executed'>            if (amountRemainingLessFee &gt;= amountIn) sqrtRatioNextX96 = sqrtRatioTargetX96;</span>
  46 |     | <span class='neutral'>            else</span>
  47 | *   | <span class='executed'>                sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(</span>
  48 |     | <span class='unexecuted'>                    sqrtRatioCurrentX96,</span>
  49 |     | <span class='unexecuted'>                    liquidity,</span>
  50 |     | <span class='unexecuted'>                    amountRemainingLessFee,</span>
  51 |     | <span class='unexecuted'>                    zeroForOne</span>
  52 |     | <span class='neutral'>                );</span>
  53 |     | <span class='neutral'>        } else {</span>
  54 | *   | <span class='executed'>            amountOut = zeroForOne</span>
  55 | *   | <span class='executed'>                ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)</span>
  56 | *   | <span class='executed'>                : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);</span>
  57 | *   | <span class='executed'>            if (uint256(-amountRemaining) &gt;= amountOut) sqrtRatioNextX96 = sqrtRatioTargetX96;</span>
  58 |     | <span class='neutral'>            else</span>
  59 | *   | <span class='executed'>                sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(</span>
  60 |     | <span class='unexecuted'>                    sqrtRatioCurrentX96,</span>
  61 |     | <span class='unexecuted'>                    liquidity,</span>
  62 | *   | <span class='executed'>                    uint256(-amountRemaining),</span>
  63 | *   | <span class='executed'>                    zeroForOne</span>
  64 |     | <span class='neutral'>                );</span>
  65 |     | <span class='neutral'>        }</span>
  66 |     | <span class='neutral'></span>
  67 | *   | <span class='executed'>        bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>        // get the input/output amounts</span>
  70 | *   | <span class='executed'>        if (zeroForOne) {</span>
  71 | *   | <span class='executed'>            amountIn = max &amp;&amp; exactIn</span>
  72 | *   | <span class='executed'>                ? amountIn</span>
  73 | *   | <span class='executed'>                : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);</span>
  74 | *   | <span class='executed'>            amountOut = max &amp;&amp; !exactIn</span>
  75 | *   | <span class='executed'>                ? amountOut</span>
  76 | *   | <span class='executed'>                : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);</span>
  77 |     | <span class='neutral'>        } else {</span>
  78 | *   | <span class='executed'>            amountIn = max &amp;&amp; exactIn</span>
  79 | *   | <span class='executed'>                ? amountIn</span>
  80 | *   | <span class='executed'>                : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);</span>
  81 | *   | <span class='executed'>            amountOut = max &amp;&amp; !exactIn</span>
  82 |     | <span class='unexecuted'>                ? amountOut</span>
  83 |     | <span class='unexecuted'>                : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);</span>
  84 |     | <span class='neutral'>        }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>        // cap the output amount to not exceed the remaining output amount</span>
  87 |     | <span class='unexecuted'>        if (!exactIn &amp;&amp; amountOut &gt; uint256(-amountRemaining)) {</span>
  88 |     | <span class='unexecuted'>            amountOut = uint256(-amountRemaining);</span>
  89 |     | <span class='neutral'>        }</span>
  90 |     | <span class='neutral'></span>
  91 | *   | <span class='executed'>        if (exactIn &amp;&amp; sqrtRatioNextX96 != sqrtRatioTargetX96) {</span>
  92 |     | <span class='neutral'>            // we didn&#39;t reach the target, so take the remainder of the maximum input as fee</span>
  93 | *   | <span class='executed'>            feeAmount = uint256(amountRemaining) - amountIn;</span>
  94 |     | <span class='neutral'>        } else {</span>
  95 | *   | <span class='executed'>            feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);</span>
  96 |     | <span class='neutral'>        }</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'>}</span>
  99 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/Tick.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0 &lt;0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./LowGasSafeMath.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./SafeCast.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &#39;./TickMath.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./LiquidityMath.sol&#39;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/// @title Tick</span>
  11 |     | <span class='neutral'>/// @notice Contains functions for managing tick processes and relevant calculations</span>
  12 |     | <span class='unexecuted'>library Tick {</span>
  13 |     | <span class='neutral'>    using LowGasSafeMath for int256;</span>
  14 |     | <span class='neutral'>    using SafeCast for int256;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    // info stored for each initialized individual tick</span>
  17 |     | <span class='neutral'>    struct Info {</span>
  18 |     | <span class='neutral'>        // the total position liquidity that references this tick</span>
  19 |     | <span class='neutral'>        uint128 liquidityGross;</span>
  20 |     | <span class='neutral'>        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),</span>
  21 |     | <span class='neutral'>        int128 liquidityNet;</span>
  22 |     | <span class='neutral'>        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)</span>
  23 |     | <span class='neutral'>        // only has relative meaning, not absolute  the value depends on when the tick is initialized</span>
  24 |     | <span class='neutral'>        uint256 feeGrowthOutside0X128;</span>
  25 |     | <span class='neutral'>        uint256 feeGrowthOutside1X128;</span>
  26 |     | <span class='neutral'>        // the cumulative tick value on the other side of the tick</span>
  27 |     | <span class='neutral'>        int56 tickCumulativeOutside;</span>
  28 |     | <span class='neutral'>        // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)</span>
  29 |     | <span class='neutral'>        // only has relative meaning, not absolute  the value depends on when the tick is initialized</span>
  30 |     | <span class='neutral'>        uint160 secondsPerLiquidityOutsideX128;</span>
  31 |     | <span class='neutral'>        // the seconds spent on the other side of the tick (relative to the current tick)</span>
  32 |     | <span class='neutral'>        // only has relative meaning, not absolute  the value depends on when the tick is initialized</span>
  33 |     | <span class='neutral'>        uint32 secondsOutside;</span>
  34 |     | <span class='neutral'>        // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0</span>
  35 |     | <span class='neutral'>        // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks</span>
  36 |     | <span class='neutral'>        bool initialized;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /// @notice Derives max liquidity per tick from given tick spacing</span>
  40 |     | <span class='neutral'>    /// @dev Executed within the pool constructor</span>
  41 |     | <span class='neutral'>    /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`</span>
  42 |     | <span class='neutral'>    ///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...</span>
  43 |     | <span class='neutral'>    /// @return The max liquidity per tick</span>
  44 | *   | <span class='executed'>    function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) {</span>
  45 | *   | <span class='executed'>        int24 minTick = (TickMath.MIN_TICK / tickSpacing) * tickSpacing;</span>
  46 | *   | <span class='executed'>        int24 maxTick = (TickMath.MAX_TICK / tickSpacing) * tickSpacing;</span>
  47 |     | <span class='unexecuted'>        uint24 numTicks = uint24((maxTick - minTick) / tickSpacing) + 1;</span>
  48 |     | <span class='unexecuted'>        return type(uint128).max / numTicks;</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    /// @notice Retrieves fee growth data</span>
  52 |     | <span class='neutral'>    /// @param self The mapping containing all tick information for initialized ticks</span>
  53 |     | <span class='neutral'>    /// @param tickLower The lower tick boundary of the position</span>
  54 |     | <span class='neutral'>    /// @param tickUpper The upper tick boundary of the position</span>
  55 |     | <span class='neutral'>    /// @param tickCurrent The current tick</span>
  56 |     | <span class='neutral'>    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0</span>
  57 |     | <span class='neutral'>    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1</span>
  58 |     | <span class='neutral'>    /// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position&#39;s tick boundaries</span>
  59 |     | <span class='neutral'>    /// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position&#39;s tick boundaries</span>
  60 | *   | <span class='executed'>    function getFeeGrowthInside(</span>
  61 |     | <span class='neutral'>        mapping(int24 =&gt; Tick.Info) storage self,</span>
  62 |     | <span class='neutral'>        int24 tickLower,</span>
  63 |     | <span class='neutral'>        int24 tickUpper,</span>
  64 |     | <span class='neutral'>        int24 tickCurrent,</span>
  65 |     | <span class='neutral'>        uint256 feeGrowthGlobal0X128,</span>
  66 |     | <span class='neutral'>        uint256 feeGrowthGlobal1X128</span>
  67 | *   | <span class='executed'>    ) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {</span>
  68 | *   | <span class='executed'>        Info storage lower = self[tickLower];</span>
  69 | *   | <span class='executed'>        Info storage upper = self[tickUpper];</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>        // calculate fee growth below</span>
  72 |     | <span class='neutral'>        uint256 feeGrowthBelow0X128;</span>
  73 |     | <span class='neutral'>        uint256 feeGrowthBelow1X128;</span>
  74 | *   | <span class='executed'>        if (tickCurrent &gt;= tickLower) {</span>
  75 | *   | <span class='executed'>            feeGrowthBelow0X128 = lower.feeGrowthOutside0X128;</span>
  76 | *   | <span class='executed'>            feeGrowthBelow1X128 = lower.feeGrowthOutside1X128;</span>
  77 |     | <span class='neutral'>        } else {</span>
  78 | *   | <span class='executed'>            feeGrowthBelow0X128 = feeGrowthGlobal0X128 - lower.feeGrowthOutside0X128;</span>
  79 | *   | <span class='executed'>            feeGrowthBelow1X128 = feeGrowthGlobal1X128 - lower.feeGrowthOutside1X128;</span>
  80 |     | <span class='neutral'>        }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>        // calculate fee growth above</span>
  83 | *   | <span class='executed'>        uint256 feeGrowthAbove0X128;</span>
  84 | *   | <span class='executed'>        uint256 feeGrowthAbove1X128;</span>
  85 | *   | <span class='executed'>        if (tickCurrent &lt; tickUpper) {</span>
  86 | *   | <span class='executed'>            feeGrowthAbove0X128 = upper.feeGrowthOutside0X128;</span>
  87 | *   | <span class='executed'>            feeGrowthAbove1X128 = upper.feeGrowthOutside1X128;</span>
  88 |     | <span class='neutral'>        } else {</span>
  89 | *   | <span class='executed'>            feeGrowthAbove0X128 = feeGrowthGlobal0X128 - upper.feeGrowthOutside0X128;</span>
  90 | *   | <span class='executed'>            feeGrowthAbove1X128 = feeGrowthGlobal1X128 - upper.feeGrowthOutside1X128;</span>
  91 |     | <span class='neutral'>        }</span>
  92 |     | <span class='neutral'></span>
  93 | *   | <span class='executed'>        feeGrowthInside0X128 = feeGrowthGlobal0X128 - feeGrowthBelow0X128 - feeGrowthAbove0X128;</span>
  94 | *   | <span class='executed'>        feeGrowthInside1X128 = feeGrowthGlobal1X128 - feeGrowthBelow1X128 - feeGrowthAbove1X128;</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa</span>
  98 |     | <span class='neutral'>    /// @param self The mapping containing all tick information for initialized ticks</span>
  99 |     | <span class='neutral'>    /// @param tick The tick that will be updated</span>
 100 |     | <span class='neutral'>    /// @param tickCurrent The current tick</span>
 101 |     | <span class='neutral'>    /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)</span>
 102 |     | <span class='neutral'>    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0</span>
 103 |     | <span class='neutral'>    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1</span>
 104 |     | <span class='neutral'>    /// @param secondsPerLiquidityCumulativeX128 The all-time seconds per max(1, liquidity) of the pool</span>
 105 |     | <span class='neutral'>    /// @param tickCumulative The tick * time elapsed since the pool was first initialized</span>
 106 |     | <span class='neutral'>    /// @param time The current block timestamp cast to a uint32</span>
 107 |     | <span class='neutral'>    /// @param upper true for updating a position&#39;s upper tick, or false for updating a position&#39;s lower tick</span>
 108 |     | <span class='neutral'>    /// @param maxLiquidity The maximum liquidity allocation for a single tick</span>
 109 |     | <span class='neutral'>    /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa</span>
 110 | *   | <span class='executed'>    function update(</span>
 111 |     | <span class='neutral'>        mapping(int24 =&gt; Tick.Info) storage self,</span>
 112 |     | <span class='neutral'>        int24 tick,</span>
 113 |     | <span class='neutral'>        int24 tickCurrent,</span>
 114 |     | <span class='neutral'>        int128 liquidityDelta,</span>
 115 |     | <span class='neutral'>        uint256 feeGrowthGlobal0X128,</span>
 116 |     | <span class='neutral'>        uint256 feeGrowthGlobal1X128,</span>
 117 |     | <span class='neutral'>        uint160 secondsPerLiquidityCumulativeX128,</span>
 118 |     | <span class='neutral'>        int56 tickCumulative,</span>
 119 |     | <span class='neutral'>        uint32 time,</span>
 120 |     | <span class='neutral'>        bool upper,</span>
 121 |     | <span class='neutral'>        uint128 maxLiquidity</span>
 122 |     | <span class='unexecuted'>    ) internal returns (bool flipped) {</span>
 123 |     | <span class='unexecuted'>        Tick.Info storage info = self[tick];</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>        uint128 liquidityGrossBefore = info.liquidityGross;</span>
 126 |     | <span class='unexecuted'>        uint128 liquidityGrossAfter = LiquidityMath.addDelta(liquidityGrossBefore, liquidityDelta);</span>
 127 |     | <span class='neutral'></span>
 128 | *   | <span class='executed'>        require(liquidityGrossAfter &lt;= maxLiquidity, &#39;LO&#39;);</span>
 129 |     | <span class='neutral'></span>
 130 | *   | <span class='executed'>        flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);</span>
 131 |     | <span class='neutral'></span>
 132 | *   | <span class='executed'>        if (liquidityGrossBefore == 0) {</span>
 133 |     | <span class='neutral'>            // by convention, we assume that all growth before a tick was initialized happened _below_ the tick</span>
 134 | *   | <span class='executed'>            if (tick &lt;= tickCurrent) {</span>
 135 |     | <span class='unexecuted'>                info.feeGrowthOutside0X128 = feeGrowthGlobal0X128;</span>
 136 |     | <span class='unexecuted'>                info.feeGrowthOutside1X128 = feeGrowthGlobal1X128;</span>
 137 | *   | <span class='executed'>                info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128;</span>
 138 | *   | <span class='executed'>                info.tickCumulativeOutside = tickCumulative;</span>
 139 | *   | <span class='executed'>                info.secondsOutside = time;</span>
 140 |     | <span class='neutral'>            }</span>
 141 | *   | <span class='executed'>            info.initialized = true;</span>
 142 |     | <span class='neutral'>        }</span>
 143 |     | <span class='neutral'></span>
 144 | *   | <span class='executed'>        info.liquidityGross = liquidityGrossAfter;</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>        // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)</span>
 147 | *   | <span class='executed'>        info.liquidityNet = upper</span>
 148 | *   | <span class='executed'>            ? int256(info.liquidityNet).sub(liquidityDelta).toInt128()</span>
 149 | *   | <span class='executed'>            : int256(info.liquidityNet).add(liquidityDelta).toInt128();</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    /// @notice Clears tick data</span>
 153 |     | <span class='neutral'>    /// @param self The mapping containing all initialized tick information for initialized ticks</span>
 154 |     | <span class='neutral'>    /// @param tick The tick that will be cleared</span>
 155 | *   | <span class='executed'>    function clear(mapping(int24 =&gt; Tick.Info) storage self, int24 tick) internal {</span>
 156 | *   | <span class='executed'>        delete self[tick];</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    /// @notice Transitions to next tick as needed by price movement</span>
 160 |     | <span class='neutral'>    /// @param self The mapping containing all tick information for initialized ticks</span>
 161 |     | <span class='neutral'>    /// @param tick The destination tick of the transition</span>
 162 |     | <span class='neutral'>    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0</span>
 163 |     | <span class='neutral'>    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1</span>
 164 |     | <span class='neutral'>    /// @param secondsPerLiquidityCumulativeX128 The current seconds per liquidity</span>
 165 |     | <span class='neutral'>    /// @param tickCumulative The tick * time elapsed since the pool was first initialized</span>
 166 |     | <span class='neutral'>    /// @param time The current block.timestamp</span>
 167 |     | <span class='neutral'>    /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)</span>
 168 | *   | <span class='executed'>    function cross(</span>
 169 |     | <span class='neutral'>        mapping(int24 =&gt; Tick.Info) storage self,</span>
 170 |     | <span class='neutral'>        int24 tick,</span>
 171 |     | <span class='neutral'>        uint256 feeGrowthGlobal0X128,</span>
 172 |     | <span class='neutral'>        uint256 feeGrowthGlobal1X128,</span>
 173 |     | <span class='neutral'>        uint160 secondsPerLiquidityCumulativeX128,</span>
 174 |     | <span class='neutral'>        int56 tickCumulative,</span>
 175 |     | <span class='neutral'>        uint32 time</span>
 176 |     | <span class='unexecuted'>    ) internal returns (int128 liquidityNet) {</span>
 177 | *   | <span class='executed'>        Tick.Info storage info = self[tick];</span>
 178 | *   | <span class='executed'>        info.feeGrowthOutside0X128 = feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;</span>
 179 | *   | <span class='executed'>        info.feeGrowthOutside1X128 = feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;</span>
 180 | *   | <span class='executed'>        info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128 - info.secondsPerLiquidityOutsideX128;</span>
 181 | *   | <span class='executed'>        info.tickCumulativeOutside = tickCumulative - info.tickCumulativeOutside;</span>
 182 | *   | <span class='executed'>        info.secondsOutside = time - info.secondsOutside;</span>
 183 | *   | <span class='executed'>        liquidityNet = info.liquidityNet;</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'>}</span>
 186 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/TickBitmap.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./BitMath.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @title Packed tick initialized state library</span>
  7 |     | <span class='neutral'>/// @notice Stores a packed mapping of tick index to its initialized state</span>
  8 |     | <span class='neutral'>/// @dev The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.</span>
  9 |     | <span class='unexecuted'>library TickBitmap {</span>
 10 |     | <span class='neutral'>    /// @notice Computes the position in the mapping where the initialized bit for a tick lives</span>
 11 |     | <span class='neutral'>    /// @param tick The tick for which to compute the position</span>
 12 |     | <span class='neutral'>    /// @return wordPos The key in the mapping containing the word in which the bit is stored</span>
 13 |     | <span class='neutral'>    /// @return bitPos The bit position in the word where the flag is stored</span>
 14 | *   | <span class='executed'>    function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {</span>
 15 | *   | <span class='executed'>        wordPos = int16(tick &gt;&gt; 8);</span>
 16 | *   | <span class='executed'>        bitPos = uint8(tick % 256);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /// @notice Flips the initialized state for a given tick from false to true, or vice versa</span>
 20 |     | <span class='neutral'>    /// @param self The mapping in which to flip the tick</span>
 21 |     | <span class='neutral'>    /// @param tick The tick to flip</span>
 22 |     | <span class='neutral'>    /// @param tickSpacing The spacing between usable ticks</span>
 23 | *   | <span class='executed'>    function flipTick(</span>
 24 |     | <span class='neutral'>        mapping(int16 =&gt; uint256) storage self,</span>
 25 |     | <span class='neutral'>        int24 tick,</span>
 26 |     | <span class='neutral'>        int24 tickSpacing</span>
 27 |     | <span class='neutral'>    ) internal {</span>
 28 | *   | <span class='executed'>        require(tick % tickSpacing == 0); // ensure that the tick is spaced</span>
 29 | *   | <span class='executed'>        (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);</span>
 30 | *   | <span class='executed'>        uint256 mask = 1 &lt;&lt; bitPos;</span>
 31 | *   | <span class='executed'>        self[wordPos] ^= mask;</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either</span>
 35 |     | <span class='neutral'>    /// to the left (less than or equal to) or right (greater than) of the given tick</span>
 36 |     | <span class='neutral'>    /// @param self The mapping in which to compute the next initialized tick</span>
 37 |     | <span class='neutral'>    /// @param tick The starting tick</span>
 38 |     | <span class='neutral'>    /// @param tickSpacing The spacing between usable ticks</span>
 39 |     | <span class='neutral'>    /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)</span>
 40 |     | <span class='neutral'>    /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick</span>
 41 |     | <span class='neutral'>    /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks</span>
 42 | *   | <span class='executed'>    function nextInitializedTickWithinOneWord(</span>
 43 |     | <span class='neutral'>        mapping(int16 =&gt; uint256) storage self,</span>
 44 |     | <span class='neutral'>        int24 tick,</span>
 45 |     | <span class='neutral'>        int24 tickSpacing,</span>
 46 |     | <span class='neutral'>        bool lte</span>
 47 | *   | <span class='executed'>    ) internal view returns (int24 next, bool initialized) {</span>
 48 | *   | <span class='executed'>        int24 compressed = tick / tickSpacing;</span>
 49 | *   | <span class='executed'>        if (tick &lt; 0 &amp;&amp; tick % tickSpacing != 0) compressed--; // round towards negative infinity</span>
 50 |     | <span class='neutral'></span>
 51 | *   | <span class='executed'>        if (lte) {</span>
 52 | *   | <span class='executed'>            (int16 wordPos, uint8 bitPos) = position(compressed);</span>
 53 |     | <span class='neutral'>            // all the 1s at or to the right of the current bitPos</span>
 54 | *   | <span class='executed'>            uint256 mask = (1 &lt;&lt; bitPos) - 1 + (1 &lt;&lt; bitPos);</span>
 55 | *   | <span class='executed'>            uint256 masked = self[wordPos] &amp; mask;</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>            // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word</span>
 58 | *   | <span class='executed'>            initialized = masked != 0;</span>
 59 |     | <span class='neutral'>            // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick</span>
 60 | *   | <span class='executed'>            next = initialized</span>
 61 | *   | <span class='executed'>                ? (compressed - int24(bitPos - BitMath.mostSignificantBit(masked))) * tickSpacing</span>
 62 | *   | <span class='executed'>                : (compressed - int24(bitPos)) * tickSpacing;</span>
 63 |     | <span class='neutral'>        } else {</span>
 64 |     | <span class='neutral'>            // start from the word of the next tick, since the current tick state doesn&#39;t matter</span>
 65 | *   | <span class='executed'>            (int16 wordPos, uint8 bitPos) = position(compressed + 1);</span>
 66 |     | <span class='neutral'>            // all the 1s at or to the left of the bitPos</span>
 67 | *   | <span class='executed'>            uint256 mask = ~((1 &lt;&lt; bitPos) - 1);</span>
 68 |     | <span class='unexecuted'>            uint256 masked = self[wordPos] &amp; mask;</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='neutral'>            // if there are no initialized ticks to the left of the current tick, return leftmost in the word</span>
 71 |     | <span class='unexecuted'>            initialized = masked != 0;</span>
 72 |     | <span class='neutral'>            // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick</span>
 73 |     | <span class='unexecuted'>            next = initialized</span>
 74 |     | <span class='unexecuted'>                ? (compressed + 1 + int24(BitMath.leastSignificantBit(masked) - bitPos)) * tickSpacing</span>
 75 |     | <span class='unexecuted'>                : (compressed + 1 + int24(type(uint8).max - bitPos)) * tickSpacing;</span>
 76 |     | <span class='neutral'>        }</span>
 77 |     | <span class='neutral'>    }</span>
 78 |     | <span class='neutral'>}</span>
 79 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/TickMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0 &lt;0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Math library for computing sqrt prices from ticks and vice versa</span>
   5 |     | <span class='neutral'>/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports</span>
   6 |     | <span class='neutral'>/// prices between 2**-128 and 2**128</span>
   7 |     | <span class='unexecuted'>library TickMath {</span>
   8 |     | <span class='neutral'>    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128</span>
   9 |     | <span class='neutral'>    int24 internal constant MIN_TICK = -887272;</span>
  10 |     | <span class='neutral'>    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128</span>
  11 | *   | <span class='executed'>    int24 internal constant MAX_TICK = -MIN_TICK;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)</span>
  14 | *   | <span class='executed'>    uint160 internal constant MIN_SQRT_RATIO = 4295128739;</span>
  15 |     | <span class='neutral'>    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)</span>
  16 | *   | <span class='executed'>    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    /// @notice Calculates sqrt(1.0001^tick) * 2^96</span>
  19 |     | <span class='neutral'>    /// @dev Throws if |tick| &gt; max tick</span>
  20 |     | <span class='neutral'>    /// @param tick The input tick for the above formula</span>
  21 |     | <span class='neutral'>    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)</span>
  22 |     | <span class='neutral'>    /// at the given tick</span>
  23 | *   | <span class='executed'>    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {</span>
  24 | *   | <span class='executed'>        uint256 absTick = tick &lt; 0 ? uint256(-int256(tick)) : uint256(int256(tick));</span>
  25 | *   | <span class='executed'>        require(absTick &lt;= uint256(MAX_TICK), &#39;T&#39;);</span>
  26 |     | <span class='neutral'></span>
  27 | *   | <span class='executed'>        uint256 ratio = absTick &amp; 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;</span>
  28 | *   | <span class='executed'>        if (absTick &amp; 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) &gt;&gt; 128;</span>
  29 | *   | <span class='executed'>        if (absTick &amp; 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) &gt;&gt; 128;</span>
  30 | *   | <span class='executed'>        if (absTick &amp; 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) &gt;&gt; 128;</span>
  31 | *   | <span class='executed'>        if (absTick &amp; 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) &gt;&gt; 128;</span>
  32 | *   | <span class='executed'>        if (absTick &amp; 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) &gt;&gt; 128;</span>
  33 | *   | <span class='executed'>        if (absTick &amp; 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) &gt;&gt; 128;</span>
  34 | *   | <span class='executed'>        if (absTick &amp; 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) &gt;&gt; 128;</span>
  35 | *   | <span class='executed'>        if (absTick &amp; 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) &gt;&gt; 128;</span>
  36 | *   | <span class='executed'>        if (absTick &amp; 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) &gt;&gt; 128;</span>
  37 | *   | <span class='executed'>        if (absTick &amp; 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) &gt;&gt; 128;</span>
  38 | *   | <span class='executed'>        if (absTick &amp; 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) &gt;&gt; 128;</span>
  39 | *   | <span class='executed'>        if (absTick &amp; 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) &gt;&gt; 128;</span>
  40 | *   | <span class='executed'>        if (absTick &amp; 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) &gt;&gt; 128;</span>
  41 | *   | <span class='executed'>        if (absTick &amp; 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) &gt;&gt; 128;</span>
  42 | *   | <span class='executed'>        if (absTick &amp; 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) &gt;&gt; 128;</span>
  43 | *   | <span class='executed'>        if (absTick &amp; 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) &gt;&gt; 128;</span>
  44 | *   | <span class='executed'>        if (absTick &amp; 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) &gt;&gt; 128;</span>
  45 | *   | <span class='executed'>        if (absTick &amp; 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) &gt;&gt; 128;</span>
  46 | *   | <span class='executed'>        if (absTick &amp; 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) &gt;&gt; 128;</span>
  47 |     | <span class='neutral'></span>
  48 | *   | <span class='executed'>        if (tick &gt; 0) ratio = type(uint256).max / ratio;</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>        // this divides by 1&lt;&lt;32 rounding up to go from a Q128.128 to a Q128.96.</span>
  51 |     | <span class='neutral'>        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint</span>
  52 |     | <span class='neutral'>        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent</span>
  53 | *   | <span class='executed'>        sqrtPriceX96 = uint160((ratio &gt;&gt; 32) + (ratio % (1 &lt;&lt; 32) == 0 ? 0 : 1));</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) &lt;= ratio</span>
  57 |     | <span class='neutral'>    /// @dev Throws in case sqrtPriceX96 &lt; MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may</span>
  58 |     | <span class='neutral'>    /// ever return.</span>
  59 |     | <span class='neutral'>    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96</span>
  60 |     | <span class='neutral'>    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio</span>
  61 | *   | <span class='executed'>    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {</span>
  62 |     | <span class='neutral'>        // second inequality must be &lt; because the price can never reach the price at the max tick</span>
  63 | *   | <span class='executed'>        require(sqrtPriceX96 &gt;= MIN_SQRT_RATIO &amp;&amp; sqrtPriceX96 &lt; MAX_SQRT_RATIO, &#39;R&#39;);</span>
  64 |     | <span class='unexecuted'>        uint256 ratio = uint256(sqrtPriceX96) &lt;&lt; 32;</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>        uint256 r = ratio;</span>
  67 |     | <span class='neutral'>        uint256 msb = 0;</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>        assembly {</span>
  70 |     | <span class='unexecuted'>            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))</span>
  71 |     | <span class='neutral'>            msb := or(msb, f)</span>
  72 |     | <span class='unexecuted'>            r := shr(f, r)</span>
  73 |     | <span class='neutral'>        }</span>
  74 |     | <span class='neutral'>        assembly {</span>
  75 |     | <span class='unexecuted'>            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))</span>
  76 | *   | <span class='executed'>            msb := or(msb, f)</span>
  77 |     | <span class='unexecuted'>            r := shr(f, r)</span>
  78 |     | <span class='neutral'>        }</span>
  79 |     | <span class='neutral'>        assembly {</span>
  80 | *   | <span class='executed'>            let f := shl(5, gt(r, 0xFFFFFFFF))</span>
  81 | *   | <span class='executed'>            msb := or(msb, f)</span>
  82 | *   | <span class='executed'>            r := shr(f, r)</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='neutral'>        assembly {</span>
  85 | *   | <span class='executed'>            let f := shl(4, gt(r, 0xFFFF))</span>
  86 | *   | <span class='executed'>            msb := or(msb, f)</span>
  87 | *   | <span class='executed'>            r := shr(f, r)</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'>        assembly {</span>
  90 | *   | <span class='executed'>            let f := shl(3, gt(r, 0xFF))</span>
  91 | *   | <span class='executed'>            msb := or(msb, f)</span>
  92 | *   | <span class='executed'>            r := shr(f, r)</span>
  93 |     | <span class='neutral'>        }</span>
  94 |     | <span class='neutral'>        assembly {</span>
  95 | *   | <span class='executed'>            let f := shl(2, gt(r, 0xF))</span>
  96 | *   | <span class='executed'>            msb := or(msb, f)</span>
  97 | *   | <span class='executed'>            r := shr(f, r)</span>
  98 |     | <span class='neutral'>        }</span>
  99 |     | <span class='neutral'>        assembly {</span>
 100 | *   | <span class='executed'>            let f := shl(1, gt(r, 0x3))</span>
 101 | *   | <span class='executed'>            msb := or(msb, f)</span>
 102 | *   | <span class='executed'>            r := shr(f, r)</span>
 103 |     | <span class='neutral'>        }</span>
 104 |     | <span class='neutral'>        assembly {</span>
 105 | *   | <span class='executed'>            let f := gt(r, 0x1)</span>
 106 | *   | <span class='executed'>            msb := or(msb, f)</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='neutral'></span>
 109 | *   | <span class='executed'>        if (msb &gt;= 128) r = ratio &gt;&gt; (msb - 127);</span>
 110 | *   | <span class='executed'>        else r = ratio &lt;&lt; (127 - msb);</span>
 111 |     | <span class='neutral'></span>
 112 | *   | <span class='executed'>        int256 log_2 = (int256(msb) - 128) &lt;&lt; 64;</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>        assembly {</span>
 115 | *   | <span class='executed'>            r := shr(127, mul(r, r))</span>
 116 | *   | <span class='executed'>            let f := shr(128, r)</span>
 117 | *   | <span class='executed'>            log_2 := or(log_2, shl(63, f))</span>
 118 | *   | <span class='executed'>            r := shr(f, r)</span>
 119 |     | <span class='neutral'>        }</span>
 120 |     | <span class='neutral'>        assembly {</span>
 121 | *   | <span class='executed'>            r := shr(127, mul(r, r))</span>
 122 | *   | <span class='executed'>            let f := shr(128, r)</span>
 123 | *   | <span class='executed'>            log_2 := or(log_2, shl(62, f))</span>
 124 | *   | <span class='executed'>            r := shr(f, r)</span>
 125 |     | <span class='neutral'>        }</span>
 126 |     | <span class='neutral'>        assembly {</span>
 127 | *   | <span class='executed'>            r := shr(127, mul(r, r))</span>
 128 | *   | <span class='executed'>            let f := shr(128, r)</span>
 129 | *   | <span class='executed'>            log_2 := or(log_2, shl(61, f))</span>
 130 | *   | <span class='executed'>            r := shr(f, r)</span>
 131 |     | <span class='neutral'>        }</span>
 132 |     | <span class='neutral'>        assembly {</span>
 133 | *   | <span class='executed'>            r := shr(127, mul(r, r))</span>
 134 | *   | <span class='executed'>            let f := shr(128, r)</span>
 135 | *   | <span class='executed'>            log_2 := or(log_2, shl(60, f))</span>
 136 | *   | <span class='executed'>            r := shr(f, r)</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='neutral'>        assembly {</span>
 139 | *   | <span class='executed'>            r := shr(127, mul(r, r))</span>
 140 | *   | <span class='executed'>            let f := shr(128, r)</span>
 141 | *   | <span class='executed'>            log_2 := or(log_2, shl(59, f))</span>
 142 | *   | <span class='executed'>            r := shr(f, r)</span>
 143 |     | <span class='neutral'>        }</span>
 144 |     | <span class='neutral'>        assembly {</span>
 145 | *   | <span class='executed'>            r := shr(127, mul(r, r))</span>
 146 | *   | <span class='executed'>            let f := shr(128, r)</span>
 147 | *   | <span class='executed'>            log_2 := or(log_2, shl(58, f))</span>
 148 | *   | <span class='executed'>            r := shr(f, r)</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='neutral'>        assembly {</span>
 151 | *   | <span class='executed'>            r := shr(127, mul(r, r))</span>
 152 | *   | <span class='executed'>            let f := shr(128, r)</span>
 153 | *   | <span class='executed'>            log_2 := or(log_2, shl(57, f))</span>
 154 | *   | <span class='executed'>            r := shr(f, r)</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='neutral'>        assembly {</span>
 157 | *   | <span class='executed'>            r := shr(127, mul(r, r))</span>
 158 | *   | <span class='executed'>            let f := shr(128, r)</span>
 159 | *   | <span class='executed'>            log_2 := or(log_2, shl(56, f))</span>
 160 | *   | <span class='executed'>            r := shr(f, r)</span>
 161 |     | <span class='neutral'>        }</span>
 162 |     | <span class='neutral'>        assembly {</span>
 163 | *   | <span class='executed'>            r := shr(127, mul(r, r))</span>
 164 | *   | <span class='executed'>            let f := shr(128, r)</span>
 165 | *   | <span class='executed'>            log_2 := or(log_2, shl(55, f))</span>
 166 | *   | <span class='executed'>            r := shr(f, r)</span>
 167 |     | <span class='neutral'>        }</span>
 168 |     | <span class='neutral'>        assembly {</span>
 169 | *   | <span class='executed'>            r := shr(127, mul(r, r))</span>
 170 | *   | <span class='executed'>            let f := shr(128, r)</span>
 171 | *   | <span class='executed'>            log_2 := or(log_2, shl(54, f))</span>
 172 | *   | <span class='executed'>            r := shr(f, r)</span>
 173 |     | <span class='neutral'>        }</span>
 174 |     | <span class='neutral'>        assembly {</span>
 175 | *   | <span class='executed'>            r := shr(127, mul(r, r))</span>
 176 | *   | <span class='executed'>            let f := shr(128, r)</span>
 177 | *   | <span class='executed'>            log_2 := or(log_2, shl(53, f))</span>
 178 | *   | <span class='executed'>            r := shr(f, r)</span>
 179 |     | <span class='neutral'>        }</span>
 180 |     | <span class='neutral'>        assembly {</span>
 181 | *   | <span class='executed'>            r := shr(127, mul(r, r))</span>
 182 | *   | <span class='executed'>            let f := shr(128, r)</span>
 183 | *   | <span class='executed'>            log_2 := or(log_2, shl(52, f))</span>
 184 | *   | <span class='executed'>            r := shr(f, r)</span>
 185 |     | <span class='neutral'>        }</span>
 186 |     | <span class='neutral'>        assembly {</span>
 187 | *   | <span class='executed'>            r := shr(127, mul(r, r))</span>
 188 | *   | <span class='executed'>            let f := shr(128, r)</span>
 189 | *   | <span class='executed'>            log_2 := or(log_2, shl(51, f))</span>
 190 | *   | <span class='executed'>            r := shr(f, r)</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='neutral'>        assembly {</span>
 193 | *   | <span class='executed'>            r := shr(127, mul(r, r))</span>
 194 |     | <span class='neutral'>            let f := shr(128, r)</span>
 195 | *   | <span class='executed'>            log_2 := or(log_2, shl(50, f))</span>
 196 |     | <span class='neutral'>        }</span>
 197 |     | <span class='neutral'></span>
 198 | *   | <span class='executed'>        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number</span>
 199 |     | <span class='neutral'></span>
 200 | *   | <span class='executed'>        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) &gt;&gt; 128);</span>
 201 | *   | <span class='executed'>        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) &gt;&gt; 128);</span>
 202 |     | <span class='neutral'></span>
 203 | *   | <span class='executed'>        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) &lt;= sqrtPriceX96 ? tickHi : tickLow;</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'>}</span>
 206 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/TransferHelper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../interfaces/IERC20Minimal.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @title TransferHelper</span>
  7 |     | <span class='neutral'>/// @notice Contains helper methods for interacting with ERC20 tokens that do not consistently return true/false</span>
  8 |     | <span class='unexecuted'>library TransferHelper {</span>
  9 |     | <span class='neutral'>    /// @notice Transfers tokens from msg.sender to a recipient</span>
 10 |     | <span class='neutral'>    /// @dev Calls transfer on token contract, errors with TF if transfer fails</span>
 11 |     | <span class='neutral'>    /// @param token The contract address of the token which will be transferred</span>
 12 |     | <span class='neutral'>    /// @param to The recipient of the transfer</span>
 13 |     | <span class='neutral'>    /// @param value The value of the transfer</span>
 14 | *   | <span class='executed'>    function safeTransfer(</span>
 15 |     | <span class='neutral'>        address token,</span>
 16 |     | <span class='neutral'>        address to,</span>
 17 |     | <span class='neutral'>        uint256 value</span>
 18 |     | <span class='neutral'>    ) internal {</span>
 19 | *   | <span class='executed'>        (bool success, bytes memory data) =</span>
 20 | *   | <span class='executed'>            token.call(abi.encodeWithSelector(IERC20Minimal.transfer.selector, to, value));</span>
 21 | *   | <span class='executed'>        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#39;TF&#39;);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'>}</span>
 24 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/libraries/UnsafeMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Math functions that do not check inputs or outputs</span>
  5 |     | <span class='neutral'>/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks</span>
  6 |     | <span class='unexecuted'>library UnsafeMath {</span>
  7 |     | <span class='neutral'>    /// @notice Returns ceil(x / y)</span>
  8 |     | <span class='neutral'>    /// @dev division by 0 has unspecified behavior, and must be checked externally</span>
  9 |     | <span class='neutral'>    /// @param x The dividend</span>
 10 |     | <span class='neutral'>    /// @param y The divisor</span>
 11 |     | <span class='neutral'>    /// @return z The quotient, ceil(x / y)</span>
 12 |     | <span class='unexecuted'>    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 13 |     | <span class='unexecuted'>        assembly {</span>
 14 |     | <span class='unexecuted'>            z := add(div(x, y), gt(mod(x, y), 0))</span>
 15 |     | <span class='neutral'>        }</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/contracts/test/TestERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity =0.7.6;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../interfaces/IERC20Minimal.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 | *   | <span class='executed'>contract TestERC20 is IERC20Minimal {</span>
  7 | *   | <span class='executed'>    mapping(address =&gt; uint256) public override balanceOf;</span>
  8 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; uint256)) public override allowance;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    constructor(uint256 amountToMint) {</span>
 11 |     | <span class='unexecuted'>        mint(msg.sender, amountToMint);</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 | *   | <span class='executed'>    function mint(address to, uint256 amount) public {</span>
 15 |     | <span class='unexecuted'>        uint256 balanceNext = balanceOf[to] + amount;</span>
 16 |     | <span class='unexecuted'>        require(balanceNext &gt;= amount, &#39;overflow balance&#39;);</span>
 17 |     | <span class='unexecuted'>        balanceOf[to] = balanceNext;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 | *   | <span class='executed'>    function transfer(address recipient, uint256 amount) external override returns (bool) {</span>
 21 | *   | <span class='executed'>        uint256 balanceBefore = balanceOf[msg.sender];</span>
 22 | *   | <span class='executed'>        require(balanceBefore &gt;= amount, &#39;insufficient balance&#39;);</span>
 23 | *   | <span class='executed'>        balanceOf[msg.sender] = balanceBefore - amount;</span>
 24 |     | <span class='neutral'></span>
 25 | *   | <span class='executed'>        uint256 balanceRecipient = balanceOf[recipient];</span>
 26 | *   | <span class='executed'>        require(balanceRecipient + amount &gt;= balanceRecipient, &#39;recipient balance overflow&#39;);</span>
 27 | *   | <span class='executed'>        balanceOf[recipient] = balanceRecipient + amount;</span>
 28 |     | <span class='neutral'></span>
 29 | *   | <span class='executed'>        emit Transfer(msg.sender, recipient, amount);</span>
 30 | *   | <span class='executed'>        return true;</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 | *   | <span class='executed'>    function approve(address spender, uint256 amount) external override returns (bool) {</span>
 34 |     | <span class='unexecuted'>        allowance[msg.sender][spender] = amount;</span>
 35 |     | <span class='unexecuted'>        emit Approval(msg.sender, spender, amount);</span>
 36 |     | <span class='unexecuted'>        return true;</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>    function transferFrom(</span>
 40 |     | <span class='neutral'>        address sender,</span>
 41 |     | <span class='neutral'>        address recipient,</span>
 42 |     | <span class='neutral'>        uint256 amount</span>
 43 |     | <span class='unexecuted'>    ) external override returns (bool) {</span>
 44 |     | <span class='unexecuted'>        uint256 allowanceBefore = allowance[sender][msg.sender];</span>
 45 |     | <span class='unexecuted'>        require(allowanceBefore &gt;= amount, &#39;allowance insufficient&#39;);</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>        allowance[sender][msg.sender] = allowanceBefore - amount;</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='unexecuted'>        uint256 balanceRecipient = balanceOf[recipient];</span>
 50 |     | <span class='unexecuted'>        require(balanceRecipient + amount &gt;= balanceRecipient, &#39;overflow balance recipient&#39;);</span>
 51 |     | <span class='unexecuted'>        balanceOf[recipient] = balanceRecipient + amount;</span>
 52 |     | <span class='unexecuted'>        uint256 balanceSender = balanceOf[sender];</span>
 53 |     | <span class='unexecuted'>        require(balanceSender &gt;= amount, &#39;underflow balance sender&#39;);</span>
 54 |     | <span class='unexecuted'>        balanceOf[sender] = balanceSender - amount;</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='unexecuted'>        emit Transfer(sender, recipient, amount);</span>
 57 |     | <span class='unexecuted'>        return true;</span>
 58 |     | <span class='neutral'>    }</span>
 59 |     | <span class='neutral'>}</span>
 60 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/lib/chimera/src/Asserts.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.7.6;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract Asserts {</span>
  5 |     | <span class='neutral'>    function gt(uint256 a, uint256 b, string memory reason) internal virtual;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function gte(uint256 a, uint256 b, string memory reason) internal virtual;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function lt(uint256 a, uint256 b, string memory reason) internal virtual;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function lte(uint256 a, uint256 b, string memory reason) internal virtual;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function eq(uint256 a, uint256 b, string memory reason) internal virtual;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function t(bool b, string memory reason) internal virtual;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function between(uint256 value, uint256 low, uint256 high) internal virtual returns (uint256);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function between(int256 value, int256 low, int256 high) internal virtual returns (int256);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function precondition(bool p) internal virtual;</span>
 22 |     | <span class='neutral'>}</span>
 23 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/lib/chimera/src/BaseProperties.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity ^0.7.6;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>import {BaseSetup} from &#39;./BaseSetup.sol&#39;;</span>
 5 |     | <span class='neutral'></span>
 6 |     | <span class='neutral'>abstract contract BaseProperties is BaseSetup {}</span>
 7 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/lib/chimera/src/BaseSetup.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity ^0.7.6;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>abstract contract BaseSetup {</span>
 5 |     | <span class='neutral'>    function setup() internal virtual;</span>
 6 |     | <span class='neutral'>}</span>
 7 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/lib/chimera/src/BaseTargetFunctions.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity ^0.7.6;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>import {BaseProperties} from &#39;./BaseProperties.sol&#39;;</span>
 5 |     | <span class='neutral'>import {Asserts} from &#39;./Asserts.sol&#39;;</span>
 6 |     | <span class='neutral'></span>
 7 |     | <span class='neutral'>abstract contract BaseTargetFunctions is BaseProperties, Asserts {}</span>
 8 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/lib/chimera/src/CryticAsserts.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.7.6;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Asserts} from &#39;./Asserts.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>contract CryticAsserts is Asserts {</span>
  7 |     | <span class='neutral'>    event Log(string);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function gt(uint256 a, uint256 b, string memory reason) internal virtual override {</span>
 10 |     | <span class='neutral'>        emit Log(reason);</span>
 11 |     | <span class='neutral'>        assert(a &gt; b);</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function gte(uint256 a, uint256 b, string memory reason) internal virtual override {</span>
 15 |     | <span class='neutral'>        emit Log(reason);</span>
 16 |     | <span class='neutral'>        assert(a &gt;= b);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function lt(uint256 a, uint256 b, string memory reason) internal virtual override {</span>
 20 |     | <span class='neutral'>        emit Log(reason);</span>
 21 |     | <span class='neutral'>        assert(a &lt; b);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    function lte(uint256 a, uint256 b, string memory reason) internal virtual override {</span>
 25 |     | <span class='neutral'>        emit Log(reason);</span>
 26 |     | <span class='neutral'>        assert(a &lt;= b);</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    function eq(uint256 a, uint256 b, string memory reason) internal virtual override {</span>
 30 |     | <span class='neutral'>        emit Log(reason);</span>
 31 |     | <span class='neutral'>        assert(a == b);</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    function t(bool b, string memory reason) internal virtual override {</span>
 35 |     | <span class='neutral'>        emit Log(reason);</span>
 36 |     | <span class='neutral'>        assert(b);</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    function between(uint256 value, uint256 low, uint256 high) internal virtual override returns (uint256) {</span>
 40 |     | <span class='neutral'>        if (value &lt; low || value &gt; high) {</span>
 41 |     | <span class='neutral'>            uint256 ans = low + (value % (high - low + 1));</span>
 42 |     | <span class='neutral'>            return ans;</span>
 43 |     | <span class='neutral'>        }</span>
 44 |     | <span class='neutral'>        return value;</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    function between(int256 value, int256 low, int256 high) internal virtual override returns (int256) {</span>
 48 |     | <span class='neutral'>        if (value &lt; low || value &gt; high) {</span>
 49 |     | <span class='neutral'>            int256 range = high - low + 1;</span>
 50 |     | <span class='neutral'>            int256 clamped = (value - low) % (range);</span>
 51 |     | <span class='neutral'>            if (clamped &lt; 0) clamped += range;</span>
 52 |     | <span class='neutral'>            int256 ans = low + clamped;</span>
 53 |     | <span class='neutral'>            return ans;</span>
 54 |     | <span class='neutral'>        }</span>
 55 |     | <span class='neutral'>        return value;</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>    function precondition(bool p) internal virtual override {</span>
 59 |     | <span class='neutral'>        require(p);</span>
 60 |     | <span class='neutral'>    }</span>
 61 |     | <span class='neutral'>}</span>
 62 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/lib/chimera/src/Hevm.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma abicoder v2;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IHevm {</span>
  5 |     | <span class='neutral'>    // Set block.timestamp to newTimestamp</span>
  6 |     | <span class='neutral'>    function warp(uint256 newTimestamp) external;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    // Set block.number to newNumber</span>
  9 |     | <span class='neutral'>    function roll(uint256 newNumber) external;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    // Loads a storage slot from an address</span>
 12 |     | <span class='neutral'>    function load(address where, bytes32 slot) external returns (bytes32);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    // Stores a value to an address&#39; storage slot</span>
 15 |     | <span class='neutral'>    function store(address where, bytes32 slot, bytes32 value) external;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    // Signs data (privateKey, digest) =&gt; (r, v, s)</span>
 18 |     | <span class='neutral'>    function sign(uint256 privateKey, bytes32 digest) external returns (uint8 r, bytes32 v, bytes32 s);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    // Gets address for a given private key</span>
 21 |     | <span class='neutral'>    function addr(uint256 privateKey) external returns (address account);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    // Performs a foreign function call via terminal</span>
 24 |     | <span class='neutral'>    function ffi(string[] calldata inputs) external returns (bytes memory result);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    // Performs the next smart contract call with specified `msg.sender`</span>
 27 |     | <span class='neutral'>    function prank(address newSender) external;</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>IHevm constant vm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);</span>
 31 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/test/recon/BeforeAfter.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity ^0.7.6;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Setup} from &#39;./Setup.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;contracts/UniswapV3Pool.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;contracts/libraries/Position.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>abstract contract BeforeAfter is Setup {</span>
  9 |     | <span class='neutral'>    struct Slot0 {</span>
 10 |     | <span class='neutral'>        // the current price</span>
 11 |     | <span class='neutral'>        uint160 sqrtPriceX96;</span>
 12 |     | <span class='neutral'>        // the current tick</span>
 13 |     | <span class='neutral'>        int24 tick;</span>
 14 |     | <span class='neutral'>        // the most-recently updated index of the observations array</span>
 15 |     | <span class='neutral'>        uint16 observationIndex;</span>
 16 |     | <span class='neutral'>        // the current maximum number of observations that are being stored</span>
 17 |     | <span class='neutral'>        uint16 observationCardinality;</span>
 18 |     | <span class='neutral'>        // the next maximum number of observations to store, triggered in observations.write</span>
 19 |     | <span class='neutral'>        uint16 observationCardinalityNext;</span>
 20 |     | <span class='neutral'>        // the current protocol fee as a percentage of the swap fee taken on withdrawal</span>
 21 |     | <span class='neutral'>        // represented as an integer denominator (1/x)%</span>
 22 |     | <span class='neutral'>        uint8 feeProtocol;</span>
 23 |     | <span class='neutral'>        // whether the pool is locked</span>
 24 |     | <span class='neutral'>        bool unlocked;</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    struct Vars {</span>
 28 |     | <span class='neutral'>        mapping(bytes32 =&gt; Position.Info) uniswapV3Pool_positions;</span>
 29 |     | <span class='neutral'>        uint256 testERC20_balanceOfToken0;</span>
 30 |     | <span class='neutral'>        uint256 testERC20_balanceOfToken1;</span>
 31 |     | <span class='neutral'>        // SwapperStats = liquidity, freeGrowthGlobal0, freeGrowthGlobal1, token0 balance, token1 balance</span>
 32 |     | <span class='neutral'>        uint256 uniswapV3Pool_feeGrowthGlobal0X128;</span>
 33 |     | <span class='neutral'>        uint256 uniswapV3Pool_feeGrowthGlobal1X128;</span>
 34 |     | <span class='neutral'>        uint128 uniswapV3Pool_liquidity;</span>
 35 |     | <span class='neutral'>        int24 uniswapV3Pool_currentTick;</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    Vars internal _before;</span>
 39 |     | <span class='neutral'>    Vars internal _after;</span>
 40 |     | <span class='neutral'></span>
 41 | *   | <span class='executed'>    function __before() internal {</span>
 42 |     | <span class='neutral'>        // replaced original implementation to allow querying balance of token0 and token1</span>
 43 | *   | <span class='executed'>        _before.testERC20_balanceOfToken0 = token0.balanceOf(address(this));</span>
 44 | *   | <span class='executed'>        _before.testERC20_balanceOfToken1 = token1.balanceOf(address(this));</span>
 45 |     | <span class='neutral'></span>
 46 | *   | <span class='executed'>        (, _before.uniswapV3Pool_currentTick, , , , , ) = uniswapV3Pool.slot0();</span>
 47 | *   | <span class='executed'>        _before.uniswapV3Pool_feeGrowthGlobal0X128 = uniswapV3Pool.feeGrowthGlobal0X128();</span>
 48 | *   | <span class='executed'>        _before.uniswapV3Pool_feeGrowthGlobal1X128 = uniswapV3Pool.feeGrowthGlobal1X128();</span>
 49 | *   | <span class='executed'>        _before.uniswapV3Pool_liquidity = uniswapV3Pool.liquidity();</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'></span>
 52 | *   | <span class='executed'>    function __after() internal {</span>
 53 | *   | <span class='executed'>        _after.testERC20_balanceOfToken0 = token0.balanceOf(address(this));</span>
 54 | *   | <span class='executed'>        _after.testERC20_balanceOfToken1 = token1.balanceOf(address(this));</span>
 55 |     | <span class='neutral'></span>
 56 | *   | <span class='executed'>        (, _after.uniswapV3Pool_currentTick, , , , , ) = uniswapV3Pool.slot0();</span>
 57 | *   | <span class='executed'>        _after.uniswapV3Pool_feeGrowthGlobal0X128 = uniswapV3Pool.feeGrowthGlobal0X128();</span>
 58 | *   | <span class='executed'>        _after.uniswapV3Pool_feeGrowthGlobal1X128 = uniswapV3Pool.feeGrowthGlobal1X128();</span>
 59 | *   | <span class='executed'>        _after.uniswapV3Pool_liquidity = uniswapV3Pool.liquidity();</span>
 60 |     | <span class='neutral'>    }</span>
 61 |     | <span class='neutral'>}</span>
 62 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/test/recon/CryticTester.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity ^0.7.6;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {TargetFunctions} from &#39;./TargetFunctions.sol&#39;;</span>
  5 |     | <span class='neutral'>import {CryticAsserts} from &#39;@chimera/CryticAsserts.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>// echidna . --contract CryticTester --config echidna.yaml</span>
  8 |     | <span class='neutral'>// medusa fuzz</span>
  9 | *or | <span class='executed'>contract CryticTester is TargetFunctions, CryticAsserts {</span>
 10 |     | <span class='neutral'>    constructor() payable {</span>
 11 |     | <span class='unexecuted'>        setup();</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/test/recon/Properties.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
 2 |     | <span class='neutral'>pragma solidity ^0.7.6;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>import {Asserts} from &#39;@chimera/Asserts.sol&#39;;</span>
 5 |     | <span class='neutral'>import {Setup} from &#39;./Setup.sol&#39;;</span>
 6 |     | <span class='neutral'></span>
 7 |     | <span class='neutral'>abstract contract Properties is Setup, Asserts {}</span>
 8 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/test/recon/Setup.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
   2 |     | <span class='neutral'>pragma abicoder v2;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {BaseSetup} from &#39;@chimera/BaseSetup.sol&#39;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &#39;contracts/interfaces/IUniswapV3Factory.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;contracts/interfaces/callback/IUniswapV3FlashCallback.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;contracts/UniswapV3PoolDeployer.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;contracts/UniswapV3Factory.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;contracts/interfaces/IUniswapV3PoolDeployer.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;contracts/interfaces/IERC20Minimal.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;contracts/interfaces/IUniswapV3Pool.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol&#39;;</span>
  15 |     | <span class='neutral'>import &#39;contracts/interfaces/pool/IUniswapV3PoolEvents.sol&#39;;</span>
  16 |     | <span class='neutral'>import &#39;contracts/interfaces/pool/IUniswapV3PoolState.sol&#39;;</span>
  17 |     | <span class='neutral'>import &#39;contracts/interfaces/pool/IUniswapV3PoolActions.sol&#39;;</span>
  18 |     | <span class='neutral'>import &#39;contracts/interfaces/callback/IUniswapV3SwapCallback.sol&#39;;</span>
  19 |     | <span class='neutral'>import &#39;contracts/interfaces/callback/IUniswapV3MintCallback.sol&#39;;</span>
  20 |     | <span class='neutral'>import &#39;contracts/interfaces/pool/IUniswapV3PoolImmutables.sol&#39;;</span>
  21 |     | <span class='neutral'>import &#39;contracts/UniswapV3Pool.sol&#39;;</span>
  22 |     | <span class='neutral'>import &#39;contracts/test/TestERC20.sol&#39;;</span>
  23 |     | <span class='neutral'>import &#39;test/recon/SetupUniswap.sol&#39;;</span>
  24 |     | <span class='neutral'>import &#39;contracts/libraries/TickMath.sol&#39;;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>abstract contract Setup is BaseSetup {</span>
  27 |     | <span class='neutral'>    UniswapV3Pool uniswapV3Pool;</span>
  28 |     | <span class='neutral'>    TestERC20 testERC20; //default from harness</span>
  29 |     | <span class='neutral'>    TestERC20 token0;</span>
  30 |     | <span class='neutral'>    TestERC20 token1;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    SetupTokens tokens;</span>
  33 |     | <span class='neutral'>    SetupUniswap uniswap;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    // UniswapV3Pool pool;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    UniswapMinter minter;</span>
  38 |     | <span class='neutral'>    UniswapSwapper swapper;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    PoolParams poolParams;</span>
  41 |     | <span class='neutral'>    PoolPositions poolPositions;</span>
  42 |     | <span class='neutral'>    PoolPosition[] positions;</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    int24[] usedTicks;</span>
  45 |     | <span class='neutral'>    bool inited;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    struct PoolParams {</span>
  48 |     | <span class='neutral'>        uint24 fee;</span>
  49 |     | <span class='neutral'>        int24 tickSpacing;</span>
  50 |     | <span class='neutral'>        int24 minTick;</span>
  51 |     | <span class='neutral'>        int24 maxTick;</span>
  52 |     | <span class='neutral'>        uint24 tickCount;</span>
  53 |     | <span class='neutral'>        uint160 startPrice;</span>
  54 |     | <span class='neutral'>        int24 startTick;</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    struct PoolPosition {</span>
  58 |     | <span class='neutral'>        int24 tickLower;</span>
  59 |     | <span class='neutral'>        int24 tickUpper;</span>
  60 |     | <span class='neutral'>        uint128 amount;</span>
  61 |     | <span class='neutral'>        bytes32 key;</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    struct PoolPositions {</span>
  65 |     | <span class='neutral'>        int24[] tickLowers;</span>
  66 |     | <span class='neutral'>        int24[] tickUppers;</span>
  67 |     | <span class='neutral'>        uint128[] amounts;</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>    function setup() internal virtual override {</span>
  71 |     | <span class='neutral'>        // uniswapV3Pool = new UniswapV3Pool(); // pool requires more complicated initialization steps so using the ToB initialization function</span>
  72 |     | <span class='unexecuted'>        testERC20 = new TestERC20(1e9 ether);</span>
  73 |     | <span class='unexecuted'>        token0 = new TestERC20(1e9 ether);</span>
  74 |     | <span class='unexecuted'>        token1 = new TestERC20(1e9 ether);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>        // setup for tests</span>
  77 |     | <span class='unexecuted'>        tokens = new SetupTokens();</span>
  78 |     | <span class='unexecuted'>        token0 = tokens.token0();</span>
  79 |     | <span class='unexecuted'>        token1 = tokens.token1();</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>        uniswap = new SetupUniswap(token0, token1);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>        minter = new UniswapMinter(token0, token1);</span>
  84 |     | <span class='unexecuted'>        swapper = new UniswapSwapper(token0, token1);</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>        tokens.mintTo(0, address(swapper), 1e9 ether);</span>
  87 |     | <span class='unexecuted'>        tokens.mintTo(1, address(swapper), 1e9 ether);</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>        tokens.mintTo(0, address(minter), 1e10 ether);</span>
  90 |     | <span class='unexecuted'>        tokens.mintTo(1, address(minter), 1e10 ether);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    // helper functions</span>
  94 | *   | <span class='executed'>    function _init(uint128 _seed) internal {</span>
  95 |     | <span class='neutral'>        //</span>
  96 |     | <span class='neutral'>        // generate random pool params</span>
  97 |     | <span class='neutral'>        //</span>
  98 | *   | <span class='executed'>        poolParams = forgePoolParams(_seed);</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>        //</span>
 101 |     | <span class='neutral'>        // deploy the pool</span>
 102 |     | <span class='neutral'>        //</span>
 103 | *   | <span class='executed'>        uniswap.createPool(poolParams.fee, poolParams.startPrice);</span>
 104 | *   | <span class='executed'>        uniswapV3Pool = uniswap.pool();</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>        //</span>
 107 |     | <span class='neutral'>        // set the pool inside the minter and swapper contracts</span>
 108 |     | <span class='neutral'>        //</span>
 109 | *   | <span class='executed'>        minter.setPool(uniswapV3Pool);</span>
 110 | *   | <span class='executed'>        swapper.setPool(uniswapV3Pool);</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>        //</span>
 113 |     | <span class='neutral'>        // generate random positions</span>
 114 |     | <span class='neutral'>        //</span>
 115 | *   | <span class='executed'>        poolPositions = forgePoolPositions(_seed, poolParams.tickSpacing, poolParams.tickCount, poolParams.maxTick);</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>        //</span>
 118 |     | <span class='neutral'>        // create the positions</span>
 119 |     | <span class='neutral'>        //</span>
 120 | *   | <span class='executed'>        for (uint8 i = 0; i &lt; poolPositions.tickLowers.length; i++) {</span>
 121 | *   | <span class='executed'>            int24 tickLower = poolPositions.tickLowers[i];</span>
 122 | *   | <span class='executed'>            int24 tickUpper = poolPositions.tickUppers[i];</span>
 123 | *   | <span class='executed'>            uint128 amount = poolPositions.amounts[i];</span>
 124 |     | <span class='neutral'></span>
 125 | *r  | <span class='executed'>            minter.doMint(tickLower, tickUpper, amount);</span>
 126 |     | <span class='neutral'></span>
 127 | *   | <span class='executed'>            bool lowerAlreadyUsed = false;</span>
 128 | *   | <span class='executed'>            bool upperAlreadyUsed = false;</span>
 129 | *   | <span class='executed'>            for (uint8 j = 0; j &lt; usedTicks.length; j++) {</span>
 130 | *   | <span class='executed'>                if (usedTicks[j] == tickLower) lowerAlreadyUsed = true;</span>
 131 | *   | <span class='executed'>                else if (usedTicks[j] == tickUpper) upperAlreadyUsed = true;</span>
 132 |     | <span class='neutral'>            }</span>
 133 | *   | <span class='executed'>            if (!lowerAlreadyUsed) usedTicks.push(tickLower);</span>
 134 | *   | <span class='executed'>            if (!upperAlreadyUsed) usedTicks.push(tickUpper);</span>
 135 |     | <span class='neutral'>        }</span>
 136 |     | <span class='neutral'></span>
 137 | *   | <span class='executed'>        inited = true;</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 | *   | <span class='executed'>    function forgePoolParams(uint128 _seed) internal view returns (PoolParams memory poolParams) {</span>
 141 |     | <span class='neutral'>        //</span>
 142 |     | <span class='neutral'>        // decide on one of the three fees, and corresponding tickSpacing</span>
 143 |     | <span class='neutral'>        //</span>
 144 | *   | <span class='executed'>        if (_seed % 3 == 0) {</span>
 145 | *   | <span class='executed'>            poolParams.fee = uint24(500);</span>
 146 | *   | <span class='executed'>            poolParams.tickSpacing = int24(10);</span>
 147 | *   | <span class='executed'>        } else if (_seed % 3 == 1) {</span>
 148 | *   | <span class='executed'>            poolParams.fee = uint24(3000);</span>
 149 | *   | <span class='executed'>            poolParams.tickSpacing = int24(60);</span>
 150 | *   | <span class='executed'>        } else if (_seed % 3 == 2) {</span>
 151 | *   | <span class='executed'>            poolParams.fee = uint24(10000);</span>
 152 | *   | <span class='executed'>            poolParams.tickSpacing = int24(2000);</span>
 153 |     | <span class='neutral'>        }</span>
 154 |     | <span class='neutral'></span>
 155 | *   | <span class='executed'>        poolParams.maxTick = (int24(887272) / poolParams.tickSpacing) * poolParams.tickSpacing;</span>
 156 | *   | <span class='executed'>        poolParams.minTick = -poolParams.maxTick;</span>
 157 | *   | <span class='executed'>        poolParams.tickCount = uint24(poolParams.maxTick / poolParams.tickSpacing);</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>        //</span>
 160 |     | <span class='neutral'>        // set the initial price</span>
 161 |     | <span class='neutral'>        //</span>
 162 | *   | <span class='executed'>        poolParams.startTick = int24((_seed % uint128(poolParams.tickCount)) * uint128(poolParams.tickSpacing));</span>
 163 | *   | <span class='executed'>        if (_seed % 3 == 0) {</span>
 164 |     | <span class='neutral'>            // set below 0</span>
 165 | *   | <span class='executed'>            poolParams.startPrice = TickMath.getSqrtRatioAtTick(-poolParams.startTick);</span>
 166 | *   | <span class='executed'>        } else if (_seed % 3 == 1) {</span>
 167 |     | <span class='neutral'>            // set at 0</span>
 168 | *   | <span class='executed'>            poolParams.startPrice = TickMath.getSqrtRatioAtTick(0);</span>
 169 | *   | <span class='executed'>            poolParams.startTick = 0;</span>
 170 | *   | <span class='executed'>        } else if (_seed % 3 == 2) {</span>
 171 |     | <span class='neutral'>            // set above 0</span>
 172 | *   | <span class='executed'>            poolParams.startPrice = TickMath.getSqrtRatioAtTick(poolParams.startTick);</span>
 173 |     | <span class='neutral'>        }</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 | *   | <span class='executed'>    function forgePoolPositions(</span>
 177 |     | <span class='neutral'>        uint128 _seed,</span>
 178 |     | <span class='neutral'>        int24 _poolTickSpacing,</span>
 179 |     | <span class='neutral'>        uint24 _poolTickCount,</span>
 180 |     | <span class='neutral'>        int24 _poolMaxTick</span>
 181 | *   | <span class='executed'>    ) internal view returns (PoolPositions memory poolPositions_) {</span>
 182 |     | <span class='neutral'>        // between 1 and 10 (inclusive) positions</span>
 183 | *   | <span class='executed'>        uint8 positionsCount = uint8(_seed % 10) + 1;</span>
 184 |     | <span class='neutral'></span>
 185 | *   | <span class='executed'>        poolPositions_.tickLowers = new int24[](positionsCount);</span>
 186 | *   | <span class='executed'>        poolPositions_.tickUppers = new int24[](positionsCount);</span>
 187 | *   | <span class='executed'>        poolPositions_.amounts = new uint128[](positionsCount);</span>
 188 |     | <span class='neutral'></span>
 189 | *   | <span class='executed'>        for (uint8 i = 0; i &lt; positionsCount; i++) {</span>
 190 | *   | <span class='executed'>            int24 tickLower;</span>
 191 |     | <span class='neutral'>            int24 tickUpper;</span>
 192 |     | <span class='neutral'>            uint128 amount;</span>
 193 |     | <span class='neutral'></span>
 194 | *   | <span class='executed'>            int24 randomTick1 = int24((_seed % uint128(_poolTickCount)) * uint128(_poolTickSpacing));</span>
 195 |     | <span class='neutral'></span>
 196 | *   | <span class='executed'>            if (_seed % 2 == 0) {</span>
 197 |     | <span class='neutral'>                // make tickLower positive</span>
 198 | *   | <span class='executed'>                tickLower = randomTick1;</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>                // tickUpper is somewhere above tickLower</span>
 201 | *   | <span class='executed'>                uint24 poolTickCountLeft = uint24((_poolMaxTick - randomTick1) / _poolTickSpacing);</span>
 202 | *   | <span class='executed'>                int24 randomTick2 = int24((_seed % uint128(poolTickCountLeft)) * uint128(_poolTickSpacing));</span>
 203 | *   | <span class='executed'>                tickUpper = tickLower + randomTick2;</span>
 204 |     | <span class='neutral'>            } else {</span>
 205 |     | <span class='neutral'>                // make tickLower negative or zero</span>
 206 | *   | <span class='executed'>                tickLower = randomTick1 == 0 ? 0 : -randomTick1;</span>
 207 |     | <span class='neutral'></span>
 208 | *   | <span class='executed'>                uint24 poolTickCountNegativeLeft = uint24((_poolMaxTick - randomTick1) / _poolTickSpacing);</span>
 209 | *   | <span class='executed'>                uint24 poolTickCountTotalLeft = poolTickCountNegativeLeft + _poolTickCount;</span>
 210 |     | <span class='neutral'></span>
 211 | *   | <span class='executed'>                uint24 randomIncrement = uint24((_seed % uint128(poolTickCountTotalLeft)) * uint128(_poolTickSpacing));</span>
 212 |     | <span class='neutral'></span>
 213 | *   | <span class='executed'>                if (randomIncrement &lt;= uint24(tickLower)) {</span>
 214 |     | <span class='neutral'>                    // tickUpper will also be negative</span>
 215 | *   | <span class='executed'>                    tickUpper = tickLower + int24(randomIncrement);</span>
 216 |     | <span class='neutral'>                } else {</span>
 217 |     | <span class='neutral'>                    // tickUpper is positive</span>
 218 | *   | <span class='executed'>                    randomIncrement -= uint24(-tickLower);</span>
 219 | *   | <span class='executed'>                    tickUpper = tickLower + int24(randomIncrement);</span>
 220 |     | <span class='neutral'>                }</span>
 221 |     | <span class='neutral'>            }</span>
 222 |     | <span class='neutral'></span>
 223 | *   | <span class='executed'>            amount = uint128(1e8 ether);</span>
 224 |     | <span class='neutral'></span>
 225 | *   | <span class='executed'>            poolPositions_.tickLowers[i] = tickLower;</span>
 226 | *   | <span class='executed'>            poolPositions_.tickUppers[i] = tickUpper;</span>
 227 | *   | <span class='executed'>            poolPositions_.amounts[i] = amount;</span>
 228 |     | <span class='neutral'></span>
 229 | *   | <span class='executed'>            _seed += uint128(tickLower);</span>
 230 |     | <span class='neutral'>        }</span>
 231 |     | <span class='neutral'>    }</span>
 232 |     | <span class='neutral'></span>
 233 | *   | <span class='executed'>    function get_random_zeroForOne_priceLimit(</span>
 234 |     | <span class='neutral'>        int256 _amountSpecified</span>
 235 | *   | <span class='executed'>    ) internal view returns (uint160 sqrtPriceLimitX96) {</span>
 236 |     | <span class='neutral'>        // help echidna a bit by calculating a valid sqrtPriceLimitX96 using the amount as random seed</span>
 237 | *   | <span class='executed'>        (uint160 currentPrice, , , , , , ) = uniswapV3Pool.slot0();</span>
 238 | *   | <span class='executed'>        uint160 minimumPrice = TickMath.MIN_SQRT_RATIO;</span>
 239 |     | <span class='neutral'>        sqrtPriceLimitX96 =</span>
 240 | *   | <span class='executed'>            minimumPrice +</span>
 241 |     | <span class='neutral'>            uint160(</span>
 242 | *   | <span class='executed'>                (uint256(_amountSpecified &gt; 0 ? _amountSpecified : -_amountSpecified) % (currentPrice - minimumPrice))</span>
 243 |     | <span class='neutral'>            );</span>
 244 |     | <span class='neutral'>    }</span>
 245 |     | <span class='neutral'></span>
 246 | *   | <span class='executed'>    function get_random_oneForZero_priceLimit(</span>
 247 |     | <span class='neutral'>        int256 _amountSpecified</span>
 248 | *   | <span class='executed'>    ) internal view returns (uint160 sqrtPriceLimitX96) {</span>
 249 |     | <span class='neutral'>        // help echidna a bit by calculating a valid sqrtPriceLimitX96 using the amount as random seed</span>
 250 | *   | <span class='executed'>        (uint160 currentPrice, , , , , , ) = uniswapV3Pool.slot0();</span>
 251 | *   | <span class='executed'>        uint160 maximumPrice = TickMath.MAX_SQRT_RATIO;</span>
 252 | *   | <span class='executed'>        sqrtPriceLimitX96 =</span>
 253 | *   | <span class='executed'>            currentPrice +</span>
 254 |     | <span class='neutral'>            uint160(</span>
 255 | *   | <span class='executed'>                (uint256(_amountSpecified &gt; 0 ? _amountSpecified : -_amountSpecified) % (maximumPrice - currentPrice))</span>
 256 |     | <span class='neutral'>            );</span>
 257 |     | <span class='neutral'>    }</span>
 258 |     | <span class='neutral'></span>
 259 | *   | <span class='executed'>    function check_swap_invariants(</span>
 260 |     | <span class='neutral'>        int24 tick_bfre,</span>
 261 |     | <span class='neutral'>        int24 tick_aftr,</span>
 262 |     | <span class='neutral'>        uint128 liq_bfre,</span>
 263 |     | <span class='neutral'>        uint128 liq_aftr,</span>
 264 |     | <span class='neutral'>        uint256 bal_sell_bfre,</span>
 265 |     | <span class='neutral'>        uint256 bal_sell_aftr,</span>
 266 |     | <span class='neutral'>        uint256 bal_buy_bfre,</span>
 267 |     | <span class='neutral'>        uint256 bal_buy_aftr,</span>
 268 |     | <span class='neutral'>        uint256 feegrowth_sell_bfre,</span>
 269 |     | <span class='neutral'>        uint256 feegrowth_sell_aftr,</span>
 270 |     | <span class='neutral'>        uint256 feegrowth_buy_bfre,</span>
 271 |     | <span class='neutral'>        uint256 feegrowth_buy_aftr</span>
 272 |     | <span class='neutral'>    ) internal {</span>
 273 |     | <span class='neutral'>        // prop #17</span>
 274 | *   | <span class='executed'>        if (tick_bfre == tick_aftr) {</span>
 275 | *e  | <span class='executed'>            assert(liq_bfre == liq_aftr);</span>
 276 |     | <span class='neutral'>        }</span>
 277 |     | <span class='neutral'>    }</span>
 278 |     | <span class='neutral'></span>
 279 |     | <span class='neutral'>    function _getRandomPositionIdx(uint128 _seed, uint256 _positionsCount) internal view returns (uint128 positionIdx) {</span>
 280 |     | <span class='neutral'>        positionIdx = _seed % uint128(_positionsCount);</span>
 281 |     | <span class='neutral'>    }</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>    function _getRandomBurnAmount(uint128 _seed, uint128 _positionAmount) internal view returns (uint128 burnAmount) {</span>
 284 |     | <span class='neutral'>        burnAmount = _seed % _positionAmount;</span>
 285 |     | <span class='neutral'>        require(burnAmount &lt; _positionAmount);</span>
 286 |     | <span class='neutral'>        require(burnAmount &gt; 0);</span>
 287 |     | <span class='neutral'>    }</span>
 288 |     | <span class='neutral'></span>
 289 |     | <span class='neutral'>    function _getRandomPositionIdxAndBurnAmount(</span>
 290 |     | <span class='neutral'>        uint128 _seed</span>
 291 |     | <span class='neutral'>    ) internal view returns (uint128 positionIdx, uint128 burnAmount) {</span>
 292 |     | <span class='neutral'>        positionIdx = _getRandomPositionIdx(_seed, positions.length);</span>
 293 |     | <span class='neutral'>        burnAmount = _getRandomBurnAmount(_seed, positions[positionIdx].amount);</span>
 294 |     | <span class='neutral'>    }</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='neutral'>    function check_burn_invariants(</span>
 297 |     | <span class='neutral'>        uint128 _burnAmount,</span>
 298 |     | <span class='neutral'>        int24 _tickLower,</span>
 299 |     | <span class='neutral'>        int24 _tickUpper,</span>
 300 |     | <span class='neutral'>        uint128 _newPosAmount,</span>
 301 |     | <span class='neutral'>        UniswapMinter.MinterStats memory bfre,</span>
 302 |     | <span class='neutral'>        UniswapMinter.MinterStats memory aftr</span>
 303 |     | <span class='neutral'>    ) internal {</span>
 304 |     | <span class='neutral'>        (, int24 currentTick, , , , , ) = uniswapV3Pool.slot0();</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='neutral'>        bytes32 positionKey = keccak256(abi.encodePacked(address(minter), _tickLower, _tickUpper));</span>
 307 |     | <span class='neutral'>        (uint128 positionLiquidity, , , , ) = uniswapV3Pool.positions(positionKey);</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='neutral'>        // prop #27</span>
 310 |     | <span class='neutral'>        assert(positionLiquidity == _newPosAmount);</span>
 311 |     | <span class='neutral'>    }</span>
 312 |     | <span class='neutral'>}</span>
 313 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/test/recon/SetupUniswap.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity =0.7.6;</span>
   2 |     | <span class='neutral'>pragma abicoder v2;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../../../../contracts/test/TestERC20.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../../../../contracts/UniswapV3Pool.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../../../../contracts/UniswapV3Factory.sol&#39;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='unexecuted'>contract SetupToken {</span>
   9 |     | <span class='unexecuted'>    TestERC20 public token;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>    constructor() {</span>
  12 |     | <span class='neutral'>        // this contract will receive the total supply of 100 tokens</span>
  13 |     | <span class='unexecuted'>        token = new TestERC20(1e12 ether);</span>
  14 |     | <span class='neutral'>    }</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='unexecuted'>    function mintTo(address _recipient, uint256 _amount) public {</span>
  17 |     | <span class='unexecuted'>        token.transfer(_recipient, _amount);</span>
  18 |     | <span class='neutral'>    }</span>
  19 |     | <span class='neutral'>}</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>contract SetupTokens {</span>
  22 |     | <span class='neutral'>    SetupToken tokenSetup0;</span>
  23 |     | <span class='neutral'>    SetupToken tokenSetup1;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>    TestERC20 public token0;</span>
  26 |     | <span class='unexecuted'>    TestERC20 public token1;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>    constructor() {</span>
  29 |     | <span class='neutral'>        // create the token wrappers</span>
  30 |     | <span class='unexecuted'>        tokenSetup0 = new SetupToken();</span>
  31 |     | <span class='unexecuted'>        tokenSetup1 = new SetupToken();</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>        // switch them around so that token0&#39;s address is lower than token1&#39;s</span>
  34 |     | <span class='neutral'>        // since this is what the uniswap factory will do when you create the pool</span>
  35 |     | <span class='unexecuted'>        if (address(tokenSetup0.token()) &gt; address(tokenSetup1.token())) {</span>
  36 |     | <span class='unexecuted'>            (tokenSetup0, tokenSetup1) = (tokenSetup1, tokenSetup0);</span>
  37 |     | <span class='neutral'>        }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>        // save the erc20 tokens</span>
  40 |     | <span class='unexecuted'>        token0 = tokenSetup0.token();</span>
  41 |     | <span class='unexecuted'>        token1 = tokenSetup1.token();</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    // mint either token0 or token1 to a chosen account</span>
  45 |     | <span class='unexecuted'>    function mintTo(uint256 _tokenIdx, address _recipient, uint256 _amount) public {</span>
  46 |     | <span class='unexecuted'>        require(_tokenIdx == 0 || _tokenIdx == 1, &#39;invalid token idx&#39;);</span>
  47 |     | <span class='unexecuted'>        if (_tokenIdx == 0) tokenSetup0.mintTo(_recipient, _amount);</span>
  48 |     | <span class='unexecuted'>        if (_tokenIdx == 1) tokenSetup1.mintTo(_recipient, _amount);</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'>}</span>
  51 |     | <span class='neutral'></span>
  52 | *   | <span class='executed'>contract SetupUniswap {</span>
  53 | *   | <span class='executed'>    UniswapV3Pool public pool;</span>
  54 |     | <span class='neutral'>    TestERC20 token0;</span>
  55 |     | <span class='neutral'>    TestERC20 token1;</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    // will create the following enabled fees and corresponding tickSpacing</span>
  58 |     | <span class='neutral'>    // fee 500   + tickSpacing 10</span>
  59 |     | <span class='neutral'>    // fee 3000  + tickSpacing 60</span>
  60 |     | <span class='neutral'>    // fee 10000 + tickSpacing 200</span>
  61 |     | <span class='neutral'>    UniswapV3Factory factory;</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>    constructor(TestERC20 _token0, TestERC20 _token1) {</span>
  64 |     | <span class='unexecuted'>        factory = new UniswapV3Factory();</span>
  65 |     | <span class='unexecuted'>        token0 = _token0;</span>
  66 |     | <span class='unexecuted'>        token1 = _token1;</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 | *   | <span class='executed'>    function createPool(uint24 _fee, uint160 _startPrice) public {</span>
  70 | *   | <span class='executed'>        pool = UniswapV3Pool(factory.createPool(address(token0), address(token1), _fee));</span>
  71 | *   | <span class='executed'>        pool.initialize(_startPrice);</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'>}</span>
  74 |     | <span class='neutral'></span>
  75 | *   | <span class='executed'>contract UniswapMinter {</span>
  76 |     | <span class='neutral'>    UniswapV3Pool pool;</span>
  77 |     | <span class='neutral'>    TestERC20 token0;</span>
  78 |     | <span class='neutral'>    TestERC20 token1;</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    struct MinterStats {</span>
  81 |     | <span class='neutral'>        uint128 liq;</span>
  82 |     | <span class='neutral'>        uint128 tL_liqGross;</span>
  83 |     | <span class='neutral'>        int128 tL_liqNet;</span>
  84 |     | <span class='neutral'>        uint128 tU_liqGross;</span>
  85 |     | <span class='neutral'>        int128 tU_liqNet;</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>    constructor(TestERC20 _token0, TestERC20 _token1) {</span>
  89 |     | <span class='unexecuted'>        token0 = _token0;</span>
  90 |     | <span class='unexecuted'>        token1 = _token1;</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 | *   | <span class='executed'>    function setPool(UniswapV3Pool _pool) public {</span>
  94 | *   | <span class='executed'>        pool = _pool;</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 | *   | <span class='executed'>    function uniswapV3MintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes calldata data) external {</span>
  98 | *   | <span class='executed'>        if (amount0Owed &gt; 0) token0.transfer(address(pool), amount0Owed);</span>
  99 | *   | <span class='executed'>        if (amount1Owed &gt; 0) token1.transfer(address(pool), amount1Owed);</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 | *   | <span class='executed'>    function getTickLiquidityVars(</span>
 103 |     | <span class='neutral'>        int24 _tickLower,</span>
 104 |     | <span class='neutral'>        int24 _tickUpper</span>
 105 | *   | <span class='executed'>    ) internal view returns (uint128, int128, uint128, int128) {</span>
 106 | *   | <span class='executed'>        (uint128 tL_liqGross, int128 tL_liqNet, , , , , , ) = pool.ticks(_tickLower);</span>
 107 | *   | <span class='executed'>        (uint128 tU_liqGross, int128 tU_liqNet, , , , , , ) = pool.ticks(_tickUpper);</span>
 108 | *   | <span class='executed'>        return (tL_liqGross, tL_liqNet, tU_liqGross, tU_liqNet);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 | *   | <span class='executed'>    function getStats(int24 _tickLower, int24 _tickUpper) internal view returns (MinterStats memory stats) {</span>
 112 | *   | <span class='executed'>        (uint128 tL_lg, int128 tL_ln, uint128 tU_lg, int128 tU_ln) = getTickLiquidityVars(_tickLower, _tickUpper);</span>
 113 | *   | <span class='executed'>        return MinterStats(pool.liquidity(), tL_lg, tL_ln, tU_lg, tU_ln);</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 | *   | <span class='executed'>    function doMint(</span>
 117 |     | <span class='neutral'>        int24 _tickLower,</span>
 118 |     | <span class='neutral'>        int24 _tickUpper,</span>
 119 |     | <span class='neutral'>        uint128 _amount</span>
 120 | *   | <span class='executed'>    ) public returns (MinterStats memory bfre, MinterStats memory aftr) {</span>
 121 | *   | <span class='executed'>        bfre = getStats(_tickLower, _tickUpper);</span>
 122 | *   | <span class='executed'>        pool.mint(address(this), _tickLower, _tickUpper, _amount, new bytes(0));</span>
 123 |     | <span class='neutral'>        aftr = getStats(_tickLower, _tickUpper);</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 | *   | <span class='executed'>    function doBurn(</span>
 127 |     | <span class='neutral'>        int24 _tickLower,</span>
 128 |     | <span class='neutral'>        int24 _tickUpper,</span>
 129 |     | <span class='neutral'>        uint128 _amount</span>
 130 |     | <span class='unexecuted'>    ) public returns (MinterStats memory bfre, MinterStats memory aftr) {</span>
 131 |     | <span class='unexecuted'>        bfre = getStats(_tickLower, _tickUpper);</span>
 132 | *   | <span class='executed'>        pool.burn(_tickLower, _tickUpper, _amount);</span>
 133 | *   | <span class='executed'>        aftr = getStats(_tickLower, _tickUpper);</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'>}</span>
 136 |     | <span class='neutral'></span>
 137 | *   | <span class='executed'>contract UniswapSwapper {</span>
 138 |     | <span class='neutral'>    UniswapV3Pool pool;</span>
 139 |     | <span class='neutral'>    TestERC20 token0;</span>
 140 |     | <span class='neutral'>    TestERC20 token1;</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    struct SwapperStats {</span>
 143 |     | <span class='neutral'>        uint128 liq;</span>
 144 |     | <span class='neutral'>        uint256 feeGrowthGlobal0X128;</span>
 145 |     | <span class='neutral'>        uint256 feeGrowthGlobal1X128;</span>
 146 |     | <span class='neutral'>        uint256 bal0;</span>
 147 |     | <span class='neutral'>        uint256 bal1;</span>
 148 |     | <span class='neutral'>        int24 tick;</span>
 149 |     | <span class='neutral'>    }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='unexecuted'>    constructor(TestERC20 _token0, TestERC20 _token1) {</span>
 152 |     | <span class='unexecuted'>        token0 = _token0;</span>
 153 |     | <span class='unexecuted'>        token1 = _token1;</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'></span>
 156 | *   | <span class='executed'>    function setPool(UniswapV3Pool _pool) public {</span>
 157 | *   | <span class='executed'>        pool = _pool;</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 | *   | <span class='executed'>    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external {</span>
 161 | *   | <span class='executed'>        if (amount0Delta &gt; 0) token0.transfer(address(pool), uint256(amount0Delta));</span>
 162 | *   | <span class='executed'>        if (amount1Delta &gt; 0) token1.transfer(address(pool), uint256(amount1Delta));</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 | *   | <span class='executed'>    function getStats() internal view returns (SwapperStats memory stats) {</span>
 166 | *   | <span class='executed'>        (, int24 currentTick, , , , , ) = pool.slot0();</span>
 167 | *   | <span class='executed'>        return</span>
 168 | *   | <span class='executed'>            SwapperStats(</span>
 169 | *   | <span class='executed'>                pool.liquidity(),</span>
 170 | *   | <span class='executed'>                pool.feeGrowthGlobal0X128(),</span>
 171 | *   | <span class='executed'>                pool.feeGrowthGlobal1X128(),</span>
 172 | *   | <span class='executed'>                token0.balanceOf(address(this)),</span>
 173 | *   | <span class='executed'>                token1.balanceOf(address(this)),</span>
 174 | *   | <span class='executed'>                currentTick</span>
 175 |     | <span class='neutral'>            );</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 | *   | <span class='executed'>    function doSwap(</span>
 179 |     | <span class='neutral'>        bool _zeroForOne,</span>
 180 |     | <span class='neutral'>        int256 _amountSpecified,</span>
 181 |     | <span class='neutral'>        uint160 _sqrtPriceLimitX96</span>
 182 | *   | <span class='executed'>    ) public returns (SwapperStats memory bfre, SwapperStats memory aftr) {</span>
 183 | *   | <span class='executed'>        bfre = getStats();</span>
 184 | *   | <span class='executed'>        pool.swap(address(this), _zeroForOne, _amountSpecified, _sqrtPriceLimitX96, new bytes(0));</span>
 185 | *   | <span class='executed'>        aftr = getStats();</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'>}</span>
 188 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Blogs/Recon_Intro_Clean/v3-core/test/recon/TargetFunctions.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
   2 |     | <span class='neutral'>pragma abicoder v2;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {BaseTargetFunctions} from &#39;@chimera/BaseTargetFunctions.sol&#39;;</span>
   5 |     | <span class='neutral'>import {BeforeAfter} from &#39;./BeforeAfter.sol&#39;;</span>
   6 |     | <span class='neutral'>import {Properties} from &#39;./Properties.sol&#39;;</span>
   7 |     | <span class='neutral'>import {vm} from &#39;@chimera/Hevm.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;contracts/libraries/TickMath.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;test/recon/SetupUniswap.sol&#39;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>abstract contract TargetFunctions is BaseTargetFunctions, Properties, BeforeAfter {</span>
  12 |     | <span class='unexecuted'>    function uniswapV3Pool_collect(</span>
  13 |     | <span class='neutral'>        address recipient,</span>
  14 |     | <span class='neutral'>        int24 tickLower,</span>
  15 |     | <span class='neutral'>        int24 tickUpper,</span>
  16 |     | <span class='neutral'>        uint128 amount0Requested,</span>
  17 |     | <span class='neutral'>        uint128 amount1Requested</span>
  18 |     | <span class='neutral'>    ) public {</span>
  19 |     | <span class='unexecuted'>        uniswapV3Pool.collect(recipient, tickLower, tickUpper, amount0Requested, amount1Requested);</span>
  20 |     | <span class='neutral'>    }</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='unexecuted'>    function uniswapV3Pool_collectProtocol(</span>
  23 |     | <span class='neutral'>        address recipient,</span>
  24 |     | <span class='neutral'>        uint128 amount0Requested,</span>
  25 |     | <span class='neutral'>        uint128 amount1Requested</span>
  26 |     | <span class='neutral'>    ) public {</span>
  27 |     | <span class='unexecuted'>        uniswapV3Pool.collectProtocol(recipient, amount0Requested, amount1Requested);</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='unexecuted'>    function uniswapV3Pool_flash(address recipient, uint256 amount0, uint256 amount1, bytes calldata data) public {</span>
  31 |     | <span class='unexecuted'>        uniswapV3Pool.flash(recipient, amount0, amount1, data);</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>    function uniswapV3Pool_increaseObservationCardinalityNext(uint16 observationCardinalityNext) public {</span>
  35 |     | <span class='unexecuted'>        uniswapV3Pool.increaseObservationCardinalityNext(observationCardinalityNext);</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 | *   | <span class='executed'>    function uniswapV3Pool_initialize(uint160 sqrtPriceX96) public {</span>
  39 | *   | <span class='executed'>        uniswapV3Pool.initialize(sqrtPriceX96);</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 | *   | <span class='executed'>    function uniswapV3Pool_mint(</span>
  43 |     | <span class='neutral'>        address recipient,</span>
  44 |     | <span class='neutral'>        int24 tickLower,</span>
  45 |     | <span class='neutral'>        int24 tickUpper,</span>
  46 |     | <span class='neutral'>        uint128 amount,</span>
  47 |     | <span class='neutral'>        bytes calldata data</span>
  48 |     | <span class='neutral'>    ) public {</span>
  49 |     | <span class='unexecuted'>        uniswapV3Pool.mint(recipient, tickLower, tickUpper, amount, data);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='unexecuted'>    function uniswapV3Pool_setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) public {</span>
  53 |     | <span class='unexecuted'>        uniswapV3Pool.setFeeProtocol(feeProtocol0, feeProtocol1);</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>    function testERC20_approve(address spender, uint256 amount) public {</span>
  57 |     | <span class='unexecuted'>        testERC20.approve(spender, amount);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>    function testERC20_mint(address to, uint256 amount) public {</span>
  61 |     | <span class='unexecuted'>        testERC20.mint(to, amount);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='unexecuted'>    function testERC20_transfer(address recipient, uint256 amount) public {</span>
  65 |     | <span class='unexecuted'>        testERC20.transfer(recipient, amount);</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>    function testERC20_transferFrom(address sender, address recipient, uint256 amount) public {</span>
  69 |     | <span class='unexecuted'>        testERC20.transferFrom(sender, recipient, amount);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    // swap invariant prop #17</span>
  73 | *   | <span class='executed'>    function test_swap_exactIn_zeroForOne(uint128 _amount) public {</span>
  74 | *r  | <span class='executed'>        require(_amount != 0);</span>
  75 |     | <span class='neutral'></span>
  76 | *   | <span class='executed'>        if (!inited) _init(_amount);</span>
  77 |     | <span class='neutral'></span>
  78 | *r  | <span class='executed'>        require(token0.balanceOf(address(swapper)) &gt;= uint256(_amount));</span>
  79 | *   | <span class='executed'>        int256 _amountSpecified = int256(_amount);</span>
  80 |     | <span class='neutral'></span>
  81 | *   | <span class='executed'>        uint160 sqrtPriceLimitX96 = get_random_zeroForOne_priceLimit(_amount);</span>
  82 |     | <span class='neutral'>        // console.log(&#39;sqrtPriceLimitX96 = %s&#39;, sqrtPriceLimitX96);</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>        __before();</span>
  85 |     | <span class='neutral'>        swapper.doSwap(true, _amountSpecified, sqrtPriceLimitX96);</span>
  86 |     | <span class='neutral'>        __after();</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>        int24 beforeCurrentTick = _before.uniswapV3Pool_currentTick;</span>
  89 |     | <span class='neutral'>        int24 afterCurrentTick = _after.uniswapV3Pool_currentTick;</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>        check_swap_invariants(</span>
  92 |     | <span class='neutral'>            beforeCurrentTick,</span>
  93 |     | <span class='neutral'>            afterCurrentTick,</span>
  94 |     | <span class='neutral'>            _before.uniswapV3Pool_liquidity,</span>
  95 |     | <span class='neutral'>            _after.uniswapV3Pool_liquidity,</span>
  96 |     | <span class='neutral'>            _before.testERC20_balanceOfToken0,</span>
  97 |     | <span class='neutral'>            _after.testERC20_balanceOfToken0,</span>
  98 |     | <span class='neutral'>            _before.testERC20_balanceOfToken1,</span>
  99 |     | <span class='neutral'>            _after.testERC20_balanceOfToken1,</span>
 100 |     | <span class='neutral'>            _before.uniswapV3Pool_feeGrowthGlobal0X128,</span>
 101 |     | <span class='neutral'>            _after.uniswapV3Pool_feeGrowthGlobal0X128,</span>
 102 |     | <span class='neutral'>            _before.uniswapV3Pool_feeGrowthGlobal1X128,</span>
 103 |     | <span class='neutral'>            _after.uniswapV3Pool_feeGrowthGlobal1X128</span>
 104 |     | <span class='neutral'>        );</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 | *   | <span class='executed'>    function test_swap_exactIn_oneForZero(uint128 _amount) public {</span>
 108 | *r  | <span class='executed'>        require(_amount != 0);</span>
 109 |     | <span class='neutral'></span>
 110 | *   | <span class='executed'>        if (!inited) _init(_amount);</span>
 111 |     | <span class='neutral'></span>
 112 | *r  | <span class='executed'>        require(token1.balanceOf(address(swapper)) &gt;= uint256(_amount));</span>
 113 | *   | <span class='executed'>        int256 _amountSpecified = int256(_amount);</span>
 114 |     | <span class='neutral'></span>
 115 | *   | <span class='executed'>        uint160 sqrtPriceLimitX96 = get_random_oneForZero_priceLimit(_amount);</span>
 116 |     | <span class='neutral'>        // console.log(&#39;sqrtPriceLimitX96 = %s&#39;, sqrtPriceLimitX96);</span>
 117 |     | <span class='neutral'></span>
 118 | *   | <span class='executed'>        __before();</span>
 119 | *r  | <span class='executed'>        swapper.doSwap(true, _amountSpecified, sqrtPriceLimitX96);</span>
 120 | *   | <span class='executed'>        __after();</span>
 121 |     | <span class='neutral'></span>
 122 | *   | <span class='executed'>        int24 beforeCurrentTick = _before.uniswapV3Pool_currentTick;</span>
 123 | *   | <span class='executed'>        int24 afterCurrentTick = _after.uniswapV3Pool_currentTick;</span>
 124 |     | <span class='neutral'></span>
 125 | *   | <span class='executed'>        check_swap_invariants(</span>
 126 |     | <span class='neutral'>            beforeCurrentTick,</span>
 127 |     | <span class='neutral'>            afterCurrentTick,</span>
 128 | *   | <span class='executed'>            _before.uniswapV3Pool_liquidity,</span>
 129 | *   | <span class='executed'>            _after.uniswapV3Pool_liquidity,</span>
 130 | *   | <span class='executed'>            _before.testERC20_balanceOfToken0,</span>
 131 | *   | <span class='executed'>            _after.testERC20_balanceOfToken0,</span>
 132 | *   | <span class='executed'>            _before.testERC20_balanceOfToken1,</span>
 133 | *   | <span class='executed'>            _after.testERC20_balanceOfToken1,</span>
 134 | *   | <span class='executed'>            _before.uniswapV3Pool_feeGrowthGlobal0X128,</span>
 135 | *   | <span class='executed'>            _after.uniswapV3Pool_feeGrowthGlobal0X128,</span>
 136 | *   | <span class='executed'>            _before.uniswapV3Pool_feeGrowthGlobal1X128,</span>
 137 | *   | <span class='executed'>            _after.uniswapV3Pool_feeGrowthGlobal1X128</span>
 138 |     | <span class='neutral'>        );</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'></span>
 141 | *   | <span class='executed'>    function test_swap_exactOut_zeroForOne(uint128 _amount) public {</span>
 142 | *r  | <span class='executed'>        require(_amount != 0);</span>
 143 |     | <span class='neutral'></span>
 144 | *   | <span class='executed'>        if (!inited) _init(_amount);</span>
 145 |     | <span class='neutral'></span>
 146 | *   | <span class='executed'>        require(token0.balanceOf(address(swapper)) &gt; 0);</span>
 147 | *   | <span class='executed'>        int256 _amountSpecified = -int256(_amount);</span>
 148 |     | <span class='neutral'></span>
 149 | *   | <span class='executed'>        uint160 sqrtPriceLimitX96 = get_random_zeroForOne_priceLimit(_amount);</span>
 150 |     | <span class='neutral'>        // console.log(&#39;sqrtPriceLimitX96 = %s&#39;, sqrtPriceLimitX96);</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>        __before();</span>
 153 |     | <span class='neutral'>        swapper.doSwap(true, _amountSpecified, sqrtPriceLimitX96);</span>
 154 |     | <span class='neutral'>        __after();</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>        int24 beforeCurrentTick = _before.uniswapV3Pool_currentTick;</span>
 157 |     | <span class='neutral'>        int24 afterCurrentTick = _after.uniswapV3Pool_currentTick;</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>        check_swap_invariants(</span>
 160 |     | <span class='neutral'>            beforeCurrentTick,</span>
 161 |     | <span class='neutral'>            afterCurrentTick,</span>
 162 |     | <span class='neutral'>            _before.uniswapV3Pool_liquidity,</span>
 163 |     | <span class='neutral'>            _after.uniswapV3Pool_liquidity,</span>
 164 |     | <span class='neutral'>            _before.testERC20_balanceOfToken0,</span>
 165 |     | <span class='neutral'>            _after.testERC20_balanceOfToken0,</span>
 166 |     | <span class='neutral'>            _before.testERC20_balanceOfToken1,</span>
 167 |     | <span class='neutral'>            _after.testERC20_balanceOfToken1,</span>
 168 |     | <span class='neutral'>            _before.uniswapV3Pool_feeGrowthGlobal0X128,</span>
 169 |     | <span class='neutral'>            _after.uniswapV3Pool_feeGrowthGlobal0X128,</span>
 170 |     | <span class='neutral'>            _before.uniswapV3Pool_feeGrowthGlobal1X128,</span>
 171 |     | <span class='neutral'>            _after.uniswapV3Pool_feeGrowthGlobal1X128</span>
 172 |     | <span class='neutral'>        );</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 | *   | <span class='executed'>    function test_swap_exactOut_oneForZero(uint128 _amount) public {</span>
 176 | *r  | <span class='executed'>        require(_amount != 0);</span>
 177 |     | <span class='neutral'></span>
 178 | *   | <span class='executed'>        if (!inited) _init(_amount);</span>
 179 |     | <span class='neutral'></span>
 180 | *   | <span class='executed'>        require(token0.balanceOf(address(swapper)) &gt; 0);</span>
 181 | *   | <span class='executed'>        int256 _amountSpecified = -int256(_amount);</span>
 182 |     | <span class='neutral'></span>
 183 | *   | <span class='executed'>        uint160 sqrtPriceLimitX96 = get_random_oneForZero_priceLimit(_amount);</span>
 184 |     | <span class='neutral'>        // console.log(&#39;sqrtPriceLimitX96 = %s&#39;, sqrtPriceLimitX96);</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>        __before();</span>
 187 |     | <span class='neutral'>        swapper.doSwap(true, _amountSpecified, sqrtPriceLimitX96);</span>
 188 |     | <span class='neutral'>        __after();</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>        int24 beforeCurrentTick = _before.uniswapV3Pool_currentTick;</span>
 191 |     | <span class='neutral'>        int24 afterCurrentTick = _after.uniswapV3Pool_currentTick;</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='neutral'>        check_swap_invariants(</span>
 194 |     | <span class='neutral'>            beforeCurrentTick,</span>
 195 |     | <span class='neutral'>            afterCurrentTick,</span>
 196 |     | <span class='neutral'>            _before.uniswapV3Pool_liquidity,</span>
 197 |     | <span class='neutral'>            _after.uniswapV3Pool_liquidity,</span>
 198 |     | <span class='neutral'>            _before.testERC20_balanceOfToken0,</span>
 199 |     | <span class='neutral'>            _after.testERC20_balanceOfToken0,</span>
 200 |     | <span class='neutral'>            _before.testERC20_balanceOfToken1,</span>
 201 |     | <span class='neutral'>            _after.testERC20_balanceOfToken1,</span>
 202 |     | <span class='neutral'>            _before.uniswapV3Pool_feeGrowthGlobal0X128,</span>
 203 |     | <span class='neutral'>            _after.uniswapV3Pool_feeGrowthGlobal0X128,</span>
 204 |     | <span class='neutral'>            _before.uniswapV3Pool_feeGrowthGlobal1X128,</span>
 205 |     | <span class='neutral'>            _after.uniswapV3Pool_feeGrowthGlobal1X128</span>
 206 |     | <span class='neutral'>        );</span>
 207 |     | <span class='neutral'>    }</span>
 208 |     | <span class='neutral'>}</span>
 209 |     | <span class='neutral'></span>

</code>
<br />

